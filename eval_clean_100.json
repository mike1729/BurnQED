{
  "theorems": [
    {
      "name": "Filter.inf_principal_eq_bot",
      "statement": "Î± : Type u\nÎ² : Type v\nÎ³ : Type w\nÎ´ : Type u_1\nÎ¹ : Sort x\nfâœ g : Filter Î±\nsâœ t : Set Î±\nf : Filter Î±\ns : Set Î±\nâŠ¢ f âŠ“ ğ“Ÿ s = âŠ¥ â†” sá¶œ âˆˆ f"
    },
    {
      "name": "MeasureTheory.VectorMeasure.restrict_eq_self",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nm instâœÂ³ : MeasurableSpace Î±\ninstâœÂ² : MeasurableSpace Î²\nM : Type u_3\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : TopologicalSpace M\nv : VectorMeasure Î± M\ni : Set Î±\nhi : MeasurableSet i\nj : Set Î±\nhj : MeasurableSet j\nhij : j âŠ† i\nâŠ¢ â†‘(v.restrict i) j = â†‘v j"
    },
    {
      "name": "MulAction.orbit.eq_or_disjoint",
      "statement": "G : Type u_1\ninstâœÂ¹ : Group G\nX : Type u_2\ninstâœ : MulAction G X\na b : X\nâŠ¢ orbit G a = orbit G b âˆ¨ Disjoint (orbit G a) (orbit G b)"
    },
    {
      "name": "Real.diam_Ico",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœ : PseudoEMetricSpace Î±\na b : â„\nh : a â‰¤ b\nâŠ¢ Metric.diam (Ico a b) = b - a"
    },
    {
      "name": "ZMod.cast_descFactorial",
      "statement": "n p : â„•\nh : n â‰¤ p\nâŠ¢ â†‘((p - 1).descFactorial n) = (-1) ^ n * â†‘n !"
    },
    {
      "name": "WithTop.sum_eq_top_iff",
      "statement": "Î¹ : Type u_1\nÎ± : Type u_2\ninstâœÂ¹ : AddCommMonoid Î±\ninstâœ : LT Î±\ns : Finset Î¹\nf : Î¹ â†’ WithTop Î±\nâŠ¢ âˆ‘ i âˆˆ s, f i = âŠ¤ â†” âˆƒ i âˆˆ s, f i = âŠ¤"
    },
    {
      "name": "Equiv.sumCongr_trans",
      "statement": "Î±â‚ : Type u_1\nÎ²â‚ : Type u_2\nÎ±â‚‚ : Type u_3\nÎ²â‚‚ : Type u_4\nÎ³â‚ : Type u_5\nÎ³â‚‚ : Type u_6\ne : Î±â‚ â‰ƒ Î²â‚\nf : Î±â‚‚ â‰ƒ Î²â‚‚\ng : Î²â‚ â‰ƒ Î³â‚\nh : Î²â‚‚ â‰ƒ Î³â‚‚\nâŠ¢ (e.sumCongr f).trans (g.sumCongr h) = (e.trans g).sumCongr (f.trans h)"
    },
    {
      "name": "Nat.coprime_mul_left_add_left",
      "statement": "m n k : â„•\nâŠ¢ (n * k + m).Coprime n â†” m.Coprime n"
    },
    {
      "name": "CategoryTheory.ShortComplex.Ï€â‚ToÏ€â‚‚_comp_Ï€â‚‚ToÏ€â‚ƒ",
      "statement": "C : Type u_1\nD : Type u_2\ninstâœÂ² : Category.{u_3, u_1} C\ninstâœÂ¹ : Category.{?u.31246, u_2} D\ninstâœ : HasZeroMorphisms C\nS Sâ‚ Sâ‚‚ Sâ‚ƒ : ShortComplex C\nâŠ¢ Ï€â‚ToÏ€â‚‚ â‰« Ï€â‚‚ToÏ€â‚ƒ = 0"
    },
    {
      "name": "Ideal.mem_leadingCoeffNth_zero",
      "statement": "R : Type u\nS : Type u_1\ninstâœÂ¹ : CommSemiring R\ninstâœ : Semiring S\nI : Ideal R[X]\nx : R\nxâœ : âˆƒ p âˆˆ I, p.degree â‰¤ â†‘0 âˆ§ p.leadingCoeff = x\np : R[X]\nhpI : p âˆˆ I\nhpdeg : p.degree â‰¤ â†‘0\nhpx : p.leadingCoeff = x\nâŠ¢ C x âˆˆ I"
    },
    {
      "name": "CategoryTheory.Limits.zeroProdIso_inv_snd",
      "statement": "C : Type u_1\ninstâœÂ² : Category.{u_2, u_1} C\ninstâœÂ¹ : HasZeroObject C\ninstâœ : HasZeroMorphisms C\nX : C\nâŠ¢ (zeroProdIso X).inv â‰« prod.snd = ğŸ™ X"
    },
    {
      "name": "catalan_succ",
      "statement": "n : â„•\nâŠ¢ catalan (n + 1) = âˆ‘ i : Fin n.succ, catalan â†‘i * catalan (n - â†‘i)"
    },
    {
      "name": "alternatingGroup.nontrivial_of_three_le_card",
      "statement": "Î± : Type u_1\ninstâœÂ¹ : Fintype Î±\ninstâœ : DecidableEq Î±\nh3 : 3 â‰¤ card Î±\nâŠ¢ Nontrivial â†¥(alternatingGroup Î±)"
    },
    {
      "name": "List.rel_reverse",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\nR S : Î± â†’ Î² â†’ Prop\nP : Î³ â†’ Î´ â†’ Prop\nRâ‚ : Î± â†’ Î± â†’ Prop\naâœ : Î±\nbâœ : Î²\nlâ‚âœ : List Î±\nlâ‚‚âœ : List Î²\nhâ‚ : R aâœ bâœ\nhâ‚‚ : Forallâ‚‚ R lâ‚âœ lâ‚‚âœ\nâŠ¢ Forallâ‚‚ R (aâœ :: lâ‚âœ).reverse (bâœ :: lâ‚‚âœ).reverse"
    },
    {
      "name": "LiouvilleWith.add_nat_iff",
      "statement": "p q x y : â„\nr : â„š\nm : â„¤\nn : â„•\nâŠ¢ LiouvilleWith p (x + â†‘n) â†” LiouvilleWith p x"
    },
    {
      "name": "Stream'.append_append_stream",
      "statement": "Î± : Type u\nÎ² : Type v\nÎ´ : Type w\na : Î±\nlâ‚ lâ‚‚ : List Î±\ns : Stream' Î±\nâŠ¢ a :: lâ‚ ++ lâ‚‚ ++â‚› s = a :: lâ‚ ++â‚› (lâ‚‚ ++â‚› s)"
    },
    {
      "name": "lucas_lehmer_sufficiency",
      "statement": "p : â„•\nw : 1 < p\nâŠ¢ LucasLehmerTest p â†’ Nat.Prime (mersenne p)"
    },
    {
      "name": "Module.AEval.injective_comapSubmodule",
      "statement": "R : Type u_2\nA : Type u_3\nM : Type u_1\ninstâœâ¶ : CommSemiring R\ninstâœâµ : Semiring A\na : A\ninstâœâ´ : Algebra R A\ninstâœÂ³ : AddCommMonoid M\ninstâœÂ² : Module A M\ninstâœÂ¹ : Module R M\ninstâœ : IsScalarTower R A M\np : Submodule R M\nhp : p â‰¤ Submodule.comap ((Algebra.lsmul R R M) a) p\nq : Submodule R[X] (AEval R M a)\nâŠ¢ Injective â‡‘(comapSubmodule R M a)"
    },
    {
      "name": "Int.zero_shiftLeft",
      "statement": "n : â„•\nâŠ¢ Nat.shiftLeft' false 0 n = 0"
    },
    {
      "name": "PadicInt.pow_p_dvd_int_iff",
      "statement": "p : â„•\nhp : Fact (Nat.Prime p)\nn : â„•\na : â„¤\nâŠ¢ â†‘p ^ n âˆ£ â†‘a â†” â†‘p ^ n âˆ£ a"
    },
    {
      "name": "WeierstrassCurve.Affine.equation_zero",
      "statement": "R : Type u\ninstâœ : CommRing R\nW : Affine R\nâŠ¢ W.Equation 0 0 â†” W.aâ‚† = 0"
    },
    {
      "name": "BoxIntegral.Prepartition.IsPartition.inf",
      "statement": "Î¹ : Type u_1\nI J Jâ‚ Jâ‚‚ : Box Î¹\nÏ€ Ï€â‚ Ï€â‚‚ : Prepartition I\nx : Î¹ â†’ â„\nÏ€i Ï€iâ‚ Ï€iâ‚‚ : (J : Box Î¹) â†’ Prepartition J\nhâ‚ : Ï€â‚.IsPartition\nhâ‚‚ : Ï€â‚‚.IsPartition\nâŠ¢ (Ï€â‚ âŠ“ Ï€â‚‚).iUnion = â†‘I"
    },
    {
      "name": "CochainComplex.mappingConeCompTriangle_morâ‚ƒ_naturality",
      "statement": "C : Type u_1\ninstâœÂ³ : Category.{u_2, u_1} C\ninstâœÂ² : Preadditive C\ninstâœÂ¹ : HasZeroObject C\ninstâœ : HasBinaryBiproducts C\nXâ‚ Xâ‚‚ Xâ‚ƒ : CochainComplex C â„¤\nf : Xâ‚ âŸ¶ Xâ‚‚\ng : Xâ‚‚ âŸ¶ Xâ‚ƒ\nYâ‚ Yâ‚‚ Yâ‚ƒ : CochainComplex C â„¤\nf' : Yâ‚ âŸ¶ Yâ‚‚\ng' : Yâ‚‚ âŸ¶ Yâ‚ƒ\nÏ† : mkâ‚‚ f g âŸ¶ mkâ‚‚ f' g'\nâŠ¢ map g g' (Ï†.app 1) (Ï†.app 2) â‹¯ â‰« (mappingConeCompTriangle f' g').morâ‚ƒ =\n    (mappingConeCompTriangle f g).morâ‚ƒ â‰«\n      (CategoryTheory.shiftFunctor (CochainComplex C â„¤) 1).map (map f f' (Ï†.app 0) (Ï†.app 1) â‹¯)"
    },
    {
      "name": "Finset.Ioc_subset_Ioi_self",
      "statement": "Î¹ : Type u_1\nÎ± : Type u_2\ninstâœÂ² : Preorder Î±\ninstâœÂ¹ : LocallyFiniteOrder Î±\na aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±\ninstâœ : LocallyFiniteOrderTop Î±\nâŠ¢ Ioc a b âŠ† Ioi a"
    },
    {
      "name": "LipschitzWith.coordinate",
      "statement": "Î± : Type u_1\nE : Î± â†’ Type u_2\np q : â„â‰¥0âˆ\ninstâœÂ¹ : (i : Î±) â†’ NormedAddCommGroup (E i)\nÎ¹ : Type u_3\ninstâœ : PseudoMetricSpace Î±\nf : Î± â†’ â†¥(lp (fun i => â„) âŠ¤)\nK : â„â‰¥0\nâŠ¢ LipschitzWith K f â†” âˆ€ (i : Î¹), LipschitzWith K fun a => â†‘(f a) i"
    },
    {
      "name": "Filter.iInf_principal",
      "statement": "Î± : Type u\nÎ² : Type v\nÎ³ : Type w\nÎ´ : Type u_1\nÎ¹âœ : Sort x\nfâœ g : Filter Î±\ns t : Set Î±\nÎ¹ : Sort w\ninstâœ : Finite Î¹\nf : Î¹ â†’ Set Î±\nâŠ¢ â¨… i, ğ“Ÿ (f i) = ğ“Ÿ (â‹‚ i, f i)"
    },
    {
      "name": "CategoryTheory.Iso.trans_assoc",
      "statement": "C : Type u\ninstâœ : Category.{v, u} C\nX Y Z Z' : C\nÎ± : X â‰… Y\nÎ² : Y â‰… Z\nÎ³ : Z â‰… Z'\nâŠ¢ (Î± â‰ªâ‰« Î²) â‰ªâ‰« Î³ = Î± â‰ªâ‰« Î² â‰ªâ‰« Î³"
    },
    {
      "name": "Real.cauchy_one",
      "statement": "x y : â„\nâŠ¢ Real.one.cauchy = 1"
    },
    {
      "name": "TopologicalSpace.Closeds.mem_iInf",
      "statement": "Î¹âœ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalSpace Î²\nÎ¹ : Sort u_4\nx : Î±\ns : Î¹ â†’ Closeds Î±\nâŠ¢ x âˆˆ iInf s â†” âˆ€ (i : Î¹), x âˆˆ s i"
    },
    {
      "name": "List.rdrop_append_length",
      "statement": "Î± : Type u_1\np : Î± â†’ Bool\nl : List Î±\nn : â„•\nlâ‚ lâ‚‚ : List Î±\nâŠ¢ (lâ‚ ++ lâ‚‚).rdrop lâ‚‚.length = lâ‚"
    },
    {
      "name": "Real.Angle.two_zsmul_toReal_eq_two_mul",
      "statement": "Î¸ : Angle\nâŠ¢ (2 â€¢ Î¸).toReal = 2 * Î¸.toReal â†” Î¸.toReal âˆˆ Set.Ioc (-Ï€ / 2) (Ï€ / 2)"
    },
    {
      "name": "SetTheory.PGame.neg_le_iff",
      "statement": "xl xr : Type u\nx y : PGame\nâŠ¢ -y â‰¤ x â†” -x â‰¤ y"
    },
    {
      "name": "Finset.card_inter",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nR : Type u_3\nsâœ tâœ u : Finset Î±\nf : Î± â†’ Î²\nn : â„•\ninstâœ : DecidableEq Î±\ns t : Finset Î±\nâŠ¢ (s âˆ© t).card = s.card + t.card - (s âˆª t).card"
    },
    {
      "name": "Function.Antiperiodic.add_nat_mul_eq",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nf g : Î± â†’ Î²\nc câ‚ câ‚‚ x : Î±\ninstâœÂ¹ : Semiring Î±\ninstâœ : Ring Î²\nh : Antiperiodic f c\nn : â„•\nâŠ¢ f (x + â†‘n * c) = (-1) ^ n * f x"
    },
    {
      "name": "RingQuot.mkRingHom_rel",
      "statement": "R : Type uR\ninstâœÂ³ : Semiring R\nS : Type uS\ninstâœÂ² : CommSemiring S\nT : Type uT\nA : Type uA\ninstâœÂ¹ : Semiring A\ninstâœ : Algebra S A\nrâœ r : R â†’ R â†’ Prop\nx y : R\nw : r x y\nâŠ¢ (mkRingHom r) x = (mkRingHom r) y"
    },
    {
      "name": "Set.ncard_diff_singleton_lt_of_mem",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\ns t : Set Î±\na : Î±\nh : a âˆˆ s\nhs : autoParam s.Finite _autoâœ\nâŠ¢ (s \\ {a}).ncard < s.ncard"
    },
    {
      "name": "BoxIntegral.Prepartition.ofWithBot_le",
      "statement": "Î¹ : Type u_1\nI J Jâ‚ Jâ‚‚ : Box Î¹\nÏ€ Ï€â‚ Ï€â‚‚ : Prepartition I\nx : Î¹ â†’ â„\nÏ€i Ï€iâ‚ Ï€iâ‚‚ : (J : Box Î¹) â†’ Prepartition J\nboxes : Finset (WithBot (Box Î¹))\nle_of_mem : âˆ€ J âˆˆ boxes, J â‰¤ â†‘I\npairwise_disjoint : (â†‘boxes).Pairwise Disjoint\nH : âˆ€ J âˆˆ boxes, J â‰  âŠ¥ â†’ âˆƒ J' âˆˆ Ï€, J â‰¤ â†‘J'\nâŠ¢ ofWithBot boxes le_of_mem pairwise_disjoint â‰¤ Ï€"
    },
    {
      "name": "AlgebraicTopology.alternatingFaceMapComplex_obj_d",
      "statement": "C : Type u_1\ninstâœÂ¹ : Category.{u_2, u_1} C\ninstâœ : Preadditive C\nX : SimplicialObject C\nn : â„•\nâŠ¢ ((alternatingFaceMapComplex C).obj X).d (n + 1) n = AlternatingFaceMapComplex.objD X n"
    },
    {
      "name": "NonUnitalRingHom.range_eq_map",
      "statement": "R : Type u\nS : Type v\nT : Type u_1\ninstâœÂ² : NonUnitalNonAssocRing R\ninstâœÂ¹ : NonUnitalNonAssocRing S\ninstâœ : NonUnitalNonAssocRing T\ng : S â†’â‚™+* T\nfâœ f : R â†’â‚™+* S\nâŠ¢ f.range = NonUnitalSubring.map f âŠ¤"
    },
    {
      "name": "tprod_eq_one_of_not_multipliable",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ¹ : CommMonoid Î±\ninstâœ : TopologicalSpace Î±\nf g : Î² â†’ Î±\na b : Î±\ns : Finset Î²\nh : Â¬Multipliable f\nâŠ¢ âˆ' (b : Î²), f b = 1"
    },
    {
      "name": "IsCompact.closure_eq_biUnion_inseparable",
      "statement": "X : Type u_1\nY : Type u_2\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : FirstCountableTopology X\ninstâœ : R1Space X\nx y : X\nK : Set X\nhK : IsCompact K\nâŠ¢ closure K = â‹ƒ x âˆˆ K, {y | Inseparable x y}"
    },
    {
      "name": "Num.sub_to_nat",
      "statement": "Î± : Type u_1\nm n : Num\nâŠ¢ â†‘(ofZNum (m.sub' n)) = â†‘m - â†‘n"
    },
    {
      "name": "LinearMap.trace_mul_cycle",
      "statement": "R : Type u\ninstâœâ¶ : CommSemiring R\nM : Type v\ninstâœâµ : AddCommMonoid M\ninstâœâ´ : Module R M\nÎ¹ : Type w\ninstâœÂ³ : DecidableEq Î¹\ninstâœÂ² : Fintype Î¹\nÎº : Type u_1\ninstâœÂ¹ : DecidableEq Îº\ninstâœ : Fintype Îº\nb : Basis Î¹ R M\nc : Basis Îº R M\nf g h : M â†’â‚—[R] M\nâŠ¢ (trace R M) (f * g * h) = (trace R M) (h * f * g)"
    },
    {
      "name": "SimpleGraph.Walk.IsHamiltonianCycle.support_count_of_ne",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : Fintype Î±\ninstâœÂ² : Fintype Î²\ninstâœÂ¹ : DecidableEq Î±\ninstâœ : DecidableEq Î²\nG : SimpleGraph Î±\na b : Î±\npâœ : G.Walk a b\np : G.Walk a a\nhp : p.IsHamiltonianCycle\nh : a â‰  b\nâŠ¢ List.count b p.support = 1"
    },
    {
      "name": "Matrix.nondegenerate_of_det_ne_zero",
      "statement": "m : Type u_1\nR : Type u_2\nA : Type u_3\ninstâœâ´ : Fintype m\ninstâœÂ³ : CommRing R\ninstâœÂ² : CommRing A\ninstâœÂ¹ : IsDomain A\ninstâœ : DecidableEq m\nM : Matrix m m A\nhM : M.det â‰  0\nâŠ¢ M.Nondegenerate"
    },
    {
      "name": "Nat.card_eq_card_toFinset",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\ns : Set Î±\ninstâœ : Fintype â†‘s\nâŠ¢ Nat.card â†‘s = s.toFinset.card"
    },
    {
      "name": "closureOperator_gi_self",
      "statement": "Î± : Type u_1\nÎ¹ : Sort u_2\nÎº : Î¹ â†’ Sort u_3\nÎ² : Type u_4\ninstâœ : PartialOrder Î±\nc : ClosureOperator Î±\nâŠ¢ â‹¯.closureOperator = c"
    },
    {
      "name": "map_nonneg",
      "statement": "F : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\nÎ´ : Type u_5\ninstâœâ¶ : FunLike F Î± Î²\ninstâœâµ : Preorder Î±\ninstâœâ´ : Zero Î±\ninstâœÂ³ : Preorder Î²\ninstâœÂ² : Zero Î²\ninstâœÂ¹ : OrderHomClass F Î± Î²\ninstâœ : ZeroHomClass F Î± Î²\nf : F\na : Î±\nha : 0 â‰¤ a\nâŠ¢ 0 â‰¤ f a"
    },
    {
      "name": "CategoryTheory.SimplicialObject.Ïƒ_comp_Ïƒ",
      "statement": "C : Type u\ninstâœ : Category.{v, u} C\nX : SimplicialObject C\nn : â„•\ni j : Fin (n + 1)\nH : i â‰¤ j\nâŠ¢ X.Ïƒ j â‰« X.Ïƒ i.castSucc = X.Ïƒ i â‰« X.Ïƒ j.succ"
    },
    {
      "name": "segment_same",
      "statement": "ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\nÎ¹ : Type u_5\nÏ€ : Î¹ â†’ Type u_6\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : Module ğ•œ E\ns : Set E\nxâœÂ¹ y zâœ x z : E\nxâœ : z âˆˆ [x-[ğ•œ]x]\na b : ğ•œ\nleftâœÂ¹ : 0 â‰¤ a\nleftâœ : 0 â‰¤ b\nhab : a + b = 1\nhz : a â€¢ x + b â€¢ x = z\nâŠ¢ z âˆˆ {x}"
    },
    {
      "name": "Finmap.lookup_insert",
      "statement": "Î± : Type u\nÎ² : Î± â†’ Type v\ninstâœ : DecidableEq Î±\na : Î±\nb : Î² a\nsâœ : Finmap Î²\ns : AList Î²\nâŠ¢ lookup a (insert a b âŸ¦sâŸ§) = some b"
    },
    {
      "name": "AkraBazziRecurrence.GrowsPolynomially.inv",
      "statement": "fâœ f : â„ â†’ â„\nhf : GrowsPolynomially f\nâŠ¢ GrowsPolynomially fun x => (f x)â»Â¹"
    },
    {
      "name": "Vector.naturality",
      "statement": "n : â„•\nF G : Type u â†’ Type u\ninstâœÂ³ : Applicative F\ninstâœÂ² : Applicative G\ninstâœÂ¹ : LawfulApplicative F\ninstâœ : LawfulApplicative G\nÎ±âœ Î²âœ Î³ : Type u\nÎ· : ApplicativeTransformation F G\nÎ± Î² : Type u\nf : Î± â†’ F Î²\nx : Vector Î± n\nâŠ¢ (fun {Î±} => Î·.app Î±) (Vector.traverse f x) = Vector.traverse ((fun {Î±} => Î·.app Î±) âˆ˜ f) x"
    },
    {
      "name": "MeasureTheory.sFinite_withDensity_of_sigmaFinite_of_measurable",
      "statement": "Î± : Type u_1\nm0 : MeasurableSpace Î±\nÎ¼âœ Î¼ : Measure Î±\ninstâœ : SigmaFinite Î¼\nf : Î± â†’ â„â‰¥0âˆ\nhf : Measurable f\nâŠ¢ SFinite (Î¼.withDensity f)"
    },
    {
      "name": "unitInterval.continuous_qRight",
      "statement": "âŠ¢ Continuous fun p => 2 * â†‘p.1"
    },
    {
      "name": "multiplicity.mul'",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : CancelCommMonoidWithZero Î±\ninstâœ : DecidableRel fun x x_1 => x âˆ£ x_1\np a b : Î±\nhp : Prime p\nh : (multiplicity p (a * b)).Dom\nâŠ¢ (multiplicity p (a * b)).get h = (multiplicity p a).get â‹¯ + (multiplicity p b).get â‹¯"
    },
    {
      "name": "IsPrimePow.exists_ord_compl_eq_one",
      "statement": "R : Type u_1\ninstâœ : CommMonoidWithZero R\nnâœ p : R\nk n : â„•\nh : IsPrimePow n\nâŠ¢ âˆƒ p, Nat.Prime p âˆ§ n / p ^ n.factorization p = 1"
    },
    {
      "name": "Nat.Prime.multiplicity_choose'",
      "statement": "p n k b : â„•\nhp : Prime p\nhnb : log p (n + k) < b\nâŠ¢ multiplicity p ((n + k).choose k) = â†‘(filter (fun i => p ^ i â‰¤ k % p ^ i + n % p ^ i) (Ico 1 b)).card"
    },
    {
      "name": "isNoetherian_of_tower",
      "statement": "R : Type u_1\nS : Type u_2\nM : Type u_3\ninstâœâ¶ : Semiring R\ninstâœâµ : Semiring S\ninstâœâ´ : AddCommMonoid M\ninstâœÂ³ : SMul R S\ninstâœÂ² : Module S M\ninstâœÂ¹ : Module R M\ninstâœ : IsScalarTower R S M\nh : IsNoetherian R M\nâŠ¢ IsNoetherian S M"
    },
    {
      "name": "Matroid.uniqueBaseOn_basis_iff",
      "statement": "Î± : Type u_1\nM : Matroid Î±\nE B I X R J : Set Î±\nhI : I âŠ† E\nhX : X âŠ† E\nâŠ¢ (uniqueBaseOn I E).Basis J X â†” J = X âˆ© I"
    },
    {
      "name": "PMF.mem_support_ofMultiset_iff",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ns : Multiset Î±\nhs : s â‰  0\na : Î±\nâŠ¢ a âˆˆ (ofMultiset s hs).support â†” a âˆˆ s.toFinset"
    },
    {
      "name": "IsCompact.disjoint_nhdsSet_right",
      "statement": "X : Type u\nY : Type v\nÎ¹ : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\ns t : Set X\nl : Filter X\nhs : IsCompact s\nâŠ¢ Disjoint l (ğ“Ë¢ s) â†” âˆ€ x âˆˆ s, Disjoint l (ğ“ x)"
    },
    {
      "name": "Set.chainHeight_eq_iSup_Iic",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\ns t : Set Î±\ninstâœ : Preorder Î±\nâŠ¢ s.chainHeight = â¨† i âˆˆ s, (s âˆ© Iic i).chainHeight"
    },
    {
      "name": "Convex.add_smul_mem_interior'",
      "statement": "Î¹ : Type u_1\nğ•œ : Type u_2\nE : Type u_3\ninstâœâµ : LinearOrderedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module ğ•œ E\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : TopologicalAddGroup E\ninstâœ : ContinuousConstSMul ğ•œ E\ns : Set E\nhs : Convex ğ•œ s\nx y : E\nhx : x âˆˆ closure s\nhy : x + y âˆˆ interior s\nt : ğ•œ\nht : t âˆˆ Ioc 0 1\nâŠ¢ x + t â€¢ y âˆˆ interior s"
    },
    {
      "name": "CategoryTheory.Limits.colimitUncurryIsoColimitCompColim_Î¹_hom",
      "statement": "J K : Type v\ninstâœâµ : SmallCategory J\ninstâœâ´ : SmallCategory K\nC : Type u\ninstâœÂ³ : Category.{v, u} C\nF : J â¥¤ K â¥¤ C\ninstâœÂ² : HasColimitsOfShape K C\ninstâœÂ¹ : HasColimit (uncurry.obj F)\ninstâœ : HasColimit (F â‹™ colim)\nj : J\nk : K\nâŠ¢ colimit.Î¹ (uncurry.obj F) (j, k) â‰« (colimitUncurryIsoColimitCompColim F).hom =\n    colimit.Î¹ (F.obj j) k â‰« colimit.Î¹ (F â‹™ colim) j"
    },
    {
      "name": "Real.sin_eq_sqrt_one_sub_cos_sq",
      "statement": "x : â„\nhl : 0 â‰¤ x\nhu : x â‰¤ Ï€\nâŠ¢ sin x = âˆš(1 - cos x ^ 2)"
    },
    {
      "name": "ModularGroup.exists_eq_T_zpow_of_c_eq_zero",
      "statement": "g : SL(2, â„¤)\nz : â„\nhc : â†‘g 1 0 = 0\nâŠ¢ âˆƒ n, âˆ€ (z : â„), g â€¢ z = T ^ n â€¢ z"
    },
    {
      "name": "PadicInt.valuation_nonneg",
      "statement": "p : â„•\nhp : Fact (Nat.Prime p)\nx : â„¤_[p]\nâŠ¢ 0 â‰¤ x.valuation"
    },
    {
      "name": "Cardinal.zero_lt_lift_iff",
      "statement": "Î± Î² : Type u\na : Cardinal.{u}\nâŠ¢ 0 < lift.{v, u} a â†” 0 < a"
    },
    {
      "name": "Mathlib.Meta.NormNum.isRat_inv_zero",
      "statement": "Î± : Type u_1\ninstâœ : DivisionRing Î±\nâŠ¢ (â†‘0)â»Â¹ = â†‘0"
    },
    {
      "name": "List.get?_zero_mul_tail_prod",
      "statement": "Î¹ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nM : Type u_4\nN : Type u_5\nP : Type u_6\nG : Type u_7\ninstâœÂ² : Monoid M\ninstâœÂ¹ : Monoid N\ninstâœ : Monoid P\nlâœ lâ‚ lâ‚‚ : List M\na : M\nl : List M\nâŠ¢ (l.get? 0).getD 1 * l.tail.prod = l.prod"
    },
    {
      "name": "Submodule.mul_one",
      "statement": "Î¹ : Sort uÎ¹\nR : Type u\ninstâœÂ² : CommSemiring R\nA : Type v\ninstâœÂ¹ : Semiring A\ninstâœ : Algebra R A\nS T : Set A\nM N P Q : Submodule R A\nm n : A\nâŠ¢ M * 1 = M"
    },
    {
      "name": "ProbabilityTheory.IndepSets_iff",
      "statement": "Î© : Type u_1\nÎ¹ : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\nÎº : Î¹ â†’ Type u_5\nÏ€ : Î¹ â†’ Set (Set Î©)\nm : Î¹ â†’ MeasurableSpace Î©\nxâœ : MeasurableSpace Î©\nÎ¼âœ : Measure Î©\nS : Finset Î¹\ns : Î¹ â†’ Set Î©\ns1 s2 : Set (Set Î©)\nÎ¼ : Measure Î©\nâŠ¢ IndepSets s1 s2 Î¼ â†” âˆ€ (t1 t2 : Set Î©), t1 âˆˆ s1 â†’ t2 âˆˆ s2 â†’ Î¼ (t1 âˆ© t2) = Î¼ t1 * Î¼ t2"
    },
    {
      "name": "CircleDeg1Lift.le_translationNumber_of_add_int_le",
      "statement": "f g : CircleDeg1Lift\nx : â„\nm : â„¤\nh : x + â†‘m â‰¤ f x\nn : â„•\nâŠ¢ x + â†‘m * (â†‘n + 1) â‰¤ (f ^ (n + 1)) x"
    },
    {
      "name": "CategoryTheory.IsIso.Iso.inv_hom",
      "statement": "C : Type u\ninstâœ : Category.{v, u} C\nX Y Z : C\nfâœ g : X âŸ¶ Y\nh : Y âŸ¶ Z\nf : X â‰… Y\nâŠ¢ inv f.hom = f.inv"
    },
    {
      "name": "CategoryTheory.Sheaf.isSeparated",
      "statement": "C : Type uâ‚\ninstâœâ· : Category.{vâ‚, uâ‚} C\nA : Type uâ‚‚\ninstâœâ¶ : Category.{vâ‚‚, uâ‚‚} A\nB : Type uâ‚ƒ\ninstâœâµ : Category.{vâ‚ƒ, uâ‚ƒ} B\nJ : GrothendieckTopology C\nU : C\nR : Presieve U\nFâœ G H : A â¥¤ B\nÎ· : Fâœ âŸ¶ G\nÎ³ : G âŸ¶ H\ninstâœâ´ : J.HasSheafCompose Fâœ\ninstâœÂ³ : J.HasSheafCompose G\ninstâœÂ² : J.HasSheafCompose H\ninstâœÂ¹ : ConcreteCategory A\ninstâœ : J.HasSheafCompose (forget A)\nF : Sheaf J A\nâŠ¢ Presheaf.IsSeparated J F.val"
    },
    {
      "name": "Fin.cons_le_cons",
      "statement": "m n : â„•\nÎ± : Fin (n + 1) â†’ Type u\nxâœ : Î± 0\nq : (i : Fin (n + 1)) â†’ Î± i\np : (i : Fin n) â†’ Î± i.succ\ni : Fin n\nyâœ : Î± i.succ\nz : Î± 0\ninstâœ : (i : Fin (n + 1)) â†’ Preorder (Î± i)\nxâ‚€ yâ‚€ : Î± 0\nx y : (i : Fin n) â†’ Î± i.succ\nâŠ¢ (âˆ€ (i : Fin n), cons xâ‚€ x i.succ â‰¤ cons yâ‚€ y i.succ) â†” x â‰¤ y"
    },
    {
      "name": "NNRat.cast_inv_of_ne_zero",
      "statement": "F : Type u_1\nÎ¹ : Type u_2\nÎ± : Type u_3\nÎ² : Type u_4\ninstâœ : DivisionSemiring Î±\nq r : â„šâ‰¥0\nhq : â†‘q.num â‰  0\nâŠ¢ â†‘qâ»Â¹ = (â†‘q)â»Â¹"
    },
    {
      "name": "IsLocalization.toInvSubmonoid_eq_mk'",
      "statement": "R : Type u_1\ninstâœâ´ : CommRing R\nM : Submonoid R\nS : Type u_2\ninstâœÂ³ : CommRing S\ninstâœÂ² : Algebra R S\nP : Type u_3\ninstâœÂ¹ : CommRing P\ninstâœ : IsLocalization M S\nx : â†¥M\nâŠ¢ â†‘((toInvSubmonoid M S) x) = mk' S 1 x"
    },
    {
      "name": "CochainComplex.HomComplex.Cochain.units_smul_comp",
      "statement": "C : Type u\ninstâœÂ³ : Category.{v, u} C\ninstâœÂ² : Preadditive C\nR : Type u_1\ninstâœÂ¹ : Ring R\ninstâœ : Linear R C\nF G K L : CochainComplex C â„¤\nn m nâ‚ nâ‚‚ nâ‚â‚‚ : â„¤\nk : RË£\nzâ‚ : Cochain F G nâ‚\nzâ‚‚ : Cochain G K nâ‚‚\nh : nâ‚ + nâ‚‚ = nâ‚â‚‚\nâŠ¢ (k â€¢ zâ‚).comp zâ‚‚ h = k â€¢ zâ‚.comp zâ‚‚ h"
    },
    {
      "name": "CategoryTheory.shift_shiftFunctorCompIsoId_add_neg_self_hom_app",
      "statement": "C : Type u\nA : Type u_1\ninstâœÂ² : Category.{v, u} C\ninstâœÂ¹ : AddGroup A\ninstâœ : HasShift C A\nXâœ Y : C\nf : Xâœ âŸ¶ Y\nn : A\nX : C\nâŠ¢ (shiftFunctor C n).map ((shiftFunctorCompIsoId C n (-n) â‹¯).hom.app X) =\n    (shiftFunctorCompIsoId C (-n) n â‹¯).hom.app ((shiftFunctor C n).obj X)"
    },
    {
      "name": "Function.Antiperiodic.mul",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nf g : Î± â†’ Î²\nc câ‚ câ‚‚ x : Î±\ninstâœÂ² : Add Î±\ninstâœÂ¹ : Mul Î²\ninstâœ : HasDistribNeg Î²\nhf : Antiperiodic f c\nhg : Antiperiodic g c\nâŠ¢ Periodic (f * g) c"
    },
    {
      "name": "DiscreteValuationRing.addVal_le_iff_dvd",
      "statement": "R : Type u_1\ninstâœÂ² : CommRing R\ninstâœÂ¹ : IsDomain R\ninstâœ : DiscreteValuationRing R\na b : R\nâŠ¢ (addVal R) a â‰¤ (addVal R) b â†” a âˆ£ b"
    },
    {
      "name": "Set.one_mem_centralizer",
      "statement": "M : Type u_1\nS T : Set M\ninstâœ : MulOneClass M\nâŠ¢ 1 âˆˆ S.centralizer"
    },
    {
      "name": "MvPolynomial.coe_mul",
      "statement": "Ïƒ : Type u_1\nR : Type u_2\ninstâœ : CommSemiring R\nÏ† Ïˆ : MvPolynomial Ïƒ R\nn : Ïƒ â†’â‚€ â„•\nâŠ¢ (MvPowerSeries.coeff R n) â†‘(Ï† * Ïˆ) = (MvPowerSeries.coeff R n) (â†‘Ï† * â†‘Ïˆ)"
    },
    {
      "name": "List.ofFn_eq_nil_iff",
      "statement": "Î± : Type u\nn : â„•\nf : Fin n â†’ Î±\nâŠ¢ ofFn f = [] â†” n = 0"
    },
    {
      "name": "analyticAt_clog",
      "statement": "E : Type\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace â„‚ E\nf g : E â†’ â„‚\nz : â„‚\nx : E\ns : Set E\nm : z âˆˆ slitPlane\nâŠ¢ AnalyticAt â„‚ log z"
    },
    {
      "name": "Orientation.oangle_smul_right_of_neg",
      "statement": "V : Type u_1\nV' : Type u_2\ninstâœâµ : NormedAddCommGroup V\ninstâœâ´ : NormedAddCommGroup V'\ninstâœÂ³ : InnerProductSpace â„ V\ninstâœÂ² : InnerProductSpace â„ V'\ninstâœÂ¹ : Fact (finrank â„ V = 2)\ninstâœ : Fact (finrank â„ V' = 2)\no : Orientation â„ V (Fin 2)\nx y : V\nr : â„\nhr : r < 0\nâŠ¢ o.oangle x (r â€¢ y) = o.oangle x (-y)"
    },
    {
      "name": "CategoryTheory.Limits.CokernelCofork.Ï€_eq_zero",
      "statement": "C : Type u\ninstâœÂ¹ : Category.{v, u} C\ninstâœ : HasZeroMorphisms C\nX Y : C\nf : X âŸ¶ Y\ns : CokernelCofork f\nâŠ¢ s.Î¹.app zero = 0"
    },
    {
      "name": "Finset.card_eq_sum_ones",
      "statement": "Î¹ : Type u_1\nÎº : Type u_2\nÎ± : Type u_3\nÎ² : Type u_4\nÎ³ : Type u_5\nsâœ sâ‚ sâ‚‚ : Finset Î±\na : Î±\nf g : Î± â†’ Î²\ns : Finset Î±\nâŠ¢ s.card = âˆ‘ x âˆˆ s, 1"
    },
    {
      "name": "Matrix.map_id",
      "statement": "l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nm' : o â†’ Type u_5\nn' : o â†’ Type u_6\nR : Type u_7\nS : Type u_8\nÎ± : Type v\nÎ² : Type w\nÎ³ : Type u_9\nM : Matrix m n Î±\nâŠ¢ M.map id = M"
    },
    {
      "name": "IsCyclotomicExtension.adjoin_roots_cyclotomic_eq_adjoin_root_cyclotomic",
      "statement": "nâœ : â„•+\nS T : Set â„•+\nA : Type u\nB : Type v\nK : Type w\nL : Type z\ninstâœâ¶ : CommRing A\ninstâœâµ : CommRing B\ninstâœâ´ : Algebra A B\ninstâœÂ³ : Field K\ninstâœÂ² : Field L\ninstâœÂ¹ : Algebra K L\nn : â„•+\ninstâœ : IsDomain B\nÎ¶ : B\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘n\nâŠ¢ adjoin A ((cyclotomic (â†‘n) A).rootSet B) = adjoin A {Î¶}"
    },
    {
      "name": "LieModule.traceForm_eq_sum_weightSpaceOf",
      "statement": "R : Type u_1\nK : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœÂ¹Â² : CommRing R\ninstâœÂ¹Â¹ : LieRing L\ninstâœÂ¹â° : LieAlgebra R L\ninstâœâ¹ : AddCommGroup M\ninstâœâ¸ : Module R M\ninstâœâ· : LieRingModule L M\ninstâœâ¶ : LieModule R L M\ninstâœâµ : Module.Free R M\ninstâœâ´ : Module.Finite R M\ninstâœÂ³ : LieAlgebra.IsNilpotent R L\ninstâœÂ² : IsDomain R\ninstâœÂ¹ : IsPrincipalIdealRing R\ninstâœ : IsTriangularizable R L M\nz : L\nâŠ¢ traceForm R L M = âˆ‘ Ï‡ âˆˆ â‹¯.toFinset, traceForm R L â†¥â†‘(weightSpaceOf M Ï‡ z)"
    },
    {
      "name": "MeasureTheory.lintegral_eq_lmarginal_univ",
      "statement": "Î´ : Type u_1\nÎ´' : Type u_2\nÏ€ : Î´ â†’ Type u_3\ninstâœÂ³ : (x : Î´) â†’ MeasurableSpace (Ï€ x)\nÎ¼ : (i : Î´) â†’ Measure (Ï€ i)\ninstâœÂ² : âˆ€ (i : Î´), SigmaFinite (Î¼ i)\ninstâœÂ¹ : DecidableEq Î´\ns t : Finset Î´\nfâœ g : ((i : Î´) â†’ Ï€ i) â†’ â„â‰¥0âˆ\nxâœ y : (i : Î´) â†’ Ï€ i\ni : Î´\ninstâœ : Fintype Î´\nf : ((i : Î´) â†’ Ï€ i) â†’ â„â‰¥0âˆ\nx : (i : Î´) â†’ Ï€ i\nâŠ¢ âˆ«â» (x : (i : Î´) â†’ Ï€ i), f x âˆ‚Measure.pi Î¼ = (âˆ«â‹¯âˆ«â»_Finset.univ, f âˆ‚Î¼) x"
    },
    {
      "name": "Filter.Tendsto.atBot_mul_atTop",
      "statement": "Î¹ : Type u_1\nÎ¹' : Type u_2\nÎ± : Type u_3\nÎ² : Type u_4\nÎ³ : Type u_5\ninstâœ : OrderedRing Î±\nl : Filter Î²\nf g : Î² â†’ Î±\nhf : Tendsto f l atBot\nhg : Tendsto g l atTop\nâŠ¢ Tendsto (fun x => f x * g x) l atBot"
    },
    {
      "name": "Option.bnot_isSome",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\na : Option Î±\nâŠ¢ (!a.isSome) = a.isNone"
    },
    {
      "name": "Real.toNNReal_le_toNNReal_iff",
      "statement": "r p : â„\nhp : 0 â‰¤ p\nâŠ¢ r.toNNReal â‰¤ p.toNNReal â†” r â‰¤ p"
    },
    {
      "name": "CategoryTheory.leftAdjointMate_id",
      "statement": "C : Type uâ‚\ninstâœÂ² : Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : MonoidalCategory C\nX : C\ninstâœ : HasLeftDual X\nâŠ¢ (á˜ğŸ™ X) = ğŸ™ á˜X"
    },
    {
      "name": "Finset.singleton_subset_set_iff",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nsâœ : Finset Î±\naâœ b : Î±\ns : Set Î±\na : Î±\nâŠ¢ â†‘{a} âŠ† s â†” a âˆˆ s"
    },
    {
      "name": "mul_one_div",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nG : Type u_3\nM : Type u_4\ninstâœ : DivInvMonoid G\na b c x y : G\nâŠ¢ x * (1 / y) = x / y"
    }
  ]
}