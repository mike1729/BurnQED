{
  "theorems": [
    {
      "name": "AList.insert_lookupFinsupp",
      "statement": "Î± : Type u_1\nM : Type u_2\ninstâœÂ¹ : Zero M\ninstâœ : DecidableEq Î±\nl : AList fun _x => M\na : Î±\nm : M\nâŠ¢ (insert a m l).lookupFinsupp = l.lookupFinsupp.update a m"
    },
    {
      "name": "AList.lookupFinsupp_support",
      "statement": "Î± : Type u_1\nM : Type u_2\ninstâœÂ² : Zero M\ninstâœÂ¹ : DecidableEq Î±\ninstâœ : DecidableEq M\nl : AList fun _x => M\nâŠ¢ l.lookupFinsupp.support = (filter (fun x => decide (x.snd â‰  0)) l.entries).keys.toFinset"
    },
    {
      "name": "AbsoluteValue.map_neg",
      "statement": "Î¹ : Type u_1\nÎ± : Type u_2\nR : Type u_3\nS : Type u_4\ninstâœÂ² : OrderedCommRing S\ninstâœÂ¹ : Ring R\nabv : AbsoluteValue R S\ninstâœ : NoZeroDivisors S\na : R\nâŠ¢ abv (-a) = abv a"
    },
    {
      "name": "AddChar.coe_mk",
      "statement": "A : Type u_1\nB : Type u_2\nM : Type u_3\nN : Type u_4\ninstâœÂ³ : AddMonoid A\ninstâœÂ² : AddMonoid B\ninstâœÂ¹ : Monoid M\ninstâœ : Monoid N\nÏˆ : AddChar A M\nf : A â†’ M\nmap_zero_eq_one' : f 0 = 1\nmap_add_eq_mul' : âˆ€ (a b : A), f (a + b) = f a * f b\nâŠ¢ â‡‘{ toFun := f, map_zero_eq_one' := map_zero_eq_one', map_add_eq_mul' := map_add_eq_mul' } = f"
    },
    {
      "name": "AddChar.mulShift_zero",
      "statement": "R : Type u_1\nM : Type u_2\ninstâœÂ¹ : Ring R\ninstâœ : CommMonoid M\nÏˆ : AddChar R M\nâŠ¢ Ïˆ.mulShift 0 = 1"
    },
    {
      "name": "AddChar.zmod_char_primitive_of_eq_one_only_at_zero",
      "statement": "R : Type u\ninstâœÂ² : CommRing R\nR' : Type v\ninstâœÂ¹ : CommMonoid R'\nC : Type v\ninstâœ : CommMonoid C\nn : â„•\nÏˆ : AddChar (ZMod n) C\nhÏˆ : âˆ€ (a : ZMod n), Ïˆ a = 1 â†’ a = 0\nâŠ¢ Ïˆ.IsPrimitive"
    },
    {
      "name": "AddCircle.isLocalHomeomorph_coe",
      "statement": "ğ•œ : Type u_1\nB : Type u_2\ninstâœâµ : LinearOrderedAddCommGroup ğ•œ\ninstâœâ´ : TopologicalSpace ğ•œ\ninstâœÂ³ : OrderTopology ğ•œ\np : ğ•œ\nhp : Fact (0 < p)\na : ğ•œ\ninstâœÂ² : Archimedean ğ•œ\nx : AddCircle p\nhx : x â‰  â†‘a\ninstâœÂ¹ : DiscreteTopology â†¥(zmultiples p)\ninstâœ : DenselyOrdered ğ•œ\nâŠ¢ IsLocalHomeomorph QuotientAddGroup.mk"
    },
    {
      "name": "AddCommGroup.natCast_modEq_natCast",
      "statement": "Î± : Type u_1\ninstâœÂ¹ : AddCommGroupWithOne Î±\ninstâœ : CharZero Î±\na b n : â„•\nâŠ¢ â†‘a â‰¡ â†‘b [PMOD â†‘n] â†” a â‰¡ b [MOD n]"
    },
    {
      "name": "AddCommGroup.self_modEq_zero",
      "statement": "Î± : Type u_1\ninstâœ : AddCommGroup Î±\np a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c : Î±\nn : â„•\nz : â„¤\nâŠ¢ 0 - p = -1 â€¢ p"
    },
    {
      "name": "AddLECancellable.mul_tsub",
      "statement": "case inl\nÎ± : Type u\nÎ² : Type u_1\ninstâœÂ³ : CanonicallyOrderedCommSemiring Î±\na b c : Î±\ninstâœÂ² : Sub Î±\ninstâœÂ¹ : OrderedSub Î±\ninstâœ : IsTotal Î± fun x x_1 => x â‰¤ x_1\nh : AddLECancellable (a * c)\nhbc : b â‰¤ c\nâŠ¢ a * (b - c) = a * b - a * c"
    },
    {
      "name": "AddMonoidAlgebra.divOf_zero",
      "statement": "k : Type u_1\nG : Type u_2\ninstâœÂ¹ : Semiring k\ninstâœ : AddCancelCommMonoid G\nx : k[G]\nâŠ¢ x /áµ’á¶  0 = x"
    },
    {
      "name": "AddMonoidAlgebra.single_pow",
      "statement": "k : Type uâ‚\nG : Type uâ‚‚\nH : Type u_1\nR : Type u_2\ninstâœÂ¹ : Semiring k\ninstâœ : AddMonoid G\na : G\nb : k\nâŠ¢ single a b ^ 0 = single (0 â€¢ a) (b ^ 0)"
    },
    {
      "name": "AddSubgroup.norm_normedMk",
      "statement": "M : Type u_1\nN : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup M\ninstâœ : SeminormedAddCommGroup N\nS : AddSubgroup M\nh : â†‘S.topologicalClosure â‰  univ\nâŠ¢ â€–S.normedMkâ€– = 1"
    },
    {
      "name": "AdjoinRoot.algHomOfDvd_apply_root",
      "statement": "K : Type u_1\nL : Type ?u.589078\ninstâœÂ² : Field K\ninstâœÂ¹ : Field L\ninstâœ : Algebra K L\np q : K[X]\nhpq : q âˆ£ p\nâŠ¢ (algHomOfDvd hpq) (root p) = root q"
    },
    {
      "name": "AdjoinRoot.quotAdjoinRootEquivQuotPolynomialQuot_symm_mk_mk",
      "statement": "R : Type u\nS : Type v\nK : Type w\ninstâœ : CommRing R\nI : Ideal R\nf p : R[X]\nâŠ¢ (quotAdjoinRootEquivQuotPolynomialQuot I f).symm\n      ((Ideal.Quotient.mk (span {Polynomial.map (Ideal.Quotient.mk I) f})) (Polynomial.map (Ideal.Quotient.mk I) p)) =\n    (Ideal.Quotient.mk (Ideal.map (of f) I)) ((mk f) p)"
    },
    {
      "name": "Affine.Simplex.circumradius_pos",
      "statement": "V : Type u_1\nP : Type u_2\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : InnerProductSpace â„ V\ninstâœÂ¹ : MetricSpace P\ninstâœ : NormedAddTorsor V P\nn : â„•\ns : Simplex â„ P (n + 1)\nâŠ¢ 0 < s.circumradius"
    },
    {
      "name": "Affine.Simplex.circumsphere_reindex",
      "statement": "V : Type u_1\nP : Type u_2\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : InnerProductSpace â„ V\ninstâœÂ¹ : MetricSpace P\ninstâœ : NormedAddTorsor V P\nm n : â„•\ns : Simplex â„ P m\ne : Fin (m + 1) â‰ƒ Fin (n + 1)\nâŠ¢ (s.reindex e).circumsphere = s.circumsphere"
    },
    {
      "name": "Affine.Simplex.reindex_reindex_symm",
      "statement": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninstâœÂ³ : Ring k\ninstâœÂ² : AddCommGroup V\ninstâœÂ¹ : Module k V\ninstâœ : AffineSpace V P\nm n : â„•\ns : Simplex k P m\ne : Fin (m + 1) â‰ƒ Fin (n + 1)\nâŠ¢ (s.reindex e).reindex e.symm = s"
    },
    {
      "name": "Affine.Simplex.sum_circumcenterWeightsWithCircumcenter",
      "statement": "V : Type u_1\nP : Type u_2\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : InnerProductSpace â„ V\ninstâœÂ¹ : MetricSpace P\ninstâœ : NormedAddTorsor V P\nn : â„•\nâŠ¢ âˆ‘ i : PointsWithCircumcenterIndex n, circumcenterWeightsWithCircumcenter n i = 1"
    },
    {
      "name": "Affine.Simplex.sum_mongePointWeightsWithCircumcenter",
      "statement": "V : Type u_1\nP : Type u_2\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : InnerProductSpace â„ V\ninstâœÂ¹ : MetricSpace P\ninstâœ : NormedAddTorsor V P\nn : â„•\nâŠ¢ âˆ‘ i : PointsWithCircumcenterIndex (n + 2), mongePointWeightsWithCircumcenter n i = 1"
    },
    {
      "name": "Affine.Simplex.sum_pointWeightsWithCircumcenter",
      "statement": "V : Type u_1\nP : Type u_2\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : InnerProductSpace â„ V\ninstâœÂ¹ : MetricSpace P\ninstâœ : NormedAddTorsor V P\nn : â„•\ni : Fin (n + 1)\nâŠ¢ âˆ‘ j : PointsWithCircumcenterIndex n, pointWeightsWithCircumcenter i j = 1"
    },
    {
      "name": "Affine.Simplex.sum_reflectionCircumcenterWeightsWithCircumcenter",
      "statement": "V : Type u_1\nP : Type u_2\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : InnerProductSpace â„ V\ninstâœÂ¹ : MetricSpace P\ninstâœ : NormedAddTorsor V P\nn : â„•\niâ‚ iâ‚‚ : Fin (n + 1)\nh : iâ‚ â‰  iâ‚‚\nâŠ¢ âˆ‘ i : PointsWithCircumcenterIndex n, reflectionCircumcenterWeightsWithCircumcenter iâ‚ iâ‚‚ i = 1"
    },
    {
      "name": "AffineBasis.toMatrix_inv_vecMul_toMatrix",
      "statement": "Î¹ : Type uâ‚\nk : Type uâ‚‚\nV : Type uâ‚ƒ\nP : Type uâ‚„\ninstâœâµ : AddCommGroup V\ninstâœâ´ : AffineSpace V P\ninstâœÂ³ : CommRing k\ninstâœÂ² : Module k V\ninstâœÂ¹ : DecidableEq Î¹\ninstâœ : Fintype Î¹\nb bâ‚‚ : AffineBasis Î¹ k P\nx : P\nâŠ¢ b.coords x áµ¥* (b.toMatrix â‡‘bâ‚‚)â»Â¹ = bâ‚‚.coords x"
    },
    {
      "name": "AffineIsometry.image_intrinsicFrontier",
      "statement": "ğ•œ : Type u_1\nV : Type u_2\nW : Type u_3\nQ : Type u_4\nP : Type u_5\ninstâœâ¸ : NormedField ğ•œ\ninstâœâ· : SeminormedAddCommGroup V\ninstâœâ¶ : SeminormedAddCommGroup W\ninstâœâµ : NormedSpace ğ•œ V\ninstâœâ´ : NormedSpace ğ•œ W\ninstâœÂ³ : MetricSpace P\ninstâœÂ² : PseudoMetricSpace Q\ninstâœÂ¹ : NormedAddTorsor V P\ninstâœ : NormedAddTorsor W Q\nÏ† : P â†’áµƒâ±[ğ•œ] Q\ns : Set P\nâŠ¢ intrinsicFrontier ğ•œ (â‡‘Ï† '' s) = â‡‘Ï† '' intrinsicFrontier ğ•œ s"
    },
    {
      "name": "AffineSubspace.Parallel.symm",
      "statement": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninstâœÂ³ : Ring k\ninstâœÂ² : AddCommGroup V\ninstâœÂ¹ : Module k V\ninstâœ : AffineSpace V P\nsâ‚ sâ‚‚ : AffineSubspace k P\nh : sâ‚ âˆ¥ sâ‚‚\nâŠ¢ sâ‚‚ âˆ¥ sâ‚"
    },
    {
      "name": "AffineSubspace.coe_affineSpan_singleton",
      "statement": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninstâœÂ² : Ring k\ninstâœÂ¹ : AddCommGroup V\ninstâœ : Module k V\nS : AffineSpace V P\npâ‚ pâ‚‚ p : P\nâŠ¢ â†‘(affineSpan k {p}) = {p}"
    },
    {
      "name": "AffineSubspace.map_eq_bot_iff",
      "statement": "k : Type u_1\nVâ‚ : Type u_2\nPâ‚ : Type u_3\nVâ‚‚ : Type u_4\nPâ‚‚ : Type u_5\nVâ‚ƒ : Type u_6\nPâ‚ƒ : Type u_7\ninstâœâ¹ : Ring k\ninstâœâ¸ : AddCommGroup Vâ‚\ninstâœâ· : Module k Vâ‚\ninstâœâ¶ : AffineSpace Vâ‚ Pâ‚\ninstâœâµ : AddCommGroup Vâ‚‚\ninstâœâ´ : Module k Vâ‚‚\ninstâœÂ³ : AffineSpace Vâ‚‚ Pâ‚‚\ninstâœÂ² : AddCommGroup Vâ‚ƒ\ninstâœÂ¹ : Module k Vâ‚ƒ\ninstâœ : AffineSpace Vâ‚ƒ Pâ‚ƒ\nf : Pâ‚ â†’áµƒ[k] Pâ‚‚\ns : AffineSubspace k Pâ‚\nâŠ¢ map f s = âŠ¥ â†” s = âŠ¥"
    },
    {
      "name": "AffineSubspace.perpBisector_ne_bot",
      "statement": "V : Type u_1\nP : Type u_2\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : InnerProductSpace â„ V\ninstâœÂ¹ : MetricSpace P\ninstâœ : NormedAddTorsor V P\nc câ‚ câ‚‚ pâ‚ pâ‚‚ : P\nâŠ¢ perpBisector pâ‚ pâ‚‚ â‰  âŠ¥"
    },
    {
      "name": "AlgHom.coe_range",
      "statement": "R' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninstâœâ¶ : CommSemiring R\ninstâœâµ : Semiring A\ninstâœâ´ : Algebra R A\ninstâœÂ³ : Semiring B\ninstâœÂ² : Algebra R B\ninstâœÂ¹ : Semiring C\ninstâœ : Algebra R C\nÏ†âœ Ï† : A â†’â‚[R] B\nâŠ¢ â†‘Ï†.range = Set.range â‡‘Ï†"
    },
    {
      "name": "AlgHom.toContinuousLinearMap_norm",
      "statement": "ğ•œ : Type u_1\nA : Type u_2\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedRing A\ninstâœÂ² : NormedAlgebra ğ•œ A\ninstâœÂ¹ : CompleteSpace A\ninstâœ : NormOneClass A\nÏ† : A â†’â‚[ğ•œ] ğ•œ\nxâœÂ¹ : â„\nxâœ : xâœÂ¹ â‰¥ 0\nh : âˆ€ (x : A), â€–Ï†.toContinuousLinearMap xâ€– â‰¤ xâœÂ¹ * â€–xâ€–\nâŠ¢ 1 â‰¤ xâœÂ¹"
    },
    {
      "name": "Algebra.FinitePresentation.of_finiteType",
      "statement": "R : Type wâ‚\nA : Type wâ‚‚\nB : Type wâ‚ƒ\ninstâœâµ : CommRing R\ninstâœâ´ : CommRing A\ninstâœÂ³ : Algebra R A\ninstâœÂ² : CommRing B\ninstâœÂ¹ : Algebra R B\ninstâœ : IsNoetherianRing R\nâŠ¢ FiniteType R A â†” FinitePresentation R A"
    },
    {
      "name": "Algebra.FormallySmooth.liftOfSurjective_apply",
      "statement": "R : Type u\ninstâœâ· : CommSemiring R\nA : Type u\ninstâœâ¶ : Semiring A\ninstâœâµ : Algebra R A\nB : Type u\ninstâœâ´ : CommRing B\ninstâœÂ³ : Algebra R B\nI : Ideal B\nC : Type u\ninstâœÂ² : CommRing C\ninstâœÂ¹ : Algebra R C\ninstâœ : FormallySmooth R A\nf : A â†’â‚[R] C\ng : B â†’â‚[R] C\nhg : Function.Surjective â‡‘g\nhg' : IsNilpotent (RingHom.ker â†‘g)\nx : A\nâŠ¢ g ((liftOfSurjective f g hg hg') x) = f x"
    },
    {
      "name": "Algebra.TensorProduct.tmul_pow",
      "statement": "R : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\nC : Type uC\nD : Type uD\nE : Type uE\nF : Type uF\ninstâœâ¶ : CommSemiring R\ninstâœâµ : Semiring A\ninstâœâ´ : Algebra R A\ninstâœÂ³ : Semiring B\ninstâœÂ² : Algebra R B\ninstâœÂ¹ : Semiring C\ninstâœ : Algebra R C\na : A\nb : B\nk : â„•\nâŠ¢ a âŠ—â‚œ[R] b ^ k = (a ^ k) âŠ—â‚œ[R] (b ^ k)"
    },
    {
      "name": "Algebra.adjoin_empty",
      "statement": "R : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\ninstâœâ¸ : CommSemiring R\ninstâœâ· : CommSemiring S\ninstâœâ¶ : Semiring A\ninstâœâµ : Semiring B\ninstâœâ´ : Algebra R S\ninstâœÂ³ : Algebra R A\ninstâœÂ² : Algebra S A\ninstâœÂ¹ : Algebra R B\ninstâœ : IsScalarTower R S A\ns t : Set A\nâŠ¢ adjoin R âŠ¥ = âŠ¥"
    },
    {
      "name": "Algebra.discr_reindex",
      "statement": "A : Type u\nB : Type v\nC : Type z\nÎ¹ : Type w\ninstâœâ¸ : DecidableEq Î¹\ninstâœâ· : CommRing A\ninstâœâ¶ : CommRing B\ninstâœâµ : Algebra A B\ninstâœâ´ : CommRing C\ninstâœÂ³ : Algebra A C\nÎ¹' : Type u_1\ninstâœÂ² : Fintype Î¹'\ninstâœÂ¹ : Fintype Î¹\ninstâœ : DecidableEq Î¹'\nb : Basis Î¹ A B\nf : Î¹ â‰ƒ Î¹'\nâŠ¢ discr A (â‡‘b âˆ˜ â‡‘f.symm) = discr A â‡‘b"
    },
    {
      "name": "Algebra.intNorm_eq_zero",
      "statement": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninstâœÂ³Â¹ : CommRing A\ninstâœÂ³â° : CommRing B\ninstâœÂ²â¹ : Algebra A B\ninstâœÂ²â¸ : Field K\ninstâœÂ²â· : Field L\ninstâœÂ²â¶ : Algebra A K\ninstâœÂ²âµ : IsFractionRing A K\ninstâœÂ²â´ : Algebra B L\ninstâœÂ²Â³ : Algebra K L\ninstâœÂ²Â² : Algebra A L\ninstâœÂ²Â¹ : IsScalarTower A B L\ninstâœÂ²â° : IsScalarTower A K L\ninstâœÂ¹â¹ : IsIntegralClosure B A L\ninstâœÂ¹â¸ : FiniteDimensional K L\nAâ‚˜ : Type ?u.623706\nBâ‚˜ : Type ?u.623709\ninstâœÂ¹â· : CommRing Aâ‚˜\ninstâœÂ¹â¶ : CommRing Bâ‚˜\ninstâœÂ¹âµ : Algebra Aâ‚˜ Bâ‚˜\ninstâœÂ¹â´ : Algebra A Aâ‚˜\ninstâœÂ¹Â³ : Algebra B Bâ‚˜\ninstâœÂ¹Â² : Algebra A Bâ‚˜\ninstâœÂ¹Â¹ : IsScalarTower A Aâ‚˜ Bâ‚˜\ninstâœÂ¹â° : IsScalarTower A B Bâ‚˜\nM : Submonoid A\ninstâœâ¹ : IsLocalization M Aâ‚˜\ninstâœâ¸ : IsLocalization (algebraMapSubmonoid B M) Bâ‚˜\ninstâœâ· : IsIntegrallyClosed A\ninstâœâ¶ : IsDomain A\ninstâœâµ : IsIntegrallyClosed A\ninstâœâ´ : IsDomain B\ninstâœÂ³ : IsIntegrallyClosed B\ninstâœÂ² : Module.Finite A B\ninstâœÂ¹ : NoZeroSMulDivisors A B\ninstâœ : IsSeparable (FractionRing A) (FractionRing B)\nx : B\nâŠ¢ (intNorm A B) x = 0 â†” x = 0"
    },
    {
      "name": "Algebra.norm_algebraMap",
      "statement": "R : Type u_1\nS : Type u_2\nT : Type u_3\ninstâœâ¹ : CommRing R\ninstâœâ¸ : Ring S\ninstâœâ· : Algebra R S\nK : Type u_4\nLâœ : Type u_5\nF : Type u_6\ninstâœâ¶ : Field K\ninstâœâµ : Field Lâœ\ninstâœâ´ : Field F\ninstâœÂ³ : Algebra K Lâœ\ninstâœÂ² : Algebra K F\nÎ¹ : Type w\nL : Type u_7\ninstâœÂ¹ : Ring L\ninstâœ : Algebra K L\nx : K\nâŠ¢ (norm K) ((algebraMap K L) x) = x ^ finrank K L"
    },
    {
      "name": "Algebra.sInf_toSubmodule",
      "statement": "R : Type u\nA : Type v\nB : Type w\ninstâœâ´ : CommSemiring R\ninstâœÂ³ : Semiring A\ninstâœÂ² : Algebra R A\ninstâœÂ¹ : Semiring B\ninstâœ : Algebra R B\nS : Set (Subalgebra R A)\nâŠ¢ â†‘(Subalgebra.toSubmodule (sInf S)) = â†‘(sInf (â‡‘Subalgebra.toSubmodule '' S))"
    },
    {
      "name": "Algebraic.countable",
      "statement": "R : Type u\nA : Type v\ninstâœâµ : CommRing R\ninstâœâ´ : CommRing A\ninstâœÂ³ : IsDomain A\ninstâœÂ² : Algebra R A\ninstâœÂ¹ : NoZeroSMulDivisors R A\ninstâœ : Countable R\nâŠ¢ {x | IsAlgebraic R x}.Countable"
    },
    {
      "name": "AlgebraicGeometry.IsAffineOpen.isLocalization_basicOpen",
      "statement": "X Y : Scheme\nU : Opens â†‘â†‘X.toPresheafedSpace\nhU : IsAffineOpen U\nf : â†‘Î“(X, U)\nâŠ¢ IsLocalization.Away f â†‘Î“(X, X.basicOpen f)"
    },
    {
      "name": "AlgebraicGeometry.LocallyRingedSpace.IsOpenImmersion.isoRestrict_hom_ofRestrict",
      "statement": "C : Type u\ninstâœ : Category.{v, u} C\nX Y : LocallyRingedSpace\nf : X âŸ¶ Y\nH : IsOpenImmersion f\nâŠ¢ (isoRestrict f).hom â‰« Y.ofRestrict â‹¯ = f"
    },
    {
      "name": "AlgebraicGeometry.LocallyRingedSpace.toÎ“Spec_preim_basicOpen_eq",
      "statement": "X : LocallyRingedSpace\nr : â†‘(Î“.obj { unop := X })\nâŠ¢ X.toÎ“SpecFun â»Â¹' (basicOpen r).carrier = (X.toRingedSpace.basicOpen r).carrier"
    },
    {
      "name": "AlgebraicGeometry.ProjIsoSpecTopComponent.toSpec_injective",
      "statement": "R : Type u_1\nA : Type u_2\ninstâœÂ³ : CommRing R\ninstâœÂ² : CommRing A\ninstâœÂ¹ : Algebra R A\nğ’œ : â„• â†’ Submodule R A\ninstâœ : GradedAlgebra ğ’œ\nf : A\nm : â„•\nf_deg : f âˆˆ ğ’œ m\nhm : 0 < m\nâŠ¢ Function.Injective â‡‘(toSpec ğ’œ f)"
    },
    {
      "name": "AlgebraicGeometry.RingedSpace.mem_basicOpen",
      "statement": "X : RingedSpace\nU : Opens â†‘â†‘X.toPresheafedSpace\nf : â†‘(X.presheaf.obj { unop := U })\nx : â†¥U\nâŠ¢ â†‘x âˆˆ X.basicOpen f â†” IsUnit ((X.presheaf.germ x) f)"
    },
    {
      "name": "AlgebraicGeometry.Scheme.ofRestrict_appLE",
      "statement": "C : Type u\ninstâœ : Category.{v, u} C\nU : TopCat\nX : Scheme\nf : U âŸ¶ TopCat.of â†‘â†‘X.toPresheafedSpace\nh : OpenEmbedding â‡‘f\nV : Opens â†‘â†‘X.toPresheafedSpace\nW : Opens â†‘â†‘(X.restrict h).toPresheafedSpace\ne : W â‰¤ X.ofRestrict h â»Â¹áµ V\nâŠ¢ X.ofRestrict h ''áµ { unop := W }.unop â‰¤ V"
    },
    {
      "name": "AlgebraicGeometry.Scheme.restrictFunctor_map_left",
      "statement": "C : Type uâ‚\ninstâœ : Category.{v, uâ‚} C\nX : Scheme\nU V : Opens â†‘â†‘X.toPresheafedSpace\ni : U âŸ¶ V\nâŠ¢ Set.range â‡‘(Î¹Opens U).val.base âŠ† Set.range â‡‘(Î¹Opens V).val.base"
    },
    {
      "name": "AlgebraicGeometry.Î“SpecIso_obj_hom",
      "statement": "X : Scheme\nU : Opens â†‘â†‘X.toPresheafedSpace\nâŠ¢ (Scheme.Î“SpecIso Î“(X, U)).hom =\n    Scheme.Î“.map (Spec.map (X.presheaf.map (eqToHom â‹¯).op)).op â‰«\n      Scheme.Hom.app (Î“Spec.adjunction.unit.app (X âˆ£_áµ¤ U)) âŠ¤ â‰« X.presheaf.map (eqToHom â‹¯).op"
    },
    {
      "name": "AlgebraicTopology.DoldKan.MorphComponents.id_Ï†",
      "statement": "C : Type u_1\ninstâœÂ¹ : Category.{u_2, u_1} C\ninstâœ : Preadditive C\nX X' : SimplicialObject C\nn : â„•\nZ Z' : C\nf : MorphComponents X n Z\ng : X' âŸ¶ X\nh : Z âŸ¶ Z'\nâŠ¢ (id X n).Ï† = ğŸ™ (X _[n + 1])"
    },
    {
      "name": "AlgebraicTopology.DoldKan.Nâ‚Î“â‚€_hom_app_f_f",
      "statement": "C : Type u_1\ninstâœÂ² : Category.{u_2, u_1} C\ninstâœÂ¹ : Preadditive C\ninstâœ : HasFiniteCoproducts C\nK : ChainComplex C â„•\nn : â„•\nâŠ¢ (Nâ‚Î“â‚€.hom.app K).f.f n = (Î“â‚€.splitting K).toKaroubiNondegComplexIsoNâ‚.inv.f.f n"
    },
    {
      "name": "AlgebraicTopology.DoldKan.P_f_0_eq",
      "statement": "C : Type u_1\ninstâœÂ¹ : Category.{u_2, u_1} C\ninstâœ : Preadditive C\nX : SimplicialObject C\nq : â„•\nâŠ¢ (P q).f 0 = ğŸ™ (K[X].X 0)"
    },
    {
      "name": "AlgebraicTopology.DoldKan.QInfty_f_comp_PInfty_f",
      "statement": "C : Type u_1\ninstâœÂ¹ : Category.{u_2, u_1} C\ninstâœ : Preadditive C\nX : SimplicialObject C\nn : â„•\nâŠ¢ QInfty.f n â‰« PInfty.f n = 0"
    },
    {
      "name": "AlternatingMap.compLinearMap_zero",
      "statement": "R : Type u_1\ninstâœÂ¹âµ : Semiring R\nM : Type u_2\ninstâœÂ¹â´ : AddCommMonoid M\ninstâœÂ¹Â³ : Module R M\nN : Type u_3\ninstâœÂ¹Â² : AddCommMonoid N\ninstâœÂ¹Â¹ : Module R N\nP : Type u_4\ninstâœÂ¹â° : AddCommMonoid P\ninstâœâ¹ : Module R P\nM' : Type u_5\ninstâœâ¸ : AddCommGroup M'\ninstâœâ· : Module R M'\nN' : Type u_6\ninstâœâ¶ : AddCommGroup N'\ninstâœâµ : Module R N'\nÎ¹ : Type u_7\nÎ¹' : Type u_8\nÎ¹'' : Type u_9\nMâ‚‚ : Type u_10\ninstâœâ´ : AddCommMonoid Mâ‚‚\ninstâœÂ³ : Module R Mâ‚‚\nMâ‚ƒ : Type u_11\ninstâœÂ² : AddCommMonoid Mâ‚ƒ\ninstâœÂ¹ : Module R Mâ‚ƒ\ninstâœ : Nonempty Î¹\nf : M [â‹€^Î¹]â†’â‚—[R] N\nâŠ¢ f.compLinearMap 0 = 0"
    },
    {
      "name": "AntilipschitzWith.properSpace",
      "statement": "Î±âœ : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœâ´ : PseudoMetricSpace Î±âœ\ninstâœÂ³ : PseudoMetricSpace Î²\ninstâœÂ² : PseudoMetricSpace Î³\nKâœ : â„â‰¥0\nfâœ : Î±âœ â†’ Î²\nÎ± : Type u_4\ninstâœÂ¹ : MetricSpace Î±\nK : â„â‰¥0\nf : Î± â†’ Î²\ninstâœ : ProperSpace Î±\nhK : AntilipschitzWith K f\nf_cont : Continuous f\nhf : Function.Surjective f\nâŠ¢ ProperSpace Î²"
    },
    {
      "name": "ArithmeticFunction.cardFactors_eq_one_iff_prime",
      "statement": "R : Type u_1\nn : â„•\nâŠ¢ Î© n = 1 â†” Nat.Prime n"
    },
    {
      "name": "ArithmeticFunction.coe_zeta_smul_apply",
      "statement": "R : Type u_1\nM : Type u_2\ninstâœÂ² : Semiring R\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : Module R M\nf : ArithmeticFunction M\nx : â„•\nâŠ¢ (â†‘Î¶ â€¢ f) x = âˆ‘ i âˆˆ x.divisors, f i"
    },
    {
      "name": "ArithmeticFunction.moebius_mul_coe_zeta",
      "statement": "R : Type u_1\nâŠ¢ Î¼ * â†‘Î¶ = 1"
    },
    {
      "name": "ArithmeticFunction.pow_apply",
      "statement": "R : Type u_1\nk n : â„•\nâŠ¢ (pow k) n = if k = 0 âˆ§ n = 0 then 0 else n ^ k"
    },
    {
      "name": "ArithmeticFunction.zeta_mul_pow_eq_sigma",
      "statement": "R : Type u_1\nk : â„•\nâŠ¢ Î¶ * pow k = Ïƒ k"
    },
    {
      "name": "Associates.factors_one",
      "statement": "Î± : Type u_1\ninstâœâ´ : CancelCommMonoidWithZero Î±\ninstâœÂ³ : UniqueFactorizationMonoid Î±\ninstâœÂ² : DecidableEq (Associates Î±)\ninstâœÂ¹ : (p : Associates Î±) â†’ Decidable (Irreducible p)\ninstâœ : Nontrivial Î±\nâŠ¢ factors 1 = 0"
    },
    {
      "name": "Associates.mk_dvdNotUnit_mk_iff",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\ninstâœ : CommMonoidWithZero Î±\na b : Î±\nâŠ¢ DvdNotUnit (Associates.mk a) (Associates.mk b) â†” DvdNotUnit a b"
    },
    {
      "name": "Associates.mk_eq_one",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\ninstâœ : Monoid Î±\na : Î±\nâŠ¢ Associates.mk a = 1 â†” IsUnit a"
    },
    {
      "name": "Associates.pow_factors",
      "statement": "Î± : Type u_1\ninstâœâ´ : CancelCommMonoidWithZero Î±\ninstâœÂ³ : UniqueFactorizationMonoid Î±\ninstâœÂ² : DecidableEq (Associates Î±)\ninstâœÂ¹ : (p : Associates Î±) â†’ Decidable (Irreducible p)\ninstâœ : Nontrivial Î±\na : Associates Î±\nk : â„•\nâŠ¢ (a ^ k).factors = k â€¢ a.factors"
    },
    {
      "name": "Asymptotics.IsLittleO.rpow",
      "statement": "Î± : Type u_1\nr c : â„\nl : Filter Î±\nf g : Î± â†’ â„\nhr : 0 < r\nhg : 0 â‰¤á¶ [l] g\nh : f =o[l] g\nâŠ¢ (fun x => f x ^ r) =o[l] fun x => g x ^ r"
    },
    {
      "name": "Asymptotics.isBigOWith_const_const",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nE : Type u_3\nF : Type u_4\nG : Type u_5\nE' : Type u_6\nF' : Type u_7\nG' : Type u_8\nE'' : Type u_9\nF'' : Type u_10\nG'' : Type u_11\nE''' : Type u_12\nR : Type u_13\nR' : Type u_14\nğ•œ : Type u_15\nğ•œ' : Type u_16\ninstâœÂ¹Â³ : Norm E\ninstâœÂ¹Â² : Norm F\ninstâœÂ¹Â¹ : Norm G\ninstâœÂ¹â° : SeminormedAddCommGroup E'\ninstâœâ¹ : SeminormedAddCommGroup F'\ninstâœâ¸ : SeminormedAddCommGroup G'\ninstâœâ· : NormedAddCommGroup E''\ninstâœâ¶ : NormedAddCommGroup F''\ninstâœâµ : NormedAddCommGroup G''\ninstâœâ´ : SeminormedRing R\ninstâœÂ³ : SeminormedAddGroup E'''\ninstâœÂ² : SeminormedRing R'\ninstâœÂ¹ : NormedDivisionRing ğ•œ\ninstâœ : NormedDivisionRing ğ•œ'\ncâœ c'âœ câ‚ câ‚‚ : â„\nf : Î± â†’ E\ng : Î± â†’ F\nk : Î± â†’ G\nf' : Î± â†’ E'\ng' : Î± â†’ F'\nk' : Î± â†’ G'\nf'' : Î± â†’ E''\ng'' : Î± â†’ F''\nk'' : Î± â†’ G''\nlâœ l' : Filter Î±\nc : E\nc' : F''\nhc' : c' â‰  0\nl : Filter Î±\nâŠ¢ IsBigOWith (â€–câ€– / â€–c'â€–) l (fun _x => c) fun _x => c'"
    },
    {
      "name": "Asymptotics.isBigO_const_const_iff",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nE : Type u_3\nF : Type u_4\nG : Type u_5\nE' : Type u_6\nF' : Type u_7\nG' : Type u_8\nE'' : Type u_9\nF'' : Type u_10\nG'' : Type u_11\nE''' : Type u_12\nR : Type u_13\nR' : Type u_14\nğ•œ : Type u_15\nğ•œ' : Type u_16\ninstâœÂ¹â´ : Norm E\ninstâœÂ¹Â³ : Norm F\ninstâœÂ¹Â² : Norm G\ninstâœÂ¹Â¹ : SeminormedAddCommGroup E'\ninstâœÂ¹â° : SeminormedAddCommGroup F'\ninstâœâ¹ : SeminormedAddCommGroup G'\ninstâœâ¸ : NormedAddCommGroup E''\ninstâœâ· : NormedAddCommGroup F''\ninstâœâ¶ : NormedAddCommGroup G''\ninstâœâµ : SeminormedRing R\ninstâœâ´ : SeminormedAddGroup E'''\ninstâœÂ³ : SeminormedRing R'\ninstâœÂ² : NormedDivisionRing ğ•œ\ninstâœÂ¹ : NormedDivisionRing ğ•œ'\ncâœ c'âœ câ‚ câ‚‚ : â„\nf : Î± â†’ E\ng : Î± â†’ F\nk : Î± â†’ G\nf' : Î± â†’ E'\ng' : Î± â†’ F'\nk' : Î± â†’ G'\nf'' : Î± â†’ E''\ng'' : Î± â†’ F''\nk'' : Î± â†’ G''\nlâœ l' : Filter Î±\nc : E''\nc' : F''\nl : Filter Î±\ninstâœ : l.NeBot\nâŠ¢ ((fun _x => c) =O[l] fun _x => c') â†” c' = 0 â†’ c = 0"
    },
    {
      "name": "Asymptotics.isBigO_pi",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nE : Type u_3\nF : Type u_4\nG : Type u_5\nE'âœ : Type u_6\nF' : Type u_7\nG' : Type u_8\nE'' : Type u_9\nF'' : Type u_10\nG'' : Type u_11\nE''' : Type u_12\nR : Type u_13\nR' : Type u_14\nğ•œ : Type u_15\nğ•œ' : Type u_16\ninstâœÂ¹âµ : Norm E\ninstâœÂ¹â´ : Norm F\ninstâœÂ¹Â³ : Norm G\ninstâœÂ¹Â² : SeminormedAddCommGroup E'âœ\ninstâœÂ¹Â¹ : SeminormedAddCommGroup F'\ninstâœÂ¹â° : SeminormedAddCommGroup G'\ninstâœâ¹ : NormedAddCommGroup E''\ninstâœâ¸ : NormedAddCommGroup F''\ninstâœâ· : NormedAddCommGroup G''\ninstâœâ¶ : SeminormedRing R\ninstâœâµ : SeminormedAddGroup E'''\ninstâœâ´ : SeminormedRing R'\ninstâœÂ³ : NormedDivisionRing ğ•œ\ninstâœÂ² : NormedDivisionRing ğ•œ'\nc c' câ‚ câ‚‚ : â„\nfâœ : Î± â†’ E\ng : Î± â†’ F\nk : Î± â†’ G\nf' : Î± â†’ E'âœ\ng' : Î± â†’ F'\nk' : Î± â†’ G'\nf'' : Î± â†’ E''\ng'' : Î± â†’ F''\nk'' : Î± â†’ G''\nl l' : Filter Î±\nÎ¹ : Type u_17\ninstâœÂ¹ : Fintype Î¹\nE' : Î¹ â†’ Type u_18\ninstâœ : (i : Î¹) â†’ NormedAddCommGroup (E' i)\nf : Î± â†’ (i : Î¹) â†’ E' i\nâŠ¢ f =O[l] g' â†” âˆ€ (i : Î¹), (fun x => f x i) =O[l] g'"
    },
    {
      "name": "Batteries.AssocList.forIn_eq",
      "statement": "m : Type u_1 â†’ Type u_2\nÎ± : Type u_3\nÎ² : Type u_4\nÎ´ : Type u_1\ninstâœ : Monad m\nl : AssocList Î± Î²\ninit : Î´\nf : Î± Ã— Î² â†’ Î´ â†’ m (ForInStep Î´)\nâŠ¢ forIn l init f = forIn l.toList init f"
    },
    {
      "name": "Batteries.RBNode.reverse_balLeft",
      "statement": "Î± : Type u_1\nl : RBNode Î±\nv : Î±\nr : RBNode Î±\nâŠ¢ (l.balLeft v r).reverse = r.reverse.balRight v l.reverse"
    },
    {
      "name": "Batteries.RBNode.toStream_toList",
      "statement": "Î± : Type u_1\nt : RBNode Î±\nâŠ¢ t.toStream.toList = t.toList"
    },
    {
      "name": "Batteries.UnionFind.push_parentD",
      "statement": "i : Nat\narr : Array UFNode\nâŠ¢ parentD (arr.push { parent := arr.size, rank := 0 }) i = parentD arr i"
    },
    {
      "name": "Batteries.UnionFind.push_rankD",
      "statement": "i : Nat\narr : Array UFNode\nâŠ¢ rankD (arr.push { parent := arr.size, rank := 0 }) i = rankD arr i"
    },
    {
      "name": "Batteries.UnionFind.rankD_push",
      "statement": "a : Nat\narr : Array UFNode\nâŠ¢ rankD (arr.push { parent := arr.size, rank := 0 }) a = rankD arr a"
    },
    {
      "name": "Bool.coe_false",
      "statement": "âŠ¢ (false = true) = False"
    },
    {
      "name": "Bool.coe_sort_true",
      "statement": "âŠ¢ (true = true) = True"
    },
    {
      "name": "Bool.eq_false_eq_not_eq_true",
      "statement": "b : Bool\nâŠ¢ (Â¬b = true) = (b = false)"
    },
    {
      "name": "Booleanisation.lift_le_lift",
      "statement": "Î± : Type u_1\ninstâœ : GeneralizedBooleanAlgebra Î±\nx y : Booleanisation Î±\na b : Î±\nâŠ¢ lift a â‰¤ lift b â†’ a â‰¤ b"
    },
    {
      "name": "Bornology.IsVonNBounded.neg",
      "statement": "ğ•œ : Type u_1\nğ•œ' : Type u_2\nE : Type u_3\nE' : Type u_4\nF : Type u_5\nÎ¹ : Type u_6\ninstâœâ´ : SeminormedRing ğ•œ\ninstâœÂ³ : AddGroup E\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : TopologicalAddGroup E\ninstâœ : DistribMulAction ğ•œ E\ns t : Set E\nhs : IsVonNBounded ğ•œ s\nU : Set E\nhU : U âˆˆ ğ“ 0\nâŠ¢ Absorbs ğ•œ U (-s)"
    },
    {
      "name": "Bornology.isBounded_prod_self",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nÏ€ : Î¹ â†’ Type u_4\ninstâœÂ² : Bornology Î±\ninstâœÂ¹ : Bornology Î²\ninstâœ : (i : Î¹) â†’ Bornology (Ï€ i)\ns : Set Î±\nt : Set Î²\nS : (i : Î¹) â†’ Set (Ï€ i)\nâŠ¢ IsBounded (s Ã—Ë¢ s) â†” IsBounded s"
    },
    {
      "name": "Bornology.isVonNBounded_insert",
      "statement": "ğ•œ : Type u_1\nğ•œ' : Type u_2\nE : Type u_3\nE' : Type u_4\nF : Type u_5\nÎ¹ : Type u_6\ninstâœâ´ : NormedField ğ•œ\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : ContinuousSMul ğ•œ E\nx : E\ns : Set E\nâŠ¢ IsVonNBounded ğ•œ (insert x s) â†” IsVonNBounded ğ•œ s"
    },
    {
      "name": "BoundedContinuousFunction.coe_nsmulRec",
      "statement": "F : Type u_1\nÎ± : Type u\nÎ² : Type v\nÎ³ : Type w\ninstâœâ´ : TopologicalSpace Î±\ninstâœÂ³ : PseudoMetricSpace Î²\ninstâœÂ² : AddMonoid Î²\ninstâœÂ¹ : BoundedAdd Î²\ninstâœ : ContinuousAdd Î²\nf g : Î± â†’áµ‡ Î²\nx : Î±\nC : â„\nâŠ¢ â‡‘(nsmulRec 0 f) = 0 â€¢ â‡‘f"
    },
    {
      "name": "BoundedContinuousFunction.norm_sub_nonneg",
      "statement": "F : Type u_1\nÎ±âœ : Type u\nÎ² : Type v\nÎ³ : Type w\nÎ± : Type u_2\ninstâœ : TopologicalSpace Î±\nf : Î± â†’áµ‡ â„\nâŠ¢ 0 â‰¤ const Î± â€–fâ€– - f"
    },
    {
      "name": "BoxIntegral.Box.splitLower_eq_self",
      "statement": "Î¹ : Type u_1\nM : Type u_2\nn : â„•\nI : Box Î¹\ni : Î¹\nx : â„\ny : Î¹ â†’ â„\nâŠ¢ I.splitLower i x = â†‘I â†” I.upper i â‰¤ x"
    },
    {
      "name": "BoxIntegral.Box.volume_apply'",
      "statement": "Î¹ : Type u_1\ninstâœ : Fintype Î¹\nI : Box Î¹\nâŠ¢ (volume â†‘I).toReal = âˆ i : Î¹, (I.upper i - I.lower i)"
    },
    {
      "name": "BoxIntegral.Prepartition.isPartition_single_iff",
      "statement": "Î¹ : Type u_1\nI J Jâ‚ Jâ‚‚ : Box Î¹\nÏ€ Ï€â‚ Ï€â‚‚ : Prepartition I\nx : Î¹ â†’ â„\nÏ€i Ï€iâ‚ Ï€iâ‚‚ : (J : Box Î¹) â†’ Prepartition J\nh : J â‰¤ I\nâŠ¢ (single I J h).IsPartition â†” J = I"
    },
    {
      "name": "BoxIntegral.Prepartition.mem_iUnion",
      "statement": "Î¹ : Type u_1\nI J Jâ‚ Jâ‚‚ : Box Î¹\nÏ€ Ï€â‚ Ï€â‚‚ : Prepartition I\nx : Î¹ â†’ â„\nâŠ¢ x âˆˆ Ï€.iUnion â†” âˆƒ J âˆˆ Ï€, x âˆˆ J"
    },
    {
      "name": "Cardinal.aleph_zero",
      "statement": "âŠ¢ aleph 0 = â„µâ‚€"
    },
    {
      "name": "Cardinal.beth_strictMono",
      "statement": "âŠ¢ StrictMono beth"
    },
    {
      "name": "Cardinal.lift_iInf",
      "statement": "Î± Î² : Type u\nÎ¹ : Sort u_1\nf : Î¹ â†’ Cardinal.{v}\nâŠ¢ lift.{u, v} (iInf f) = â¨… i, lift.{u, v} (f i)"
    },
    {
      "name": "Cardinal.lift_le_continuum",
      "statement": "c : Cardinal.{u}\nâŠ¢ lift.{v, u} c â‰¤ ğ”  â†” c â‰¤ ğ” "
    },
    {
      "name": "Cardinal.lift_le_nat_iff",
      "statement": "Î± Î² : Type u\na : Cardinal.{u}\nn : â„•\nâŠ¢ lift.{v, u} a â‰¤ â†‘n â†” a â‰¤ â†‘n"
    },
    {
      "name": "Cardinal.lift_natCast",
      "statement": "Î± Î² : Type u\nn : â„•\nâŠ¢ lift.{u, v} â†‘n = â†‘n"
    },
    {
      "name": "Cardinal.lift_ord",
      "statement": "Î± : Type u\nÎ² : Type u_1\nÎ³ : Type u_2\nr : Î± â†’ Î± â†’ Prop\ns : Î² â†’ Î² â†’ Prop\nt : Î³ â†’ Î³ â†’ Prop\nc : Cardinal.{v}\nâŠ¢ Ordinal.lift.{u, v} c.ord = (lift.{u, v} c).ord"
    },
    {
      "name": "Cardinal.mk_finsupp_lift_of_infinite'",
      "statement": "Î± : Type u\nÎ² : Type v\ninstâœÂ² : Nonempty Î±\ninstâœÂ¹ : Zero Î²\ninstâœ : Infinite Î²\nâŠ¢ #(Î± â†’â‚€ Î²) = max (lift.{v, u} #Î±) (lift.{u, v} #Î²)"
    },
    {
      "name": "Cardinal.nat_eq_ofENat",
      "statement": "m : â„•\nn : â„•âˆ\nâŠ¢ â†‘m = â†‘n â†” â†‘m = n"
    },
    {
      "name": "Cardinal.ofENat_le_lift",
      "statement": "x : Cardinal.{v}\nm : â„•âˆ\nâŠ¢ â†‘m â‰¤ lift.{u, v} x â†” â†‘m â‰¤ x"
    },
    {
      "name": "Cardinal.ord_aleph0",
      "statement": "o : Ordinal.{u}\nh : o < Ï‰\nâŠ¢ o < â„µâ‚€.ord"
    },
    {
      "name": "Cardinal.ord_one",
      "statement": "Î± : Type u\nÎ² : Type u_1\nÎ³ : Type u_2\nr : Î± â†’ Î± â†’ Prop\ns : Î² â†’ Î² â†’ Prop\nt : Î³ â†’ Î³ â†’ Prop\nâŠ¢ ord 1 = 1"
    },
    {
      "name": "Cardinal.prime_of_aleph0_le",
      "statement": "a b : Cardinal.{u}\nn m : â„•\nha : â„µâ‚€ â‰¤ a\nâŠ¢ Prime a"
    },
    {
      "name": "CategoryTheory.Adjunction.leftAdjointUniq_trans_app",
      "statement": "C : Type u_1\nD : Type u_2\ninstâœÂ¹ : Category.{u_3, u_1} C\ninstâœ : Category.{u_4, u_2} D\nF F' F'' : C â¥¤ D\nG : D â¥¤ C\nadj1 : F âŠ£ G\nadj2 : F' âŠ£ G\nadj3 : F'' âŠ£ G\nx : C\nâŠ¢ (adj1.leftAdjointUniq adj2).hom.app x â‰« (adj2.leftAdjointUniq adj3).hom.app x = (adj1.leftAdjointUniq adj3).hom.app x"
    },
    {
      "name": "CategoryTheory.Adjunction.rightAdjointUniq_trans_app",
      "statement": "C : Type u_1\nD : Type u_2\ninstâœÂ¹ : Category.{u_3, u_1} C\ninstâœ : Category.{u_4, u_2} D\nF : C â¥¤ D\nG G' G'' : D â¥¤ C\nadj1 : F âŠ£ G\nadj2 : F âŠ£ G'\nadj3 : F âŠ£ G''\nx : D\nâŠ¢ (adj1.rightAdjointUniq adj2).hom.app x â‰« (adj2.rightAdjointUniq adj3).hom.app x =\n    (adj1.rightAdjointUniq adj3).hom.app x"
    },
    {
      "name": "CategoryTheory.Arrow.inv_right",
      "statement": "T : Type u\ninstâœÂ¹ : Category.{v, u} T\nf g : Arrow T\nsq : f âŸ¶ g\ninstâœ : IsIso sq\nâŠ¢ sq.right â‰« (inv sq).right = ğŸ™ f.right"
    },
    {
      "name": "CategoryTheory.Bicategory.associator_inv_naturality_middle",
      "statement": "B : Type u\ninstâœ : Bicategory B\na b c d e : B\nf : a âŸ¶ b\ng g' : b âŸ¶ c\nÎ· : g âŸ¶ g'\nh : c âŸ¶ d\nâŠ¢ f â— Î· â–· h â‰« (Î±_ f g' h).inv = (Î±_ f g h).inv â‰« (f â— Î·) â–· h"
    },
    {
      "name": "CategoryTheory.Bicategory.inv_whiskerLeft",
      "statement": "B : Type u\ninstâœÂ¹ : Bicategory B\na b c d e : B\nf : a âŸ¶ b\ng h : b âŸ¶ c\nÎ· : g âŸ¶ h\ninstâœ : IsIso Î·\nâŠ¢ inv (f â— Î·) = f â— inv Î·"
    },
    {
      "name": "CategoryTheory.Bicategory.triangle_assoc_comp_right",
      "statement": "B : Type u\ninstâœ : Bicategory B\na b c d e : B\nf : a âŸ¶ b\ng : b âŸ¶ c\nâŠ¢ (Î±_ f (ğŸ™ b) g).inv â‰« (Ï_ f).hom â–· g = f â— (Î»_ g).hom"
    },
    {
      "name": "CategoryTheory.Bifunctor.map_id_comp",
      "statement": "C : Type uâ‚\nD : Type uâ‚‚\nE : Type uâ‚ƒ\ninstâœÂ² : Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : Category.{vâ‚‚, uâ‚‚} D\ninstâœ : Category.{vâ‚ƒ, uâ‚ƒ} E\nF : C Ã— D â¥¤ E\nW : C\nX Y Z : D\nf : X âŸ¶ Y\ng : Y âŸ¶ Z\nâŠ¢ F.map (ğŸ™ W, f â‰« g) = F.map (ğŸ™ W, f) â‰« F.map (ğŸ™ W, g)"
    },
    {
      "name": "CategoryTheory.Cat.associator_hom_app",
      "statement": "B C D E : Cat\nF : B âŸ¶ C\nG : C âŸ¶ D\nH : D âŸ¶ E\nX : â†‘B\nâŠ¢ ((F â‰« G) â‰« H).obj X = (F â‰« G â‰« H).obj X"
    },
    {
      "name": "CategoryTheory.ComposableArrows.homMkâ‚…_app_four",
      "statement": "C : Type u_1\ninstâœ : Category.{?u.427767, u_1} C\nn m : â„•\nF G : ComposableArrows C n\nf g : ComposableArrows C 5\nappâ‚€ : f.obj' 0 â‹¯ âŸ¶ g.obj' 0 â‹¯\nappâ‚ : f.obj' 1 â‹¯ âŸ¶ g.obj' 1 â‹¯\nappâ‚‚ : f.obj' 2 â‹¯ âŸ¶ g.obj' 2 â‹¯\nappâ‚ƒ : f.obj' 3 â‹¯ âŸ¶ g.obj' 3 â‹¯\nappâ‚„ : f.obj' 4 â‹¯ âŸ¶ g.obj' 4 â‹¯\nappâ‚… : f.obj' 5 â‹¯ âŸ¶ g.obj' 5 â‹¯\nwâ‚€ : f.map' 0 1 â‹¯ â‹¯ â‰« appâ‚ = appâ‚€ â‰« g.map' 0 1 â‹¯ â‹¯\nwâ‚ : f.map' 1 2 â‹¯ â‹¯ â‰« appâ‚‚ = appâ‚ â‰« g.map' 1 2 â‹¯ â‹¯\nwâ‚‚ : f.map' 2 3 â‹¯ â‹¯ â‰« appâ‚ƒ = appâ‚‚ â‰« g.map' 2 3 â‹¯ â‹¯\nwâ‚ƒ : f.map' 3 4 â‹¯ â‹¯ â‰« appâ‚„ = appâ‚ƒ â‰« g.map' 3 4 â‹¯ â‹¯\nwâ‚„ : f.map' 4 5 â‹¯ â‹¯ â‰« appâ‚… = appâ‚„ â‰« g.map' 4 5 â‹¯ â‹¯\nâŠ¢ 4 < 5 + 1"
    },
    {
      "name": "CategoryTheory.DifferentialObject.eqToHom_f'",
      "statement": "Î² : Type u_1\ninstâœÂ² : AddCommGroup Î²\nb : Î²\nV : Type u_2\ninstâœÂ¹ : Category.{u_3, u_2} V\ninstâœ : HasZeroMorphisms V\nXâœ X Y : DifferentialObject â„¤ (GradedObjectWithShift b V)\nf : X âŸ¶ Y\nx y : Î²\nh : x = y\nâŠ¢ X.objEqToHom h â‰« f.f y = f.f x â‰« Y.objEqToHom h"
    },
    {
      "name": "CategoryTheory.DifferentialObject.objEqToHom_d",
      "statement": "Î² : Type u_1\ninstâœÂ² : AddCommGroup Î²\nb : Î²\nV : Type u_2\ninstâœÂ¹ : Category.{?u.1213, u_2} V\ninstâœ : HasZeroMorphisms V\nX : DifferentialObject â„¤ (GradedObjectWithShift b V)\nx y : Î²\nh : x = y\nâŠ¢ (fun b_1 => b_1 + { as := 1 }.as â€¢ b) x = (fun b_1 => b_1 + { as := 1 }.as â€¢ b) y"
    },
    {
      "name": "CategoryTheory.Discrete.natIso_app",
      "statement": "Î± : Type uâ‚\nC : Type uâ‚‚\ninstâœ : Category.{vâ‚‚, uâ‚‚} C\nI : Type uâ‚\nF G : Discrete I â¥¤ C\nf : (i : Discrete I) â†’ F.obj i â‰… G.obj i\ni : Discrete I\nâŠ¢ (natIso f).app i = f i"
    },
    {
      "name": "CategoryTheory.Equivalence.funInvIdAssoc_inv_app",
      "statement": "C : Type uâ‚\ninstâœÂ² : Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : Category.{vâ‚‚, uâ‚‚} D\nE : Type uâ‚ƒ\ninstâœ : Category.{vâ‚ƒ, uâ‚ƒ} E\ne : C â‰Œ D\nF : C â¥¤ E\nX : C\nâŠ¢ (e.funInvIdAssoc F).inv.app X = F.map (e.unit.app X)"
    },
    {
      "name": "CategoryTheory.Equivalence.invFunIdAssoc_hom_app",
      "statement": "C : Type uâ‚\ninstâœÂ² : Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : Category.{vâ‚‚, uâ‚‚} D\nE : Type uâ‚ƒ\ninstâœ : Category.{vâ‚ƒ, uâ‚ƒ} E\ne : C â‰Œ D\nF : D â¥¤ E\nX : D\nâŠ¢ (e.invFunIdAssoc F).hom.app X = F.map (e.counit.app X)"
    },
    {
      "name": "CategoryTheory.Equivalence.unit_inverse_comp",
      "statement": "C : Type uâ‚\ninstâœÂ¹ : Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœ : Category.{vâ‚‚, uâ‚‚} D\ne : C â‰Œ D\nY : D\nâŠ¢ e.unit.app (e.inverse.obj Y) â‰« e.inverse.map (e.counit.app Y) = ğŸ™ (e.inverse.obj Y)"
    },
    {
      "name": "CategoryTheory.Functor.Initial.limit_cone_comp_aux",
      "statement": "C : Type uâ‚\ninstâœÂ³ : Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : Category.{vâ‚‚, uâ‚‚} D\nF : C â¥¤ D\ninstâœÂ¹ : F.Initial\nE : Type uâ‚ƒ\ninstâœ : Category.{vâ‚ƒ, uâ‚ƒ} E\nG : D â¥¤ E\ns : Cone (F â‹™ G)\nj : C\nâŠ¢ s.Ï€.app (lift F (F.obj j)) â‰« G.map (homToLift F (F.obj j)) = s.Ï€.app j"
    },
    {
      "name": "CategoryTheory.Functor.Monoidal.tensorHom_app_snd",
      "statement": "J : Type u_1\nC : Type u_2\ninstâœÂ² : Category.{u_3, u_1} J\ninstâœÂ¹ : Category.{u_4, u_2} C\ninstâœ : ChosenFiniteProducts C\nFâ‚ Fâ‚' Fâ‚‚ Fâ‚‚' : J â¥¤ C\nf : Fâ‚ âŸ¶ Fâ‚'\ng : Fâ‚‚ âŸ¶ Fâ‚‚'\nj : J\nâŠ¢ (f âŠ— g).app j â‰« snd (Fâ‚'.obj j) (Fâ‚‚'.obj j) = snd (Fâ‚.obj j) (Fâ‚‚.obj j) â‰« g.app j"
    },
    {
      "name": "CategoryTheory.Functor.ShiftSequence.induced_shiftIso_hom_app_obj",
      "statement": "C : Type u_1\nD : Type u_2\nA : Type u_3\ninstâœâ¹ : Category.{u_7, u_1} C\ninstâœâ¸ : Category.{u_6, u_2} D\ninstâœâ· : Category.{u_5, u_3} A\nL : C â¥¤ D\nF : D â¥¤ A\nG : C â¥¤ A\ne : L â‹™ F â‰… G\nM : Type u_4\ninstâœâ¶ : AddMonoid M\ninstâœâµ : HasShift C M\ninstâœâ´ : HasShift D M\ninstâœÂ³ : L.CommShift M\ninstâœÂ² : G.ShiftSequence M\nF' : M â†’ D â¥¤ A\ne' : (m : M) â†’ L â‹™ F' m â‰… G.shift m\ninstâœÂ¹ : ((whiskeringLeft C D A).obj L).Full\ninstâœ : ((whiskeringLeft C D A).obj L).Faithful\nn a a' : M\nha' : n + a = a'\nX : C\nâŠ¢ (F.shiftIso n a a' ha').hom.app (L.obj X) =\n    (F.shift a).map ((L.commShiftIso n).inv.app X) â‰«\n      (e' a).hom.app ((shiftFunctor C n).obj X) â‰« (G.shiftIso n a a' ha').hom.app X â‰« (e' a').inv.app X"
    },
    {
      "name": "CategoryTheory.Functor.biprodComparison'_comp_biprodComparison",
      "statement": "C : Type uâ‚\ninstâœâ¶ : Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœâµ : Category.{vâ‚‚, uâ‚‚} D\ninstâœâ´ : HasZeroMorphisms C\ninstâœÂ³ : HasZeroMorphisms D\nF : C â¥¤ D\nX Y : C\ninstâœÂ² : HasBinaryBiproduct X Y\ninstâœÂ¹ : HasBinaryBiproduct (F.obj X) (F.obj Y)\ninstâœ : F.PreservesZeroMorphisms\nâŠ¢ F.biprodComparison' X Y â‰« F.biprodComparison X Y = ğŸ™ (F.obj X âŠ F.obj Y)"
    },
    {
      "name": "CategoryTheory.Functor.epi_map_iff_epi",
      "statement": "C : Type uâ‚\ninstâœÂ² : Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : Category.{vâ‚‚, uâ‚‚} D\nE : Type uâ‚ƒ\ninstâœ : Category.{vâ‚ƒ, uâ‚ƒ} E\nF : C â¥¤ D\nX Y : C\nf : X âŸ¶ Y\nhFâ‚ : F.PreservesEpimorphisms\nhFâ‚‚ : F.ReflectsEpimorphisms\nâŠ¢ Epi (F.map f) â†” Epi f"
    },
    {
      "name": "CategoryTheory.Functor.map_comp_heq'",
      "statement": "C : Type uâ‚\ninstâœÂ² : Category.{vâ‚, uâ‚} C\nÎ² : Sort u_1\nD : Type uâ‚‚\ninstâœÂ¹ : Category.{vâ‚‚, uâ‚‚} D\nE : Type uâ‚ƒ\ninstâœ : Category.{vâ‚ƒ, uâ‚ƒ} E\nF G : C â¥¤ D\nX Y Z : C\nf : X âŸ¶ Y\ng : Y âŸ¶ Z\nhobj : âˆ€ (X : C), F.obj X = G.obj X\nhmap : âˆ€ {X Y : C} (f : X âŸ¶ Y), HEq (F.map f) (G.map f)\nâŠ¢ HEq (F.map (f â‰« g)) (G.map (f â‰« g))"
    },
    {
      "name": "CategoryTheory.GlueData.types_Î¹_jointly_surjective",
      "statement": "C : Type uâ‚\ninstâœÂ¹ : Category.{v, uâ‚} C\nC' : Type uâ‚‚\ninstâœ : Category.{v, uâ‚‚} C'\nDâœ : GlueData C\nD : GlueData (Type v)\nx : D.glued\nâŠ¢ âˆƒ i y, D.Î¹ i y = x"
    },
    {
      "name": "CategoryTheory.GradedObject.eqToHom_apply",
      "statement": "C : Type u\ninstâœ : Category.{v, u} C\nÎ² : Type w\nX Y : Î² â†’ C\nh : X = Y\nb : Î²\nâŠ¢ X b = Y b"
    },
    {
      "name": "CategoryTheory.GradedObject.mapMap_id",
      "statement": "I : Type u_1\nJ : Type u_2\nK : Type u_3\nC : Type u_4\ninstâœÂ³ : Category.{u_5, u_4} C\nX Y Z : GradedObject I C\nÏ† : X âŸ¶ Y\ne : X â‰… Y\nÏˆ : Y âŸ¶ Z\np : I â†’ J\nj : J\ninstâœÂ² : X.HasMap p\ninstâœÂ¹ : Y.HasMap p\ninstâœ : Z.HasMap p\nâŠ¢ mapMap (ğŸ™ X) p = ğŸ™ (X.mapObj p)"
    },
    {
      "name": "CategoryTheory.HasShift.Induced.add_hom_app_obj",
      "statement": "C : Type u_5\nD : Type u_2\ninstâœâµ : Category.{u_4, u_5} C\ninstâœâ´ : Category.{u_1, u_2} D\nF : C â¥¤ D\nA : Type u_3\ninstâœÂ³ : AddMonoid A\ninstâœÂ² : HasShift C A\ns : A â†’ D â¥¤ D\ni : (a : A) â†’ F â‹™ s a â‰… shiftFunctor C a â‹™ F\ninstâœÂ¹ : ((whiskeringLeft C D D).obj F).Full\ninstâœ : ((whiskeringLeft C D D).obj F).Faithful\na b : A\nX : C\nâŠ¢ (add F s i a b).hom.app (F.obj X) =\n    (i (a + b)).hom.app X â‰«\n      F.map ((shiftFunctorAdd C a b).hom.app X) â‰« (i b).inv.app ((shiftFunctor C a).obj X) â‰« (s b).map ((i a).inv.app X)"
    },
    {
      "name": "CategoryTheory.Idempotents.isIdempotentComplete_iff_opposite",
      "statement": "C : Type u_1\ninstâœ : Category.{u_2, u_1} C\nâŠ¢ IsIdempotentComplete Cáµ’áµ– â†” IsIdempotentComplete C"
    },
    {
      "name": "CategoryTheory.IsPullback.zero_right",
      "statement": "C : Type uâ‚\ninstâœÂ² : Category.{vâ‚, uâ‚} C\nP Xâœ Y Z : C\nfst : P âŸ¶ Xâœ\nsnd : P âŸ¶ Y\nf : Xâœ âŸ¶ Z\ng : Y âŸ¶ Z\ninstâœÂ¹ : HasZeroObject C\ninstâœ : HasZeroMorphisms C\nX : C\nâŠ¢ CommSq 0 (ğŸ™ X) 0 0"
    },
    {
      "name": "CategoryTheory.Iso.op_unop",
      "statement": "C : Type uâ‚\ninstâœ : Category.{vâ‚, uâ‚} C\nXâœ Yâœ X Y : C\nf : X â‰… Y\nâŠ¢ f.op.unop = f"
    },
    {
      "name": "CategoryTheory.Limits.IsColimit.coconePointUniqueUpToIso_inv_desc",
      "statement": "J : Type uâ‚\ninstâœÂ² : Category.{vâ‚, uâ‚} J\nK : Type uâ‚‚\ninstâœÂ¹ : Category.{vâ‚‚, uâ‚‚} K\nC : Type uâ‚ƒ\ninstâœ : Category.{vâ‚ƒ, uâ‚ƒ} C\nF : J â¥¤ C\nr s t : Cocone F\nP : IsColimit s\nQ : IsColimit t\nâŠ¢ âˆ€ (j : J), t.Î¹.app j â‰« (P.coconePointUniqueUpToIso Q).inv â‰« P.desc r = r.Î¹.app j"
    },
    {
      "name": "CategoryTheory.Limits.PullbackCone.unop_inl",
      "statement": "C : Type uâ‚\ninstâœÂ¹ : Category.{vâ‚, uâ‚} C\nJ : Type uâ‚‚\ninstâœ : Category.{vâ‚‚, uâ‚‚} J\nXâœ : Type vâ‚‚\nX Y Z : Cáµ’áµ–\nf : X âŸ¶ Z\ng : Y âŸ¶ Z\nc : PullbackCone f g\nâŠ¢ c.unop.inl = c.fst.unop"
    },
    {
      "name": "CategoryTheory.Limits.Types.Pushout.inr_rel'_inr_iff",
      "statement": "S Xâ‚ Xâ‚‚ : Type u\nf : S âŸ¶ Xâ‚\ng : S âŸ¶ Xâ‚‚\nxâ‚‚ yâ‚‚ : Xâ‚‚\nâŠ¢ Rel' f g (Sum.inr xâ‚‚) (Sum.inr yâ‚‚) â†” xâ‚‚ = yâ‚‚"
    },
    {
      "name": "CategoryTheory.Limits.Types.pi_lift_Ï€_apply'",
      "statement": "Î² : Type v\nf : Î² â†’ Type v\nP : Type v\ns : (b : Î²) â†’ P âŸ¶ f b\nb : Î²\nx : P\nâŠ¢ Pi.Ï€ f b (Pi.lift s x) = s b x"
    },
    {
      "name": "CategoryTheory.Limits.biprod.inr_map",
      "statement": "J : Type w\nC : Type u\ninstâœâµ : Category.{v, u} C\ninstâœâ´ : HasZeroMorphisms C\nD : Type uD\ninstâœÂ³ : Category.{uD', uD} D\ninstâœÂ² : HasZeroMorphisms D\nP Q W X Y Z : C\ninstâœÂ¹ : HasBinaryBiproduct W X\ninstâœ : HasBinaryBiproduct Y Z\nf : W âŸ¶ Y\ng : X âŸ¶ Z\nâŠ¢ inr â‰« map f g = g â‰« inr"
    },
    {
      "name": "CategoryTheory.Limits.biprod.isoProd_hom",
      "statement": "J : Type w\nC : Type u\ninstâœâ´ : Category.{v, u} C\ninstâœÂ³ : HasZeroMorphisms C\nD : Type uD\ninstâœÂ² : Category.{uD', uD} D\ninstâœÂ¹ : HasZeroMorphisms D\nP Q X Y : C\ninstâœ : HasBinaryBiproduct X Y\nâŠ¢ (isoProd X Y).hom = prod.lift fst snd"
    },
    {
      "name": "CategoryTheory.Limits.biprod_isZero_iff",
      "statement": "J : Type w\nC : Type u\ninstâœâ´ : Category.{v, u} C\ninstâœÂ³ : HasZeroMorphisms C\nD : Type uD\ninstâœÂ² : Category.{uD', uD} D\ninstâœÂ¹ : HasZeroMorphisms D\nP Q A B : C\ninstâœ : HasBinaryBiproduct A B\nâŠ¢ IsZero (A âŠ B) â†” IsZero A âˆ§ IsZero B"
    },
    {
      "name": "CategoryTheory.Limits.colimitCurrySwapCompColimIsoColimitCurryCompColim_Î¹_Î¹_inv",
      "statement": "J K : Type v\ninstâœÂ³ : SmallCategory J\ninstâœÂ² : SmallCategory K\nC : Type u\ninstâœÂ¹ : Category.{v, u} C\nF : J â¥¤ K â¥¤ C\nG : J Ã— K â¥¤ C\ninstâœ : HasColimits C\nj : J\nk : K\nâŠ¢ colimit.Î¹ ((curry.obj G).obj j) k â‰«\n      colimit.Î¹ (curry.obj G â‹™ colim) j â‰« (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =\n    colimit.Î¹ ((curry.obj (Prod.swap K J â‹™ G)).obj k) j â‰« colimit.Î¹ (curry.obj (Prod.swap K J â‹™ G) â‹™ colim) k"
    },
    {
      "name": "CategoryTheory.Limits.limitCurrySwapCompLimIsoLimitCurryCompLim_hom_Ï€_Ï€",
      "statement": "J K : Type v\ninstâœÂ³ : SmallCategory J\ninstâœÂ² : SmallCategory K\nC : Type u\ninstâœÂ¹ : Category.{v, u} C\nF : J â¥¤ K â¥¤ C\nG : J Ã— K â¥¤ C\ninstâœ : HasLimits C\nj : J\nk : K\nâŠ¢ (limitCurrySwapCompLimIsoLimitCurryCompLim G).hom â‰« limit.Ï€ (curry.obj G â‹™ lim) j â‰« limit.Ï€ ((curry.obj G).obj j) k =\n    limit.Ï€ (curry.obj (Prod.swap K J â‹™ G) â‹™ lim) k â‰« limit.Ï€ ((curry.obj (Prod.swap K J â‹™ G)).obj k) j"
    },
    {
      "name": "CategoryTheory.Limits.pullbackDiagonalMapIdIso_inv_fst",
      "statement": "C : Type u_1\ninstâœâµ : Category.{u_2, u_1} C\nX Y Z : C\ninstâœâ´ : HasPullbacks C\nS T : C\nf : X âŸ¶ T\ng : Y âŸ¶ T\ni : T âŸ¶ S\ninstâœÂ³ : HasPullback i i\ninstâœÂ² : HasPullback f g\ninstâœÂ¹ : HasPullback (f â‰« i) (g â‰« i)\ninstâœ : HasPullback (diagonal i) (map (f â‰« i) (g â‰« i) i i f g (ğŸ™ S) â‹¯ â‹¯)\nâŠ¢ (pullbackDiagonalMapIdIso f g i).inv â‰« fst = fst â‰« f"
    },
    {
      "name": "CategoryTheory.Limits.pullbackDiagonalMapIdIso_inv_snd_snd",
      "statement": "C : Type u_1\ninstâœâµ : Category.{u_2, u_1} C\nX Y Z : C\ninstâœâ´ : HasPullbacks C\nS T : C\nf : X âŸ¶ T\ng : Y âŸ¶ T\ni : T âŸ¶ S\ninstâœÂ³ : HasPullback i i\ninstâœÂ² : HasPullback f g\ninstâœÂ¹ : HasPullback (f â‰« i) (g â‰« i)\ninstâœ : HasPullback (diagonal i) (map (f â‰« i) (g â‰« i) i i f g (ğŸ™ S) â‹¯ â‹¯)\nâŠ¢ (pullbackDiagonalMapIdIso f g i).inv â‰« snd â‰« snd = snd"
    },
    {
      "name": "CategoryTheory.Limits.pullbackIsoUnopPushout_hom_inl",
      "statement": "C : Type uâ‚\ninstâœÂ³ : Category.{vâ‚, uâ‚} C\nJ : Type uâ‚‚\ninstâœÂ² : Category.{vâ‚‚, uâ‚‚} J\nXâœ : Type vâ‚‚\nX Y Z : C\nf : X âŸ¶ Z\ng : Y âŸ¶ Z\ninstâœÂ¹ : HasPullback f g\ninstâœ : HasPushout f.op g.op\nâŠ¢ pushout.inl â‰« (pullbackIsoUnopPushout f g).hom.op = pullback.fst.op"
    },
    {
      "name": "CategoryTheory.Limits.pushoutIsoUnopPullback_inv_snd",
      "statement": "C : Type uâ‚\ninstâœÂ³ : Category.{vâ‚, uâ‚} C\nJ : Type uâ‚‚\ninstâœÂ² : Category.{vâ‚‚, uâ‚‚} J\nXâœ : Type vâ‚‚\nX Y Z : C\nf : X âŸ¶ Z\ng : X âŸ¶ Y\ninstâœÂ¹ : HasPushout f g\ninstâœ : HasPullback f.op g.op\nâŠ¢ (pushoutIsoUnopPullback f g).inv.op â‰« pullback.snd = pushout.inr.op"
    },
    {
      "name": "CategoryTheory.Limits.terminal.comp_from",
      "statement": "C : Type uâ‚\ninstâœÂ¹ : Category.{vâ‚, uâ‚} C\ninstâœ : HasTerminal C\nP Q : C\nf : P âŸ¶ Q\nâŠ¢ f â‰« from Q = from P"
    },
    {
      "name": "CategoryTheory.Limits.Î¹_colimitConstInitial_hom",
      "statement": "Câœ : Type uâ‚\ninstâœÂ³ : Category.{vâ‚, uâ‚} Câœ\nJ : Type u_1\ninstâœÂ² : Category.{u_3, u_1} J\nC : Type u_2\ninstâœÂ¹ : Category.{u_4, u_2} C\ninstâœ : HasInitial C\nj : J\nâŠ¢ colimit.Î¹ ((Functor.const J).obj (âŠ¥_ C)) j â‰« colimitConstInitial.hom = initial.to (âŠ¥_ C)"
    },
    {
      "name": "CategoryTheory.Localization.Construction.fac",
      "statement": "C : Type uC\ninstâœÂ¹ : Category.{uC', uC} C\nW : MorphismProperty C\nD : Type uD\ninstâœ : Category.{uD', uD} D\nG : C â¥¤ D\nhG : W.IsInvertedBy G\nâŠ¢ âˆ€ (X Y : C) (f : X âŸ¶ Y), (W.Q â‹™ lift G hG).map f = eqToHom â‹¯ â‰« G.map f â‰« eqToHom â‹¯"
    },
    {
      "name": "CategoryTheory.LocalizerMorphism.id_homMap",
      "statement": "C : Type u_1\nCâ‚ : Type u_2\nCâ‚‚ : Type u_3\nCâ‚ƒ : Type u_4\nDâ‚ : Type u_5\nDâ‚‚ : Type u_6\nDâ‚ƒ : Type u_7\ninstâœâ¹ : Category.{?u.24763, u_1} C\ninstâœâ¸ : Category.{u_9, u_2} Câ‚\ninstâœâ· : Category.{?u.24771, u_3} Câ‚‚\ninstâœâ¶ : Category.{?u.24775, u_4} Câ‚ƒ\ninstâœâµ : Category.{u_8, u_5} Dâ‚\ninstâœâ´ : Category.{?u.24783, u_6} Dâ‚‚\ninstâœÂ³ : Category.{?u.24787, u_7} Dâ‚ƒ\nWâ‚ : MorphismProperty Câ‚\nWâ‚‚ : MorphismProperty Câ‚‚\nWâ‚ƒ : MorphismProperty Câ‚ƒ\nÎ¦ : LocalizerMorphism Wâ‚ Wâ‚‚\nÎ¨ : LocalizerMorphism Wâ‚‚ Wâ‚ƒ\nLâ‚ : Câ‚ â¥¤ Dâ‚\ninstâœÂ² : Lâ‚.IsLocalization Wâ‚\nLâ‚‚ : Câ‚‚ â¥¤ Dâ‚‚\ninstâœÂ¹ : Lâ‚‚.IsLocalization Wâ‚‚\nLâ‚ƒ : Câ‚ƒ â¥¤ Dâ‚ƒ\ninstâœ : Lâ‚ƒ.IsLocalization Wâ‚ƒ\nX Y Z : Câ‚\nf : Lâ‚.obj X âŸ¶ Lâ‚.obj Y\nâŠ¢ (id Wâ‚).homMap Lâ‚ Lâ‚ f = f"
    },
    {
      "name": "CategoryTheory.Mat_.additiveObjIsoBiproduct_hom_Ï€",
      "statement": "C : Type uâ‚\ninstâœâ´ : Category.{vâ‚, uâ‚} C\ninstâœÂ³ : Preadditive C\nD : Type uâ‚\ninstâœÂ² : Category.{vâ‚, uâ‚} D\ninstâœÂ¹ : Preadditive D\nF : Mat_ C â¥¤ D\ninstâœ : F.Additive\nM : Mat_ C\ni : M.Î¹\nâŠ¢ (additiveObjIsoBiproduct F M).hom â‰« biproduct.Ï€ (fun i => F.obj ((embedding C).obj (M.X i))) i =\n    F.map (M.isoBiproductEmbedding.hom â‰« biproduct.Ï€ (fun i => (embedding C).obj (M.X i)) i)"
    },
    {
      "name": "CategoryTheory.Mat_.Î¹_additiveObjIsoBiproduct_inv",
      "statement": "C : Type uâ‚\ninstâœâ´ : Category.{vâ‚, uâ‚} C\ninstâœÂ³ : Preadditive C\nD : Type uâ‚\ninstâœÂ² : Category.{vâ‚, uâ‚} D\ninstâœÂ¹ : Preadditive D\nF : Mat_ C â¥¤ D\ninstâœ : F.Additive\nM : Mat_ C\ni : M.Î¹\nâŠ¢ biproduct.Î¹ (fun i => F.obj ((embedding C).obj (M.X i))) i â‰« (additiveObjIsoBiproduct F M).inv =\n    F.map (biproduct.Î¹ (fun i => (embedding C).obj (M.X i)) i â‰« M.isoBiproductEmbedding.inv)"
    },
    {
      "name": "CategoryTheory.MonoidalCategory.leftUnitor_inv_tensor_id",
      "statement": "C : Type u_1\ninstâœÂ¹ : Category.{u_2, u_1} C\ninstâœ : MonoidalCategory C\nX Y : C\nâŠ¢ (Î»_ X).inv âŠ— ğŸ™ Y = (Î»_ (X âŠ— Y)).inv â‰« (Î±_ (ğŸ™_ C) X Y).inv"
    },
    {
      "name": "CategoryTheory.PreGaloisCategory.fiberPullbackEquiv_symm_snd_apply",
      "statement": "C : Type uâ‚\ninstâœÂ² : Category.{uâ‚‚, uâ‚} C\ninstâœÂ¹ : PreGaloisCategory C\nF : C â¥¤ FintypeCat\ninstâœ : FiberFunctor F\nX A B : C\nf : A âŸ¶ X\ng : B âŸ¶ X\na : â†‘(F.obj A)\nb : â†‘(F.obj B)\nh : F.map f a = F.map g b\nâŠ¢ F.map pullback.snd ((fiberPullbackEquiv F f g).symm âŸ¨(a, b), hâŸ©) = b"
    },
    {
      "name": "CategoryTheory.Presieve.extend_restrict",
      "statement": "C : Type uâ‚\ninstâœ : Category.{vâ‚, uâ‚} C\nP Q U : Cáµ’áµ– â¥¤ Type w\nX Y : C\nS : Sieve X\nR : Presieve X\nx : FamilyOfElements P (generate R).arrows\nt : x.Compatible\nâŠ¢ (FamilyOfElements.restrict â‹¯ x).sieveExtend = x"
    },
    {
      "name": "CategoryTheory.Presieve.factorsThruAlong_id",
      "statement": "C : Type u_2\nD : Type ?u.1161\ninstâœÂ¹ : Category.{u_1, u_2} C\ninstâœ : Category.{?u.1169, ?u.1161} D\nX : C\nS T : Presieve X\nâŠ¢ S.FactorsThruAlong T (ğŸ™ X) â†” S.FactorsThru T"
    },
    {
      "name": "CategoryTheory.ShortComplex.LeftHomologyData.cyclesIso_hom_comp_i",
      "statement": "C : Type u_1\ninstâœÂ² : Category.{u_2, u_1} C\ninstâœÂ¹ : HasZeroMorphisms C\nS Sâ‚ Sâ‚‚ Sâ‚ƒ : ShortComplex C\nh : S.LeftHomologyData\ninstâœ : S.HasLeftHomology\nâŠ¢ h.cyclesIso.hom â‰« h.i = S.iCycles"
    },
    {
      "name": "CategoryTheory.ShortComplex.cyclesMap'_add",
      "statement": "C : Type u_1\ninstâœÂ¹ : Category.{u_2, u_1} C\ninstâœ : Preadditive C\nSâ‚ Sâ‚‚ Sâ‚ƒ : ShortComplex C\nÏ† Ï†' : Sâ‚ âŸ¶ Sâ‚‚\nhâ‚ : Sâ‚.LeftHomologyData\nhâ‚‚ : Sâ‚‚.LeftHomologyData\nâŠ¢ cyclesMap' (Ï† + Ï†') hâ‚ hâ‚‚ = cyclesMap' Ï† hâ‚ hâ‚‚ + cyclesMap' Ï†' hâ‚ hâ‚‚"
    },
    {
      "name": "CategoryTheory.ShortComplex.exact_of_f_is_kernel",
      "statement": "C : Type u_1\nD : Type u_2\ninstâœâ´ : Category.{u_3, u_1} C\ninstâœÂ³ : Category.{?u.61126, u_2} D\ninstâœÂ² : Preadditive C\ninstâœÂ¹ : Preadditive D\nS : ShortComplex C\nhS : IsLimit (KernelFork.ofÎ¹ S.f â‹¯)\ninstâœ : S.HasHomology\nâŠ¢ S.Exact"
    },
    {
      "name": "CategoryTheory.ShortComplex.opcyclesMap'_sub",
      "statement": "C : Type u_1\ninstâœÂ¹ : Category.{u_2, u_1} C\ninstâœ : Preadditive C\nSâ‚ Sâ‚‚ Sâ‚ƒ : ShortComplex C\nÏ† Ï†' : Sâ‚ âŸ¶ Sâ‚‚\nhâ‚ : Sâ‚.RightHomologyData\nhâ‚‚ : Sâ‚‚.RightHomologyData\nâŠ¢ opcyclesMap' (Ï† - Ï†') hâ‚ hâ‚‚ = opcyclesMap' Ï† hâ‚ hâ‚‚ - opcyclesMap' Ï†' hâ‚ hâ‚‚"
    },
    {
      "name": "CategoryTheory.Sieve.mem_ofObjects_iff",
      "statement": "C : Type uâ‚\ninstâœÂ¹ : Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœ : Category.{vâ‚‚, uâ‚‚} D\nF : C â¥¤ D\nXâœ Yâœ Zâœ : C\nf : Yâœ âŸ¶ Xâœ\nS R : Sieve Xâœ\nI : Type u_1\nY : I â†’ C\nZ X : C\ng : Z âŸ¶ X\nâŠ¢ (ofObjects Y X).arrows g â†” âˆƒ i, Nonempty (Z âŸ¶ Y i)"
    },
    {
      "name": "CategoryTheory.StructuredArrow.eqToHom_right",
      "statement": "C : Type uâ‚\ninstâœÂ¹ : Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœ : Category.{vâ‚‚, uâ‚‚} D\nS S' S'' : D\nYâœ Y' Y'' : C\nT T' : C â¥¤ D\nX Y : StructuredArrow S T\nh : X = Y\nâŠ¢ X.right = Y.right"
    },
    {
      "name": "CategoryTheory.StructuredArrow.homMk'_comp",
      "statement": "C : Type uâ‚\ninstâœÂ¹ : Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœ : Category.{vâ‚‚, uâ‚‚} D\nS S' S'' : D\nY Y' Y'' : C\nT T' : C â¥¤ D\nf : StructuredArrow S T\ng : f.right âŸ¶ Y'\ng' : Y' âŸ¶ Y''\nâŠ¢ mk ((mk (f.hom â‰« T.map g)).hom â‰« T.map g') = mk (f.hom â‰« T.map (g â‰« g'))"
    },
    {
      "name": "CategoryTheory.StructuredArrow.homMk'_mk_comp",
      "statement": "C : Type uâ‚\ninstâœÂ¹ : Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœ : Category.{vâ‚‚, uâ‚‚} D\nS S' S'' : D\nY Y' Y'' : C\nT T' : C â¥¤ D\nf : S âŸ¶ T.obj Y\ng : Y âŸ¶ Y'\ng' : Y' âŸ¶ Y''\nâŠ¢ mk ((mk (f â‰« T.map g)).hom â‰« T.map g') = mk ((mk f).hom â‰« T.map (g â‰« g'))"
    },
    {
      "name": "CategoryTheory.Subobject.factorThru_eq_zero",
      "statement": "C : Type uâ‚\ninstâœÂ² : Category.{vâ‚, uâ‚} C\nXâœ Yâœ Z : C\nD : Type uâ‚‚\ninstâœÂ¹ : Category.{vâ‚‚, uâ‚‚} D\ninstâœ : HasZeroMorphisms C\nX Y : C\nP : Subobject Y\nf : X âŸ¶ Y\nh : P.Factors f\nâŠ¢ P.factorThru f h = 0 â†” f = 0"
    },
    {
      "name": "CategoryTheory.Subobject.inf_factors",
      "statement": "C : Type uâ‚\ninstâœÂ² : Category.{vâ‚, uâ‚} C\nXâœ Yâœ Z : C\nD : Type uâ‚‚\ninstâœÂ¹ : Category.{vâ‚‚, uâ‚‚} D\ninstâœ : HasPullbacks C\nA B : C\nX Y : Subobject B\nf : A âŸ¶ B\nâŠ¢ X.Factors f âˆ§ Y.Factors f â†’ (X âŠ“ Y).Factors f"
    },
    {
      "name": "CategoryTheory.Subobject.ofLEMk_comp",
      "statement": "C : Type uâ‚\ninstâœÂ² : Category.{vâ‚, uâ‚} C\nXâœ Y Z : C\nD : Type uâ‚‚\ninstâœÂ¹ : Category.{vâ‚‚, uâ‚‚} D\nB A : C\nX : Subobject B\nf : A âŸ¶ B\ninstâœ : Mono f\nh : X â‰¤ mk f\nâŠ¢ X.ofLEMk f h â‰« f = X.arrow"
    },
    {
      "name": "CategoryTheory.Subobject.ofMkLEMk_refl",
      "statement": "C : Type uâ‚\ninstâœÂ² : Category.{vâ‚, uâ‚} C\nX Y Z : C\nD : Type uâ‚‚\ninstâœÂ¹ : Category.{vâ‚‚, uâ‚‚} D\nB Aâ‚ : C\nf : Aâ‚ âŸ¶ B\ninstâœ : Mono f\nâŠ¢ ofMkLEMk f f â‹¯ = ğŸ™ Aâ‚"
    },
    {
      "name": "CategoryTheory.TwoSquare.GuitartExact.whiskerVertical_iff",
      "statement": "Câ‚ : Type u_1\nCâ‚‚ : Type u_2\nCâ‚ƒ : Type u_3\nDâ‚ : Type u_4\nDâ‚‚ : Type u_5\nDâ‚ƒ : Type u_6\ninstâœâµ : Category.{u_8, u_1} Câ‚\ninstâœâ´ : Category.{u_7, u_2} Câ‚‚\ninstâœÂ³ : Category.{?u.17114, u_3} Câ‚ƒ\ninstâœÂ² : Category.{u_10, u_4} Dâ‚\ninstâœÂ¹ : Category.{u_9, u_5} Dâ‚‚\ninstâœ : Category.{?u.17126, u_6} Dâ‚ƒ\nT : Câ‚ â¥¤ Dâ‚\nL : Câ‚ â¥¤ Câ‚‚\nR : Dâ‚ â¥¤ Dâ‚‚\nB : Câ‚‚ â¥¤ Dâ‚‚\nw : TwoSquare T L R B\nL' : Câ‚ â¥¤ Câ‚‚\nR' : Dâ‚ â¥¤ Dâ‚‚\nÎ± : L â‰… L'\nÎ² : R â‰… R'\nâŠ¢ (w.whiskerVertical Î±.hom Î².inv).GuitartExact â†” w.GuitartExact"
    },
    {
      "name": "CategoryTheory.braiding_leftUnitor_auxâ‚‚",
      "statement": "C : Type uâ‚\ninstâœÂ² : Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : MonoidalCategory C\ninstâœ : BraidedCategory C\nX : C\nâŠ¢ (Î²_ X (ğŸ™_ C)).hom â–· ğŸ™_ C â‰« (Î»_ X).hom â–· ğŸ™_ C =\n    (Î²_ X (ğŸ™_ C)).hom â–· ğŸ™_ C â‰« (Î±_ (ğŸ™_ C) X (ğŸ™_ C)).hom â‰« (Î±_ (ğŸ™_ C) X (ğŸ™_ C)).inv â‰« (Î»_ X).hom â–· ğŸ™_ C"
    },
    {
      "name": "CategoryTheory.braiding_rightUnitor_auxâ‚‚",
      "statement": "C : Type uâ‚\ninstâœÂ² : Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : MonoidalCategory C\ninstâœ : BraidedCategory C\nX : C\nâŠ¢ ğŸ™_ C â— (Î²_ (ğŸ™_ C) X).hom â‰« ğŸ™_ C â— (Ï_ X).hom =\n    ğŸ™_ C â— (Î²_ (ğŸ™_ C) X).hom â‰« (Î±_ (ğŸ™_ C) X (ğŸ™_ C)).inv â‰« (Î±_ (ğŸ™_ C) X (ğŸ™_ C)).hom â‰« ğŸ™_ C â— (Ï_ X).hom"
    },
    {
      "name": "CategoryTheory.congrArg_mpr_hom_right",
      "statement": "C : Type uâ‚\ninstâœ : Category.{vâ‚, uâ‚} C\nÎ² : Sort u_1\nX Y Z : C\np : X âŸ¶ Y\nq : Z = Y\nâŠ¢ â‹¯.mpr p = p â‰« eqToHom â‹¯"
    },
    {
      "name": "CategoryTheory.eqToHom_app",
      "statement": "C : Type uâ‚\ninstâœÂ¹ : Category.{vâ‚, uâ‚} C\nÎ² : Sort u_1\nD : Type uâ‚‚\ninstâœ : Category.{vâ‚‚, uâ‚‚} D\nF G : C â¥¤ D\nh : F = G\nX : C\nâŠ¢ (eqToHom h).app X = eqToHom â‹¯"
    },
    {
      "name": "CategoryTheory.eqToHom_iso_hom_naturality",
      "statement": "C : Type uâ‚\ninstâœ : Category.{vâ‚, uâ‚} C\nÎ² : Sort u_1\nf g : Î² â†’ C\nz : (b : Î²) â†’ f b â‰… g b\nj j' : Î²\nw : j = j'\nâŠ¢ g j = g j'"
    },
    {
      "name": "CategoryTheory.eqToHom_iso_inv_naturality",
      "statement": "C : Type uâ‚\ninstâœ : Category.{vâ‚, uâ‚} C\nÎ² : Sort u_1\nf g : Î² â†’ C\nz : (b : Î²) â†’ f b â‰… g b\nj j' : Î²\nw : j = j'\nâŠ¢ f j = f j'"
    },
    {
      "name": "CategoryTheory.eqToIso_trans",
      "statement": "C : Type uâ‚\ninstâœ : Category.{vâ‚, uâ‚} C\nÎ² : Sort u_1\nX Y Z : C\np : X = Y\nq : Y = Z\nâŠ¢ eqToIso p â‰ªâ‰« eqToIso q = eqToIso â‹¯"
    },
    {
      "name": "CategoryTheory.monoidalOfHasFiniteProducts.associator_hom_fst",
      "statement": "C : Type u\ninstâœÂ² : Category.{v, u} C\nXâœ Yâœ : C\ninstâœÂ¹ : HasTerminal C\ninstâœ : HasBinaryProducts C\nX Y Z : C\nâŠ¢ (Î±_ X Y Z).hom â‰« prod.fst = prod.fst â‰« prod.fst"
    },
    {
      "name": "CategoryTheory.tensorRightHomEquiv_whiskerRight_comp_evaluation",
      "statement": "C : Type uâ‚\ninstâœÂ² : Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : MonoidalCategory C\nX Y : C\ninstâœ : HasRightDual X\nf : Y âŸ¶ Xá˜\nâŠ¢ (tensorRightHomEquiv Y X Xá˜ (ğŸ™_ C)) (f â–· X â‰« Îµ_ X Xá˜) = ğŸ™ Y âŠ—â‰« (Y â— Î·_ X Xá˜ â‰« f â–· (X âŠ— Xá˜)) âŠ—â‰« Îµ_ X Xá˜ â–· Xá˜"
    },
    {
      "name": "ChainComplex.mk'_d_1_0",
      "statement": "Î¹ : Type u_1\nV : Type u\ninstâœÂ¹ : Category.{v, u} V\ninstâœ : HasZeroMorphisms V\nXâ‚€ Xâ‚ Xâ‚‚ : V\ndâ‚€ : Xâ‚ âŸ¶ Xâ‚€\ndâ‚ : Xâ‚‚ âŸ¶ Xâ‚\ns : dâ‚ â‰« dâ‚€ = 0\nsucc : (S : ShortComplex V) â†’ (Xâ‚ƒ : V) Ã—' (dâ‚‚ : Xâ‚ƒ âŸ¶ S.Xâ‚) Ã—' dâ‚‚ â‰« S.f = 0\nsucc' : {Xâ‚€ Xâ‚ : V} â†’ (f : Xâ‚ âŸ¶ Xâ‚€) â†’ (Xâ‚‚ : V) Ã—' (d : Xâ‚‚ âŸ¶ Xâ‚) Ã—' d â‰« f = 0\nâŠ¢ (mk' Xâ‚€ Xâ‚ dâ‚€ fun {Xâ‚€ Xâ‚} => succ').d 1 0 = dâ‚€"
    },
    {
      "name": "CircleDeg1Lift.translationNumber_zpow",
      "statement": "fâœ g : CircleDeg1Lift\nf : CircleDeg1LiftË£\nn : â„•\nâŠ¢ Ï„ â†‘(f ^ â†‘n) = â†‘â†‘n * Ï„ â†‘f"
    },
    {
      "name": "Class.sUnion_apply",
      "statement": "x : Class\ny : ZFSet\nâŠ¢ (â‹ƒâ‚€ x) y â†” âˆƒ z, x z âˆ§ y âˆˆ z"
    },
    {
      "name": "ClassGroup.equiv_mk0",
      "statement": "R : Type u_1\nK : Type u_2\nL : Type u_3\ninstâœÂ¹Â¹ : CommRing R\ninstâœÂ¹â° : Field K\ninstâœâ¹ : Field L\ninstâœâ¸ : DecidableEq L\ninstâœâ· : Algebra R K\ninstâœâ¶ : IsFractionRing R K\ninstâœâµ : Algebra K L\ninstâœâ´ : FiniteDimensional K L\ninstâœÂ³ : Algebra R L\ninstâœÂ² : IsScalarTower R K L\ninstâœÂ¹ : IsDomain R\ninstâœ : IsDedekindDomain R\nI : â†¥(Ideal R)â°\nâŠ¢ (equiv K) (mk0 I) = (QuotientGroup.mk' (toPrincipalIdeal R K).range) ((FractionalIdeal.mk0 K) I)"
    },
    {
      "name": "CliffordAlgebra.changeForm_self_apply",
      "statement": "R : Type u1\ninstâœÂ² : CommRing R\nM : Type u2\ninstâœÂ¹ : AddCommGroup M\ninstâœ : Module R M\nQ Q' Q'' : QuadraticForm R M\nB B' : BilinForm R M\nh : B.toQuadraticForm = Q' - Q\nh' : B'.toQuadraticForm = Q'' - Q'\nx : CliffordAlgebra Q\nâŠ¢ (changeForm â‹¯) x = x"
    },
    {
      "name": "CliffordAlgebra.map_comp_map",
      "statement": "R : Type u_1\ninstâœÂ¹â° : CommRing R\nM : Type u_2\ninstâœâ¹ : AddCommGroup M\ninstâœâ¸ : Module R M\nQ : QuadraticForm R M\nn : â„•\nA : Type u_3\ninstâœâ· : Semiring A\ninstâœâ¶ : Algebra R A\nMâ‚ : Type u_4\nMâ‚‚ : Type u_5\nMâ‚ƒ : Type u_6\ninstâœâµ : AddCommGroup Mâ‚\ninstâœâ´ : AddCommGroup Mâ‚‚\ninstâœÂ³ : AddCommGroup Mâ‚ƒ\ninstâœÂ² : Module R Mâ‚\ninstâœÂ¹ : Module R Mâ‚‚\ninstâœ : Module R Mâ‚ƒ\nQâ‚ : QuadraticForm R Mâ‚\nQâ‚‚ : QuadraticForm R Mâ‚‚\nQâ‚ƒ : QuadraticForm R Mâ‚ƒ\nf : Qâ‚‚ â†’qáµ¢ Qâ‚ƒ\ng : Qâ‚ â†’qáµ¢ Qâ‚‚\nâŠ¢ (map f).comp (map g) = map (f.comp g)"
    },
    {
      "name": "CliffordAlgebra.Î¹_sq_scalar",
      "statement": "R : Type u_1\ninstâœÂ² : CommRing R\nM : Type u_2\ninstâœÂ¹ : AddCommGroup M\ninstâœ : Module R M\nQ : QuadraticForm R M\nn : â„•\nm : M\nâŠ¢ (Î¹ Q) m * (Î¹ Q) m = (algebraMap R (CliffordAlgebra Q)) (Q m)"
    },
    {
      "name": "CochainComplex.cochainComplex_d_succ_succ_zero",
      "statement": "V : Type u\ninstâœÂ¹ : Category.{v, u} V\ninstâœ : HasZeroMorphisms V\nC : CochainComplex V â„•\ni : â„•\nâŠ¢ C.d 0 (i + 2) = 0"
    },
    {
      "name": "CochainComplex.mappingCone.liftCochain_descCochain",
      "statement": "C : Type u_1\ninstâœÂ² : Category.{?u.241335, u_1} C\ninstâœÂ¹ : Preadditive C\nF G : CochainComplex C â„¤\nÏ† : F âŸ¶ G\ninstâœ : HasHomotopyCofiber Ï†\nK L : CochainComplex C â„¤\nn m : â„¤\nÎ± : Cochain K F m\nÎ² : Cochain K G n\nn' m' : â„¤\nÎ±' : Cochain F L m'\nÎ²' : Cochain G L n'\nh : n + 1 = m\nh' : m' + 1 = n'\np : â„¤\nhp : n + n' = p\nâŠ¢ m + m' = p"
    },
    {
      "name": "CochainComplex.mk'_d_1_0",
      "statement": "Î¹ : Type u_1\nV : Type u\ninstâœÂ¹ : Category.{v, u} V\ninstâœ : HasZeroMorphisms V\nXâ‚€ Xâ‚ Xâ‚‚ : V\ndâ‚€ : Xâ‚€ âŸ¶ Xâ‚\ndâ‚ : Xâ‚ âŸ¶ Xâ‚‚\ns : dâ‚€ â‰« dâ‚ = 0\nsucc : (S : ShortComplex V) â†’ (Xâ‚„ : V) Ã—' (dâ‚‚ : S.Xâ‚ƒ âŸ¶ Xâ‚„) Ã—' S.g â‰« dâ‚‚ = 0\nsucc' : {Xâ‚€ Xâ‚ : V} â†’ (f : Xâ‚€ âŸ¶ Xâ‚) â†’ (Xâ‚‚ : V) Ã—' (d : Xâ‚ âŸ¶ Xâ‚‚) Ã—' f â‰« d = 0\nâŠ¢ (mk' Xâ‚€ Xâ‚ dâ‚€ fun {Xâ‚€ Xâ‚} => succ').d 0 1 = dâ‚€"
    },
    {
      "name": "CochainComplex.of_d_ne",
      "statement": "Î¹ : Type u_1\nV : Type u\ninstâœâ´ : Category.{v, u} V\ninstâœÂ³ : HasZeroMorphisms V\nÎ± : Type u_2\ninstâœÂ² : AddRightCancelSemigroup Î±\ninstâœÂ¹ : One Î±\ninstâœ : DecidableEq Î±\nX : Î± â†’ V\nd : (n : Î±) â†’ X n âŸ¶ X (n + 1)\nsq : âˆ€ (n : Î±), d n â‰« d (n + 1) = 0\ni j : Î±\nh : i + 1 â‰  j\nâŠ¢ (of X d sq).d i j = 0"
    },
    {
      "name": "Combinatorics.Line.vertical_apply",
      "statement": "Î± : Type u_1\nÎ¹ : Type u_2\nÎ¹' : Type u_3\nv : Î¹ â†’ Î±\nl : Line Î± Î¹'\nx : Î±\nâŠ¢ (fun x i => ((vertical v l).idxFun i).getD x) x = Sum.elim v ((fun x i => (l.idxFun i).getD x) x)"
    },
    {
      "name": "CommRingCat.Colimits.cocone_naturality",
      "statement": "J : Type v\ninstâœ : SmallCategory J\nF : J â¥¤ CommRingCat\nj j' : J\nf : j âŸ¶ j'\nâŠ¢ F.map f â‰« coconeMorphism F j' = coconeMorphism F j"
    },
    {
      "name": "Commute.div_left",
      "statement": "Î± : Type u_1\nMâ‚€ : Type u_2\nGâ‚€ : Type u_3\nMâ‚€' : Type u_4\nGâ‚€' : Type u_5\nF : Type u_6\nF' : Type u_7\ninstâœÂ¹ : MonoidWithZero Mâ‚€\ninstâœ : GroupWithZero Gâ‚€\na b c : Gâ‚€\nhac : Commute a c\nhbc : Commute b c\nâŠ¢ Commute (a / b) c"
    },
    {
      "name": "Compactum.str_incl",
      "statement": "X : Compactum\nx : X.A\nâŠ¢ X.str (X.incl x) = x"
    },
    {
      "name": "Complex.arg_neg_one",
      "statement": "a x z : â„‚\nâŠ¢ (-1).arg = Ï€"
    },
    {
      "name": "Complex.arg_zero",
      "statement": "a x z : â„‚\nâŠ¢ arg 0 = 0"
    },
    {
      "name": "Complex.closure_setOf_lt_im",
      "statement": "a : â„\nâŠ¢ closure {z | a < z.im} = {z | a â‰¤ z.im}"
    },
    {
      "name": "Complex.coe_basisOneI",
      "statement": "R : Type u_1\nS : Type u_2\ni j : Fin 2\nâŠ¢ (basisOneI.repr (![1, I] i)) j = (Finsupp.single i 1) j"
    },
    {
      "name": "Complex.cos_pi_div_two",
      "statement": "âŠ¢ cos (â†‘Ï€ / 2) = â†‘(Real.cos (Ï€ / 2))"
    },
    {
      "name": "Complex.exp_ne_zero",
      "statement": "x y : â„‚\nh : cexp x = 0\nâŠ¢ 0 = 1"
    },
    {
      "name": "Complex.exp_zero",
      "statement": "x y : â„‚\nâŠ¢ cexp 0 = 1"
    },
    {
      "name": "Complex.interior_setOf_le_im",
      "statement": "a : â„\nâŠ¢ interior {z | a â‰¤ z.im} = {z | a < z.im}"
    },
    {
      "name": "Complex.monotone_ofReal",
      "statement": "âŠ¢ Monotone ofReal'"
    },
    {
      "name": "Complex.reCLM_norm",
      "statement": "âŠ¢ 1 = â€–reCLM 1â€–"
    },
    {
      "name": "Composition.blocksFun_congr",
      "statement": "n : â„•\nc : Composition n\nnâ‚ nâ‚‚ : â„•\ncâ‚ : Composition nâ‚\ncâ‚‚ : Composition nâ‚‚\niâ‚ : Fin câ‚.length\niâ‚‚ : Fin câ‚‚.length\nhn : nâ‚ = nâ‚‚\nhc : câ‚.blocks = câ‚‚.blocks\nhi : â†‘iâ‚ = â†‘iâ‚‚\nâŠ¢ câ‚.blocksFun iâ‚ = câ‚‚.blocksFun iâ‚‚"
    },
    {
      "name": "CompositionSeries.total",
      "statement": "X : Type u\ninstâœÂ¹ : Lattice X\ninstâœ : JordanHolderLattice X\ns : CompositionSeries X\nx y : X\nhx : x âˆˆ s\nhy : y âˆˆ s\nâŠ¢ x â‰¤ y âˆ¨ y â‰¤ x"
    },
    {
      "name": "Computation.bind_assoc",
      "statement": "Î± : Type u\nÎ² : Type v\nÎ³ : Type w\ns : Computation Î±\nf : Î± â†’ Computation Î²\ng : Î² â†’ Computation Î³\nâŠ¢ (s.bind f).bind g = s.bind fun x => (f x).bind g"
    },
    {
      "name": "Computation.mem_map",
      "statement": "Î± : Type u\nÎ² : Type v\nÎ³ : Type w\nf : Î± â†’ Î²\na : Î±\ns : Computation Î±\nm : a âˆˆ s\nâŠ¢ f a âˆˆ map f s"
    },
    {
      "name": "Concept.ext",
      "statement": "Î¹ : Sort u_1\nÎ± : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\nÎº : Î¹ â†’ Sort u_5\nr : Î± â†’ Î² â†’ Prop\ns sâ‚ sâ‚‚ : Set Î±\nt tâ‚ tâ‚‚ : Set Î²\nc d : Concept Î± Î² r\nh : c.toProd.1 = d.toProd.1\nâŠ¢ c = d"
    },
    {
      "name": "Configuration.ProjectivePlane.lineCount_eq_lineCount",
      "statement": "P : Type u_1\nL : Type u_2\ninstâœÂ³ : Membership P L\ninstâœÂ² : ProjectivePlane P L\ninstâœÂ¹ : Finite P\ninstâœ : Finite L\np q : P\nâŠ¢ lineCount L p = lineCount L q"
    },
    {
      "name": "Continuous.stronglyMeasurable",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ¹ : Type u_4\ninstâœâµ : Countable Î¹\nfâœ g : Î± â†’ Î²\ninstâœâ´ : MeasurableSpace Î±\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : OpensMeasurableSpace Î±\ninstâœÂ¹ : TopologicalSpace Î²\ninstâœ : PseudoMetrizableSpace Î²\nh : SecondCountableTopologyEither Î± Î²\nf : Î± â†’ Î²\nhf : Continuous f\nâŠ¢ StronglyMeasurable f"
    },
    {
      "name": "ContinuousLinearMap.hasFPowerSeriesOnBall_bilinear",
      "statement": "ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : E â†’L[ğ•œ] F â†’L[ğ•œ] G\nx : E Ã— F\nâŠ¢ âŠ¤ â‰¤ (f.fpowerSeriesBilinear x).radius"
    },
    {
      "name": "ContinuousLinearMap.inverse_equiv",
      "statement": "R : Type u_1\nM : Type u_2\nMâ‚‚ : Type u_3\ninstâœâ¶ : TopologicalSpace M\ninstâœâµ : TopologicalSpace Mâ‚‚\ninstâœâ´ : Semiring R\ninstâœÂ³ : AddCommMonoid Mâ‚‚\ninstâœÂ² : Module R Mâ‚‚\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : Module R M\ne : M â‰ƒL[R] Mâ‚‚\nâŠ¢ (â†‘e).inverse = â†‘e.symm"
    },
    {
      "name": "ContinuousLinearMap.opNorm_subsingleton",
      "statement": "ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nğ•œâ‚ƒ : Type u_3\nE : Type u_4\nEâ‚— : Type u_5\nF : Type u_6\nFâ‚— : Type u_7\nG : Type u_8\nGâ‚— : Type u_9\nğ“• : Type u_10\ninstâœÂ¹â· : SeminormedAddCommGroup E\ninstâœÂ¹â¶ : SeminormedAddCommGroup Eâ‚—\ninstâœÂ¹âµ : SeminormedAddCommGroup F\ninstâœÂ¹â´ : SeminormedAddCommGroup Fâ‚—\ninstâœÂ¹Â³ : SeminormedAddCommGroup G\ninstâœÂ¹Â² : SeminormedAddCommGroup Gâ‚—\ninstâœÂ¹Â¹ : NontriviallyNormedField ğ•œ\ninstâœÂ¹â° : NontriviallyNormedField ğ•œâ‚‚\ninstâœâ¹ : NontriviallyNormedField ğ•œâ‚ƒ\ninstâœâ¸ : NormedSpace ğ•œ E\ninstâœâ· : NormedSpace ğ•œ Eâ‚—\ninstâœâ¶ : NormedSpace ğ•œâ‚‚ F\ninstâœâµ : NormedSpace ğ•œ Fâ‚—\ninstâœâ´ : NormedSpace ğ•œâ‚ƒ G\nÏƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚\nÏƒâ‚‚â‚ƒ : ğ•œâ‚‚ â†’+* ğ•œâ‚ƒ\nÏƒâ‚â‚ƒ : ğ•œ â†’+* ğ•œâ‚ƒ\ninstâœÂ³ : RingHomCompTriple Ïƒâ‚â‚‚ Ïƒâ‚‚â‚ƒ Ïƒâ‚â‚ƒ\ninstâœÂ² : FunLike ğ“• E F\ninstâœÂ¹ : RingHomIsometric Ïƒâ‚â‚‚\nf : E â†’SL[Ïƒâ‚â‚‚] F\ninstâœ : Subsingleton E\nâŠ¢ â€–fâ€– = 0"
    },
    {
      "name": "ContinuousLinearMap.zero_comp",
      "statement": "Râ‚ : Type u_1\nRâ‚‚ : Type u_2\nRâ‚ƒ : Type u_3\ninstâœÂ¹â· : Semiring Râ‚\ninstâœÂ¹â¶ : Semiring Râ‚‚\ninstâœÂ¹âµ : Semiring Râ‚ƒ\nÏƒâ‚â‚‚ : Râ‚ â†’+* Râ‚‚\nÏƒâ‚‚â‚ƒ : Râ‚‚ â†’+* Râ‚ƒ\nÏƒâ‚â‚ƒ : Râ‚ â†’+* Râ‚ƒ\nMâ‚ : Type u_4\ninstâœÂ¹â´ : TopologicalSpace Mâ‚\ninstâœÂ¹Â³ : AddCommMonoid Mâ‚\nM'â‚ : Type u_5\ninstâœÂ¹Â² : TopologicalSpace M'â‚\ninstâœÂ¹Â¹ : AddCommMonoid M'â‚\nMâ‚‚ : Type u_6\ninstâœÂ¹â° : TopologicalSpace Mâ‚‚\ninstâœâ¹ : AddCommMonoid Mâ‚‚\nMâ‚ƒ : Type u_7\ninstâœâ¸ : TopologicalSpace Mâ‚ƒ\ninstâœâ· : AddCommMonoid Mâ‚ƒ\nMâ‚„ : Type u_8\ninstâœâ¶ : TopologicalSpace Mâ‚„\ninstâœâµ : AddCommMonoid Mâ‚„\ninstâœâ´ : Module Râ‚ Mâ‚\ninstâœÂ³ : Module Râ‚ M'â‚\ninstâœÂ² : Module Râ‚‚ Mâ‚‚\ninstâœÂ¹ : Module Râ‚ƒ Mâ‚ƒ\ninstâœ : RingHomCompTriple Ïƒâ‚â‚‚ Ïƒâ‚‚â‚ƒ Ïƒâ‚â‚ƒ\nf : Mâ‚ â†’SL[Ïƒâ‚â‚‚] Mâ‚‚\nâŠ¢ comp 0 f = 0"
    },
    {
      "name": "ContinuousMap.Homotopy.symm_symm",
      "statement": "Fâœ : Type u_1\nX : Type u\nY : Type v\nZ : Type w\nZ' : Type x\nÎ¹ : Type u_2\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace Y\ninstâœÂ¹ : TopologicalSpace Z\ninstâœ : TopologicalSpace Z'\nfâ‚€ fâ‚ : C(X, Y)\nF : fâ‚€.Homotopy fâ‚\nâŠ¢ F.symm.symm = F"
    },
    {
      "name": "ContinuousMap.coe_sup'",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœâ´ : TopologicalSpace Î±\ninstâœÂ³ : TopologicalSpace Î²\ninstâœÂ² : TopologicalSpace Î³\ninstâœÂ¹ : SemilatticeSup Î²\ninstâœ : ContinuousSup Î²\nÎ¹ : Type u_4\ns : Finset Î¹\nH : s.Nonempty\nf : Î¹ â†’ C(Î±, Î²)\nâŠ¢ â‡‘(s.sup' H f) = s.sup' H fun i => â‡‘(f i)"
    },
    {
      "name": "ContinuousMap.summable_of_locally_summable_norm",
      "statement": "X : Type u_1\ninstâœâ´ : TopologicalSpace X\ninstâœÂ³ : T2Space X\ninstâœÂ² : LocallyCompactSpace X\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : CompleteSpace E\nÎ¹ : Type u_3\nF : Î¹ â†’ C(X, E)\nhF : âˆ€ (K : Compacts X), Summable fun i => â€–restrict (â†‘K) (F i)â€–\nâŠ¢ Summable F"
    },
    {
      "name": "ContinuousMapZero.toNNReal_neg_smul",
      "statement": "X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : Zero X\nr : â„â‰¥0\nf : C(X, â„)â‚€\nâŠ¢ (-(r â€¢ f)).toNNReal = r â€¢ (-f).toNNReal"
    },
    {
      "name": "ContinuousMultilinearMap.curry_uncurryRight",
      "statement": "ğ•œ : Type u\nÎ¹ : Type v\nÎ¹' : Type v'\nn : â„•\nE : Î¹ â†’ Type wE\nEâ‚ : Î¹ â†’ Type wEâ‚\nE' : Î¹' â†’ Type wE'\nEi : Fin n.succ â†’ Type wEi\nG : Type wG\nG' : Type wG'\ninstâœÂ¹â´ : Fintype Î¹\ninstâœÂ¹Â³ : Fintype Î¹'\ninstâœÂ¹Â² : NontriviallyNormedField ğ•œ\ninstâœÂ¹Â¹ : (i : Î¹) â†’ NormedAddCommGroup (E i)\ninstâœÂ¹â° : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœâ¹ : (i : Î¹) â†’ NormedAddCommGroup (Eâ‚ i)\ninstâœâ¸ : (i : Î¹) â†’ NormedSpace ğ•œ (Eâ‚ i)\ninstâœâ· : (i : Î¹') â†’ NormedAddCommGroup (E' i)\ninstâœâ¶ : (i : Î¹') â†’ NormedSpace ğ•œ (E' i)\ninstâœâµ : (i : Fin n.succ) â†’ NormedAddCommGroup (Ei i)\ninstâœâ´ : (i : Fin n.succ) â†’ NormedSpace ğ•œ (Ei i)\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : NormedAddCommGroup G'\ninstâœ : NormedSpace ğ•œ G'\nf : ContinuousMultilinearMap ğ•œ (fun i => Ei i.castSucc) (Ei (last n) â†’L[ğ•œ] G)\nâŠ¢ f.uncurryRight.curryRight = f"
    },
    {
      "name": "ContinuousMultilinearMap.linearDeriv_apply",
      "statement": "R : Type u\nÎ¹ : Type v\nn : â„•\nM : Fin n.succ â†’ Type w\nMâ‚ : Î¹ â†’ Type wâ‚\nMâ‚' : Î¹ â†’ Type wâ‚'\nMâ‚‚ : Type wâ‚‚\nMâ‚ƒ : Type wâ‚ƒ\nMâ‚„ : Type wâ‚„\ninstâœÂ²Â¹ : Semiring R\ninstâœÂ²â° : (i : Fin n.succ) â†’ AddCommMonoid (M i)\ninstâœÂ¹â¹ : (i : Î¹) â†’ AddCommMonoid (Mâ‚ i)\ninstâœÂ¹â¸ : (i : Î¹) â†’ AddCommMonoid (Mâ‚' i)\ninstâœÂ¹â· : AddCommMonoid Mâ‚‚\ninstâœÂ¹â¶ : AddCommMonoid Mâ‚ƒ\ninstâœÂ¹âµ : AddCommMonoid Mâ‚„\ninstâœÂ¹â´ : (i : Fin n.succ) â†’ Module R (M i)\ninstâœÂ¹Â³ : (i : Î¹) â†’ Module R (Mâ‚ i)\ninstâœÂ¹Â² : (i : Î¹) â†’ Module R (Mâ‚' i)\ninstâœÂ¹Â¹ : Module R Mâ‚‚\ninstâœÂ¹â° : Module R Mâ‚ƒ\ninstâœâ¹ : Module R Mâ‚„\ninstâœâ¸ : (i : Fin n.succ) â†’ TopologicalSpace (M i)\ninstâœâ· : (i : Î¹) â†’ TopologicalSpace (Mâ‚ i)\ninstâœâ¶ : (i : Î¹) â†’ TopologicalSpace (Mâ‚' i)\ninstâœâµ : TopologicalSpace Mâ‚‚\ninstâœâ´ : TopologicalSpace Mâ‚ƒ\ninstâœÂ³ : TopologicalSpace Mâ‚„\nf f' : ContinuousMultilinearMap R Mâ‚ Mâ‚‚\ninstâœÂ² : ContinuousAdd Mâ‚‚\ninstâœÂ¹ : DecidableEq Î¹\ninstâœ : Fintype Î¹\nx y : (i : Î¹) â†’ Mâ‚ i\nâŠ¢ (f.linearDeriv x) y = âˆ‘ i : Î¹, f (update x i (y i))"
    },
    {
      "name": "ContinuousMultilinearMap.norm_mkPiAlgebra",
      "statement": "ğ•œ : Type u\nÎ¹ : Type v\nÎ¹' : Type v'\nE : Î¹ â†’ Type wE\nEâ‚ : Î¹ â†’ Type wEâ‚\nE' : Î¹' â†’ Type wE'\nG : Type wG\nG' : Type wG'\ninstâœÂ¹âµ : Fintype Î¹\ninstâœÂ¹â´ : Fintype Î¹'\ninstâœÂ¹Â³ : NontriviallyNormedField ğ•œ\ninstâœÂ¹Â² : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ¹Â¹ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ¹â° : (i : Î¹) â†’ SeminormedAddCommGroup (Eâ‚ i)\ninstâœâ¹ : (i : Î¹) â†’ NormedSpace ğ•œ (Eâ‚ i)\ninstâœâ¸ : (i : Î¹') â†’ SeminormedAddCommGroup (E' i)\ninstâœâ· : (i : Î¹') â†’ NormedSpace ğ•œ (E' i)\ninstâœâ¶ : SeminormedAddCommGroup G\ninstâœâµ : NormedSpace ğ•œ G\ninstâœâ´ : SeminormedAddCommGroup G'\ninstâœÂ³ : NormedSpace ğ•œ G'\nA : Type u_1\ninstâœÂ² : NormedCommRing A\ninstâœÂ¹ : NormedAlgebra ğ•œ A\ninstâœ : NormOneClass A\nâŠ¢ â€–ContinuousMultilinearMap.mkPiAlgebra ğ•œ Î¹ Aâ€– = 1"
    },
    {
      "name": "ContinuousMultilinearMap.norm_mkPiAlgebraFin",
      "statement": "ğ•œ : Type u\nÎ¹ : Type v\nÎ¹' : Type v'\nE : Î¹ â†’ Type wE\nEâ‚ : Î¹ â†’ Type wEâ‚\nE' : Î¹' â†’ Type wE'\nG : Type wG\nG' : Type wG'\ninstâœÂ¹âµ : Fintype Î¹\ninstâœÂ¹â´ : Fintype Î¹'\ninstâœÂ¹Â³ : NontriviallyNormedField ğ•œ\ninstâœÂ¹Â² : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ¹Â¹ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ninstâœÂ¹â° : (i : Î¹) â†’ SeminormedAddCommGroup (Eâ‚ i)\ninstâœâ¹ : (i : Î¹) â†’ NormedSpace ğ•œ (Eâ‚ i)\ninstâœâ¸ : (i : Î¹') â†’ SeminormedAddCommGroup (E' i)\ninstâœâ· : (i : Î¹') â†’ NormedSpace ğ•œ (E' i)\ninstâœâ¶ : SeminormedAddCommGroup G\ninstâœâµ : NormedSpace ğ•œ G\ninstâœâ´ : SeminormedAddCommGroup G'\ninstâœÂ³ : NormedSpace ğ•œ G'\nn : â„•\nA : Type u_1\ninstâœÂ² : NormedRing A\ninstâœÂ¹ : NormedAlgebra ğ•œ A\ninstâœ : NormOneClass A\nâŠ¢ â€–ContinuousMultilinearMap.mkPiAlgebraFin ğ•œ n Aâ€– = 1"
    },
    {
      "name": "ContinuousOn.aemeasurable",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nE : Type u_3\nF : Type u_4\ninstâœâ¶ : MeasurableSpace Î±\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : TopologicalSpace Î±\ninstâœÂ³ : OpensMeasurableSpace Î±\ninstâœÂ² : MeasurableSpace Î²\ninstâœÂ¹ : TopologicalSpace Î²\ninstâœ : BorelSpace Î²\nf : Î± â†’ Î²\ns : Set Î±\nÎ¼ : Measure Î±\nhf : ContinuousOn f s\nhs : MeasurableSet s\nâŠ¢ AEMeasurable f (Î¼.restrict s)"
    },
    {
      "name": "Convex.translate_preimage_right",
      "statement": "ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nÎ² : Type u_4\ninstâœâ´ : OrderedSemiring ğ•œ\ninstâœÂ³ : AddCommMonoid E\ninstâœÂ² : AddCommMonoid F\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œ F\ns : Set E\nx : E\nhs : Convex ğ•œ s\nz : E\nâŠ¢ Convex ğ•œ ((fun x => z + x) â»Â¹' s)"
    },
    {
      "name": "CoxeterSystem.length_simple",
      "statement": "B : Type u_1\nW : Type u_2\ninstâœ : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\ni : B\nâŠ¢ cs.length (cs.simple i) = 1"
    },
    {
      "name": "CoxeterSystem.simple_mul_simple_cancel_left",
      "statement": "B : Type u_1\nB' : Type u_2\ne : B â‰ƒ B'\nW : Type u_3\nH : Type u_4\ninstâœÂ¹ : Group W\ninstâœ : Group H\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw : W\ni : B\nâŠ¢ cs.simple i * (cs.simple i * w) = w"
    },
    {
      "name": "CoxeterSystem.simple_mul_simple_pow",
      "statement": "B : Type u_1\nB' : Type u_2\ne : B â‰ƒ B'\nW : Type u_3\nH : Type u_4\ninstâœÂ¹ : Group W\ninstâœ : Group H\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\ni i' : B\nâŠ¢ (cs.simple i * cs.simple i') ^ M.M i i' = 1"
    },
    {
      "name": "Cycle.chain_singleton",
      "statement": "Î± : Type u_1\nr : Î± â†’ Î± â†’ Prop\na : Î±\nâŠ¢ Chain r â†‘[a] â†” r a a"
    },
    {
      "name": "Cycle.map_eq_nil",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ns : Cycle Î±\nâŠ¢ âˆ€ (a : List Î±), map f (Quotient.mk'' a) = nil â†” Quotient.mk'' a = nil"
    },
    {
      "name": "Cycle.toFinset_eq_nil",
      "statement": "Î± : Type u_1\ninstâœ : DecidableEq Î±\ns : Cycle Î±\nâŠ¢ âˆ€ (a : List Î±), toFinset (Quotient.mk'' a) = âˆ… â†” Quotient.mk'' a = nil"
    },
    {
      "name": "Cycle.toMultiset_eq_nil",
      "statement": "Î± : Type u_1\ns : Cycle Î±\nâŠ¢ âˆ€ (a : List Î±), toMultiset (Quotient.mk'' a) = 0 â†” Quotient.mk'' a = nil"
    },
    {
      "name": "DFA.toNFA_evalFrom_match",
      "statement": "Î± : Type u\nÏƒ Ïƒ' : Type v\nMâœ : NFA Î± Ïƒ\nM : DFA Î± Ïƒ\nstart : Ïƒ\ns : List Î±\nâŠ¢ M.toNFA.evalFrom {start} s = {M.evalFrom start s}"
    },
    {
      "name": "DFinsupp.card_pi",
      "statement": "Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u_2\ninstâœÂ² : (i : Î¹) â†’ Zero (Î± i)\ninstâœÂ¹ : DecidableEq Î¹\ninstâœ : (i : Î¹) â†’ DecidableEq (Î± i)\nf : Î â‚€ (i : Î¹), Finset (Î± i)\nâŠ¢ f.pi.card = f.prod fun i => â†‘(f i).card"
    },
    {
      "name": "DFinsupp.comapDomain_single",
      "statement": "Î¹ : Type u\nÎ³ : Type w\nÎ² : Î¹ â†’ Type v\nÎ²â‚ : Î¹ â†’ Type vâ‚\nÎ²â‚‚ : Î¹ â†’ Type vâ‚‚\ninstâœÂ² : DecidableEq Î¹\nÎº : Type u_1\ninstâœÂ¹ : DecidableEq Îº\ninstâœ : (i : Î¹) â†’ Zero (Î² i)\nh : Îº â†’ Î¹\nhh : Function.Injective h\nk : Îº\nx : Î² (h k)\nâŠ¢ comapDomain h hh (single (h k) x) = single k x"
    },
    {
      "name": "DFinsupp.comapDomain_smul",
      "statement": "Î¹ : Type u\nÎ³ : Type w\nÎ² : Î¹ â†’ Type v\nÎ²â‚ : Î¹ â†’ Type vâ‚\nÎ²â‚‚ : Î¹ â†’ Type vâ‚‚\ninstâœÂ³ : DecidableEq Î¹\nÎº : Type u_1\ninstâœÂ² : Monoid Î³\ninstâœÂ¹ : (i : Î¹) â†’ AddMonoid (Î² i)\ninstâœ : (i : Î¹) â†’ DistribMulAction Î³ (Î² i)\nh : Îº â†’ Î¹\nhh : Function.Injective h\nr : Î³\nf : Î â‚€ (i : Î¹), Î² i\nâŠ¢ comapDomain h hh (r â€¢ f) = r â€¢ comapDomain h hh f"
    },
    {
      "name": "DFinsupp.equivFunOnFintype_single",
      "statement": "Î¹ : Type u\nÎ³ : Type w\nÎ² : Î¹ â†’ Type v\nÎ²â‚ : Î¹ â†’ Type vâ‚\nÎ²â‚‚ : Î¹ â†’ Type vâ‚‚\ninstâœÂ² : DecidableEq Î¹\ninstâœÂ¹ : (i : Î¹) â†’ Zero (Î² i)\ns : Finset Î¹\nx : (i : â†‘â†‘s) â†’ Î² â†‘i\niâœ : Î¹\ninstâœ : Fintype Î¹\ni : Î¹\nm : Î² i\nâŠ¢ equivFunOnFintype (single i m) = Pi.single i m"
    },
    {
      "name": "DFinsupp.extendWith_zero",
      "statement": "Î¹ : Type u\nÎ³ : Type w\nÎ² : Î¹ â†’ Type v\nÎ²â‚ : Î¹ â†’ Type vâ‚\nÎ²â‚‚ : Î¹ â†’ Type vâ‚‚\ninstâœÂ² : DecidableEq Î¹\nÎº : Type u_1\nÎ± : Option Î¹ â†’ Type v\ninstâœÂ¹ : DecidableEq Î¹\ninstâœ : (i : Option Î¹) â†’ Zero (Î± i)\nx : Î± none\nâŠ¢ extendWith x 0 = single none x"
    },
    {
      "name": "DFinsupp.neLocus_self_sub_right",
      "statement": "Î± : Type u_1\nN : Î± â†’ Type u_2\ninstâœÂ² : DecidableEq Î±\ninstâœÂ¹ : (a : Î±) â†’ DecidableEq (N a)\ninstâœ : (a : Î±) â†’ AddGroup (N a)\nf fâ‚ fâ‚‚ g gâ‚ gâ‚‚ : Î â‚€ (a : Î±), N a\nâŠ¢ f.neLocus (f - g) = g.support"
    },
    {
      "name": "DFinsupp.neLocus_zero_right",
      "statement": "Î± : Type u_1\nN : Î± â†’ Type u_2\ninstâœÂ² : DecidableEq Î±\ninstâœÂ¹ : (a : Î±) â†’ DecidableEq (N a)\ninstâœ : (a : Î±) â†’ Zero (N a)\nf g : Î â‚€ (a : Î±), N a\nâŠ¢ f.neLocus 0 = f.support"
    },
    {
      "name": "DFinsupp.single_smul",
      "statement": "Î¹ : Type u\nÎ³ : Type w\nÎ² : Î¹ â†’ Type v\nÎ²â‚ : Î¹ â†’ Type vâ‚\nÎ²â‚‚ : Î¹ â†’ Type vâ‚‚\ninstâœÂ³ : DecidableEq Î¹\ninstâœÂ² : Monoid Î³\ninstâœÂ¹ : (i : Î¹) â†’ AddMonoid (Î² i)\ninstâœ : (i : Î¹) â†’ DistribMulAction Î³ (Î² i)\niâœ : Î¹\nc : Î³\nx : Î² iâœ\ni : Î¹\nâŠ¢ (single iâœ (c â€¢ x)) i = (c â€¢ single iâœ x) i"
    },
    {
      "name": "DFinsupp.support_filter",
      "statement": "Î¹ : Type u\nÎ³ : Type w\nÎ² : Î¹ â†’ Type v\nÎ²â‚ : Î¹ â†’ Type vâ‚\nÎ²â‚‚ : Î¹ â†’ Type vâ‚‚\ninstâœÂ³ : DecidableEq Î¹\ninstâœÂ² : (i : Î¹) â†’ Zero (Î² i)\ninstâœÂ¹ : (i : Î¹) â†’ (x : Î² i) â†’ Decidable (x â‰  0)\np : Î¹ â†’ Prop\ninstâœ : DecidablePred p\nf : Î â‚€ (i : Î¹), Î² i\nâŠ¢ (filter p f).support = Finset.filter p f.support"
    },
    {
      "name": "DFinsupp.toFinsupp_single",
      "statement": "Î¹ : Type u_1\nR : Type u_2\nM : Type u_3\ninstâœÂ² : DecidableEq Î¹\ninstâœÂ¹ : Zero M\ninstâœ : (m : M) â†’ Decidable (m â‰  0)\ni : Î¹\nm : M\nâŠ¢ (single i m).toFinsupp = Finsupp.single i m"
    },
    {
      "name": "DFinsupp.toMultiset_inf",
      "statement": "Î± : Type u_1\nÎ² : Î± â†’ Type u_2\ninstâœ : DecidableEq Î±\nf g : Î â‚€ (_a : Î±), â„•\nâŠ¢ Multiset.toDFinsupp (toMultiset (f âŠ“ g)) = Multiset.toDFinsupp (toMultiset f âˆ© toMultiset g)"
    },
    {
      "name": "DFinsupp.toMultiset_le_toMultiset",
      "statement": "Î± : Type u_1\nÎ² : Î± â†’ Type u_2\ninstâœ : DecidableEq Î±\nf g : Î â‚€ (_a : Î±), â„•\nâŠ¢ toMultiset f â‰¤ toMultiset g â†” f â‰¤ g"
    },
    {
      "name": "DFinsupp.toMultiset_lt_toMultiset",
      "statement": "Î± : Type u_1\nÎ² : Î± â†’ Type u_2\ninstâœ : DecidableEq Î±\nf g : Î â‚€ (_a : Î±), â„•\nâŠ¢ toMultiset f < toMultiset g â†” f < g"
    },
    {
      "name": "DFinsupp.update_eq_erase",
      "statement": "Î¹ : Type u\nÎ³ : Type w\nÎ² : Î¹ â†’ Type v\nÎ²â‚ : Î¹ â†’ Type vâ‚\nÎ²â‚‚ : Î¹ â†’ Type vâ‚‚\ninstâœÂ¹ : DecidableEq Î¹\ninstâœ : (i : Î¹) â†’ Zero (Î² i)\ns : Finset Î¹\nx : (i : â†‘â†‘s) â†’ Î² â†‘i\ni : Î¹\nf : Î â‚€ (i : Î¹), Î² i\nb : Î² i\nj : Î¹\nâŠ¢ update i f 0 = erase i f"
    },
    {
      "name": "DMatrix.map_map",
      "statement": "l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nÎ± : m â†’ n â†’ Type v\nM : DMatrix m n Î±\nÎ² : m â†’ n â†’ Type w\nÎ³ : m â†’ n â†’ Type z\nf : â¦ƒi : mâ¦„ â†’ â¦ƒj : nâ¦„ â†’ Î± i j â†’ Î² i j\ng : â¦ƒi : mâ¦„ â†’ â¦ƒj : nâ¦„ â†’ Î² i j â†’ Î³ i j\nâŠ¢ (M.map f).map g = M.map fun i j x => g (f x)"
    },
    {
      "name": "Denumerable.sigma_ofNat_val",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : Denumerable Î±\ninstâœÂ¹ : Denumerable Î²\nÎ³ : Î± â†’ Type u_3\ninstâœ : (a : Î±) â†’ Denumerable (Î³ a)\nn : â„•\nâŠ¢ some (ofNat (Sigma Î³) n) = some âŸ¨ofNat Î± (unpair n).1, ofNat (Î³ (ofNat Î± (unpair n).1)) (unpair n).2âŸ©"
    },
    {
      "name": "Derivation.map_natCast",
      "statement": "R : Type u_1\nA : Type u_2\nB : Type u_3\nM : Type u_4\ninstâœâ¸ : CommSemiring R\ninstâœâ· : CommSemiring A\ninstâœâ¶ : CommSemiring B\ninstâœâµ : AddCommMonoid M\ninstâœâ´ : Algebra R A\ninstâœÂ³ : Algebra R B\ninstâœÂ² : Module A M\ninstâœÂ¹ : Module B M\ninstâœ : Module R M\nD D1 D2 : Derivation R A M\nr : R\na b : A\nn : â„•\nâŠ¢ D â†‘n = 0"
    },
    {
      "name": "DihedralGroup.orderOf_sr",
      "statement": "n : â„•\ni : ZMod n\nâŠ¢ orderOf (sr i) = 2"
    },
    {
      "name": "Dilation.dist_eq",
      "statement": "Î±âœ : Type u_1\nÎ²âœ : Type u_2\nÎ³ : Type u_3\nFâœ : Type u_4\nG : Type u_5\ninstâœâ¶ : PseudoEMetricSpace Î±âœ\ninstâœâµ : PseudoEMetricSpace Î²âœ\ninstâœâ´ : FunLike Fâœ Î±âœ Î²âœ\nÎ± : Type u_6\nÎ² : Type u_7\nF : Type u_8\ninstâœÂ³ : PseudoMetricSpace Î±\ninstâœÂ² : PseudoMetricSpace Î²\ninstâœÂ¹ : FunLike F Î± Î²\ninstâœ : DilationClass F Î± Î²\nf : F\nx y : Î±\nâŠ¢ dist (f x) (f y) = â†‘(ratio f) * dist x y"
    },
    {
      "name": "DilationEquiv.ratio_trans",
      "statement": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninstâœÂ² : PseudoEMetricSpace X\ninstâœÂ¹ : PseudoEMetricSpace Y\ninstâœ : PseudoEMetricSpace Z\ne : X â‰ƒáµˆ Y\ne' : Y â‰ƒáµˆ Z\nâŠ¢ ratio (e.trans e') = ratio e * ratio e'"
    },
    {
      "name": "DirectSum.IsInternal.collectedBasis_coe",
      "statement": "R : Type u\ninstâœÂ² : Semiring R\nÎ¹ : Type v\ndec_Î¹ : DecidableEq Î¹\nM : Type u_1\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : Module R M\nA : Î¹ â†’ Submodule R M\nh : IsInternal A\nÎ± : Î¹ â†’ Type u_2\nv : (i : Î¹) â†’ Basis (Î± i) R â†¥(A i)\nâŠ¢ â‡‘(h.collectedBasis v) = fun a => â†‘((v a.fst) a.snd)"
    },
    {
      "name": "DirectSum.coeAlgHom_of",
      "statement": "Î¹ : Type u_1\nÏƒ : Type u_2\nS : Type u_3\nR : Type u_4\ninstâœâµ : DecidableEq Î¹\ninstâœâ´ : AddMonoid Î¹\ninstâœÂ³ : CommSemiring S\ninstâœÂ² : Semiring R\ninstâœÂ¹ : Algebra S R\nA : Î¹ â†’ Submodule S R\ninstâœ : SetLike.GradedMonoid A\ni : Î¹\nx : â†¥(A i)\nâŠ¢ ((fun i => (A i).subtype) 0).toAddMonoidHom GradedMonoid.GOne.one = 1"
    },
    {
      "name": "DirectSum.equivCongrLeft_apply",
      "statement": "Î¹ : Type v\ndec_Î¹ : DecidableEq Î¹\nÎ² : Î¹ â†’ Type w\ninstâœÂ¹ : (i : Î¹) â†’ AddCommMonoid (Î² i)\nÎ³ : Type uâ‚\ninstâœ : AddCommMonoid Î³\nÎº : Type u_1\nh : Î¹ â‰ƒ Îº\nf : â¨ (i : Î¹), Î² i\nk : Îº\nâŠ¢ ((equivCongrLeft h) f) k = f (h.symm k)"
    },
    {
      "name": "DirectSum.lie_of",
      "statement": "R : Type u\nÎ¹ : Type v\ninstâœÂ³ : CommRing R\nL : Î¹ â†’ Type w\ninstâœÂ² : (i : Î¹) â†’ LieRing (L i)\ninstâœÂ¹ : (i : Î¹) â†’ LieAlgebra R (L i)\ninstâœ : DecidableEq Î¹\ni j : Î¹\nx : L i\ny : L j\nâŠ¢ â…(of L i) x, (of L j) yâ† = if hij : i = j then (of L i) â…x, Eq.recOn â‹¯ yâ† else 0"
    },
    {
      "name": "DoubleQuot.quotQuotEquivComm_symmâ‚",
      "statement": "R : Type u\nA : Type u_1\ninstâœÂ² : CommSemiring R\ninstâœÂ¹ : CommRing A\ninstâœ : Algebra R A\nI J : Ideal A\nâŠ¢ (quotQuotEquivCommâ‚ R I J).symm = quotQuotEquivCommâ‚ R J I"
    },
    {
      "name": "DvdNotUnit.ne",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\ninstâœ : CancelCommMonoidWithZero Î±\np q : Î±\nh : DvdNotUnit p q\nâŠ¢ p â‰  q"
    },
    {
      "name": "EMetric.diam_closure",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœ : PseudoEMetricSpace Î±\ns : Set Î±\nâŠ¢ diam (closure s) = diam s"
    },
    {
      "name": "EMetric.hausdorffEdist_closureâ‚",
      "statement": "Î¹ : Sort u_1\nÎ± : Type u\nÎ² : Type v\ninstâœÂ¹ : PseudoEMetricSpace Î±\ninstâœ : PseudoEMetricSpace Î²\nx y : Î±\ns t u : Set Î±\nÎ¦ : Î± â†’ Î²\nâŠ¢ hausdorffEdist (closure s) t = hausdorffEdist s t"
    },
    {
      "name": "ENNReal.add_rpow_le_rpow_add",
      "statement": "Î¹ : Type u\ns : Finset Î¹\np : â„\na b : â„â‰¥0âˆ\nhp1 : 1 â‰¤ p\nâŠ¢ a ^ p + b ^ p â‰¤ (a + b) ^ p"
    },
    {
      "name": "ENNReal.coe_zpow",
      "statement": "a b c d : â„â‰¥0âˆ\nr p q : â„â‰¥0\nhr : r â‰  0\nn : â„¤\nâŠ¢ â†‘(r ^ n) = â†‘r ^ n"
    },
    {
      "name": "ENNReal.inv_strictAnti",
      "statement": "a b c d : â„â‰¥0âˆ\nr p q : â„â‰¥0\nâŠ¢ StrictAnti Inv.inv"
    },
    {
      "name": "ENNReal.rpow_eq_zero_iff",
      "statement": "x : â„â‰¥0âˆ\ny : â„\nâŠ¢ x ^ y = 0 â†” x = 0 âˆ§ 0 < y âˆ¨ x = âŠ¤ âˆ§ y < 0"
    },
    {
      "name": "ENNReal.rpow_one",
      "statement": "x : â„â‰¥0âˆ\nâŠ¢ x ^ 1 = x"
    },
    {
      "name": "ENNReal.toReal_le_toReal",
      "statement": "a b c d : â„â‰¥0âˆ\nr p q : â„â‰¥0\nha : a â‰  âŠ¤\nhb : b â‰  âŠ¤\nâŠ¢ a.toReal â‰¤ b.toReal â†” a â‰¤ b"
    },
    {
      "name": "ENNReal.toReal_mul_top",
      "statement": "aâœ b c d : â„â‰¥0âˆ\nr p q : â„â‰¥0\na : â„â‰¥0âˆ\nâŠ¢ (a * âŠ¤).toReal = 0"
    },
    {
      "name": "ENNReal.toReal_sub_of_le",
      "statement": "aâœ bâœ c d : â„â‰¥0âˆ\nr p q : â„â‰¥0\na b : â„â‰¥0âˆ\nh : b â‰¤ a\nha : a â‰  âŠ¤\nâŠ¢ (a - b).toReal = a.toReal - b.toReal"
    },
    {
      "name": "ENNReal.zero_rpow_mul_self",
      "statement": "y : â„\nâŠ¢ 0 ^ y * 0 ^ y = 0 ^ y"
    },
    {
      "name": "EReal.abs_mul",
      "statement": "x y : EReal\nâŠ¢ (x * y).abs = x.abs * y.abs"
    },
    {
      "name": "EReal.bot_lt_add_iff",
      "statement": "x y : EReal\nâŠ¢ âŠ¥ < x + y â†” âŠ¥ < x âˆ§ âŠ¥ < y"
    },
    {
      "name": "EReal.coe_ennreal_eq_one",
      "statement": "x : â„â‰¥0âˆ\nâŠ¢ â†‘x = 1 â†” x = 1"
    },
    {
      "name": "EReal.coe_ennreal_pos",
      "statement": "x : â„â‰¥0âˆ\nâŠ¢ 0 < â†‘x â†” 0 < x"
    },
    {
      "name": "EReal.image_coe_Ico",
      "statement": "x y : â„\nâŠ¢ Real.toEReal '' Ico x y = Ico â†‘x â†‘y"
    },
    {
      "name": "EReal.image_coe_Iio",
      "statement": "x : â„\nâŠ¢ Real.toEReal '' Iio x = Ioo âŠ¥ â†‘x"
    },
    {
      "name": "EReal.image_coe_Ioi",
      "statement": "x : â„\nâŠ¢ Real.toEReal '' Ioi x = Ioo â†‘x âŠ¤"
    },
    {
      "name": "EReal.neg_mul",
      "statement": "x y : EReal\nâŠ¢ -x * y = -(x * y)"
    },
    {
      "name": "EReal.preimage_coe_Iio",
      "statement": "y : â„\nâŠ¢ Real.toEReal â»Â¹' Iio â†‘y = Iio y"
    },
    {
      "name": "EReal.sign_mul",
      "statement": "x y : EReal\nâŠ¢ sign (x * y) = sign x * sign y"
    },
    {
      "name": "EqualCharZero.pnatCast_one",
      "statement": "R : Type u_1\ninstâœÂ¹ : CommRing R\ninstâœ : Fact (âˆ€ (I : Ideal R), I â‰  âŠ¤ â†’ CharZero (R â§¸ I))\nâŠ¢ â†‘1 = 1"
    },
    {
      "name": "Equiv.Perm.card_cycleType_eq_zero",
      "statement": "Î± : Type u_1\ninstâœÂ¹ : Fintype Î±\ninstâœ : DecidableEq Î±\nÏƒ : Perm Î±\nâŠ¢ card Ïƒ.cycleType = 0 â†” Ïƒ = 1"
    },
    {
      "name": "Equiv.Perm.card_support_eq_zero",
      "statement": "Î± : Type u_1\ninstâœÂ¹ : DecidableEq Î±\ninstâœ : Fintype Î±\nfâœ g f : Perm Î±\nâŠ¢ f.support.card = 0 â†” f = 1"
    },
    {
      "name": "Equiv.Perm.cycleOf_apply_apply_zpow_self",
      "statement": "Î¹ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nfâœ g : Perm Î±\nxâœ y : Î±\ninstâœÂ² : DecidableRel fâœ.SameCycle\ninstâœÂ¹ : DecidableRel g.SameCycle\nf : Perm Î±\ninstâœ : DecidableRel f.SameCycle\nx : Î±\nk : â„¤\nâŠ¢ (f.cycleOf x) ((f ^ k) x) = (f ^ (k + 1)) x"
    },
    {
      "name": "Equiv.Perm.decomposeFin_symm_apply_succ",
      "statement": "n : â„•\ne : Perm (Fin n)\np : Fin (n + 1)\nx : Fin n\nâŠ¢ (decomposeFin.symm (p, e)) x.succ = (swap 0 p) (e x).succ"
    },
    {
      "name": "Equiv.Perm.disjoint_inv_left_iff",
      "statement": "Î± : Type u_1\nf g h : Perm Î±\nâŠ¢ fâ»Â¹.Disjoint g â†” f.Disjoint g"
    },
    {
      "name": "Equiv.Perm.disjoint_refl_iff",
      "statement": "Î± : Type u_1\nf g h : Perm Î±\nâŠ¢ f.Disjoint f â†” f = 1"
    },
    {
      "name": "Equiv.Perm.sign_prodExtendRight",
      "statement": "Î± : Type u\ninstâœÂ³ : DecidableEq Î±\nÎ² : Type v\ninstâœÂ² : Fintype Î±\ninstâœÂ¹ : DecidableEq Î²\ninstâœ : Fintype Î²\na : Î±\nÏƒ : Perm Î²\nxâœÂ¹ : Î± Ã— Î²\na' : Î±\nb : Î²\nhab : (prodExtendRight a Ïƒ) (a', b) â‰  (a', b)\nxâœ : (prodExtendRight a Ïƒ) ((prodExtendRight a Ïƒ) (a', b)) â‰  (prodExtendRight a Ïƒ) (a', b)\nâŠ¢ (fun ab x => ab.2) ((prodExtendRight a Ïƒ) (a', b)) xâœ = Ïƒ ((fun ab x => ab.2) (a', b) hab)"
    },
    {
      "name": "Equiv.Perm.support_cycleOf_eq_nil_iff",
      "statement": "Î¹ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nf g : Perm Î±\nx y : Î±\ninstâœÂ³ : DecidableRel f.SameCycle\ninstâœÂ² : DecidableRel g.SameCycle\ninstâœÂ¹ : DecidableEq Î±\ninstâœ : Fintype Î±\nâŠ¢ (f.cycleOf x).support = âˆ… â†” x âˆ‰ f.support"
    },
    {
      "name": "Equiv.Perm.toList_formPerm_nil",
      "statement": "Î± : Type u_1\ninstâœÂ¹ : Fintype Î±\ninstâœ : DecidableEq Î±\np : Perm Î±\nxâœ x : Î±\nâŠ¢ [].formPerm.toList x = []"
    },
    {
      "name": "Equiv.algebraMap_def",
      "statement": "Î± : Type u\nÎ² : Type v\neâœ : Î± â‰ƒ Î²\nR : Type u_1\ninstâœÂ² : CommSemiring R\ne : Î± â‰ƒ Î²\ninstâœÂ¹ : Semiring Î²\ninstâœ : Algebra R Î²\nr : R\nâŠ¢ let semiring := e.semiring;\n  let algebra := Equiv.algebra R e;\n  (algebraMap R Î±) r = e.symm ((algebraMap R Î²) r)"
    },
    {
      "name": "Equiv.left_vsub_pointReflection",
      "statement": "G : Type u_1\nP : Type u_2\ninstâœÂ¹ : AddGroup G\ninstâœ : AddTorsor G P\nx y : P\nâŠ¢ -(x -áµ¥ (pointReflection x) y) = -(y -áµ¥ x)"
    },
    {
      "name": "Equiv.piCongr'_symm_apply_symm_apply",
      "statement": "Î± : Sort u_1\nÎ² : Sort u_2\nW : Î± â†’ Sort w\nZ : Î² â†’ Sort z\nhâ‚ : Î± â‰ƒ Î²\nhâ‚‚ : (b : Î²) â†’ W (hâ‚.symm b) â‰ƒ Z b\nf : (b : Î²) â†’ Z b\nb : Î²\nâŠ¢ (hâ‚.piCongr' hâ‚‚).symm f (hâ‚.symm b) = (hâ‚‚ b).symm (f b)"
    },
    {
      "name": "Equiv.swap_smul_self_smul",
      "statement": "Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : DecidableEq Î±\ninstâœ : MulAction (Perm Î±) Î²\ni j : Î±\nx : Î²\nâŠ¢ swap i j â€¢ swap i j â€¢ x = x"
    },
    {
      "name": "Equiv.toFun_inducedStructureEquiv_Symm",
      "statement": "L : Language\nM : Type u_1\nN : Type u_2\ninstâœ : L.Structure M\ne : M â‰ƒ N\nâŠ¢ N â†’ M"
    },
    {
      "name": "Erased.out_mk",
      "statement": "Î± : Sort u_1\na : Î±\nâŠ¢ (mk a).out = a"
    },
    {
      "name": "EuclideanDomain.gcdB_zero_left",
      "statement": "R : Type u\ninstâœÂ¹ : EuclideanDomain R\ninstâœ : DecidableEq R\ns : R\nâŠ¢ gcdB 0 s = 1"
    },
    {
      "name": "EuclideanDomain.gcd_mul_lcm",
      "statement": "R : Type u\ninstâœÂ¹ : EuclideanDomain R\ninstâœ : DecidableEq R\nx y : R\nâŠ¢ gcd x y * lcm x y = x * y"
    },
    {
      "name": "EuclideanDomain.lcm_zero_right",
      "statement": "R : Type u\ninstâœÂ¹ : EuclideanDomain R\ninstâœ : DecidableEq R\nx : R\nâŠ¢ lcm x 0 = 0"
    },
    {
      "name": "EuclideanDomain.mod_eq_zero",
      "statement": "R : Type u\ninstâœ : EuclideanDomain R\na b : R\nh : a % b = 0\nâŠ¢ b âˆ£ a"
    },
    {
      "name": "EuclideanDomain.xgcdAux_fst",
      "statement": "R : Type u\ninstâœÂ¹ : EuclideanDomain R\ninstâœ : DecidableEq R\nx y : R\nâŠ¢ âˆ€ (x s t s' t' : R), (xgcdAux 0 s t x s' t').1 = gcd 0 x"
    },
    {
      "name": "EuclideanGeometry.Sphere.secondInter_mem",
      "statement": "V : Type u_1\nP : Type u_2\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : InnerProductSpace â„ V\ninstâœÂ¹ : MetricSpace P\ninstâœ : NormedAddTorsor V P\ns : Sphere P\np : P\nv : V\nâŠ¢ s.secondInter p v âˆˆ s â†” p âˆˆ s"
    },
    {
      "name": "EuclideanGeometry.inversion_dist_center'",
      "statement": "V : Type u_1\nP : Type u_2\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : InnerProductSpace â„ V\ninstâœÂ¹ : MetricSpace P\ninstâœ : NormedAddTorsor V P\na b câœ d xâœ y z : P\nr R : â„\nc x : P\nâŠ¢ inversion c (dist c x) x = x"
    },
    {
      "name": "EuclideanGeometry.orthogonalProjection_mem_subspace_eq_self",
      "statement": "V : Type u_1\nP : Type u_2\ninstâœâµ : NormedAddCommGroup V\ninstâœâ´ : InnerProductSpace â„ V\ninstâœÂ³ : MetricSpace P\ninstâœÂ² : NormedAddTorsor V P\ns : AffineSubspace â„ P\ninstâœÂ¹ : Nonempty â†¥s\ninstâœ : HasOrthogonalProjection s.direction\np : â†¥s\nâŠ¢ (orthogonalProjection s) â†‘p = p"
    },
    {
      "name": "EuclideanGeometry.orthogonalProjection_orthogonalProjection",
      "statement": "V : Type u_1\nP : Type u_2\ninstâœâµ : NormedAddCommGroup V\ninstâœâ´ : InnerProductSpace â„ V\ninstâœÂ³ : MetricSpace P\ninstâœÂ² : NormedAddTorsor V P\ns : AffineSubspace â„ P\ninstâœÂ¹ : Nonempty â†¥s\ninstâœ : HasOrthogonalProjection s.direction\np : P\nâŠ¢ (orthogonalProjection s) â†‘((orthogonalProjection s) p) = (orthogonalProjection s) p"
    },
    {
      "name": "EuclideanGeometry.reflection_reflection",
      "statement": "V : Type u_1\nP : Type u_2\ninstâœâµ : NormedAddCommGroup V\ninstâœâ´ : InnerProductSpace â„ V\ninstâœÂ³ : MetricSpace P\ninstâœÂ² : NormedAddTorsor V P\ns : AffineSubspace â„ P\ninstâœÂ¹ : Nonempty â†¥s\ninstâœ : HasOrthogonalProjection s.direction\np : P\nâŠ¢ (reflection s) ((reflection s) p) = p"
    },
    {
      "name": "Even.isSquare_zpow",
      "statement": "F : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nR : Type u_4\ninstâœ : Group Î±\nn : â„¤\nâŠ¢ Even n â†’ âˆ€ (a : Î±), IsSquare (a ^ n)"
    },
    {
      "name": "ExteriorAlgebra.liftAlternating_Î¹",
      "statement": "R : Type u_1\nM : Type u_2\nN : Type u_3\nN' : Type u_4\ninstâœâ¶ : CommRing R\ninstâœâµ : AddCommGroup M\ninstâœâ´ : AddCommGroup N\ninstâœÂ³ : AddCommGroup N'\ninstâœÂ² : Module R M\ninstâœÂ¹ : Module R N\ninstâœ : Module R N'\nf : (i : â„•) â†’ M [â‹€^Fin i]â†’â‚—[R] N\nm : M\nâŠ¢ (liftAlternating f) ((Î¹ R) m) = (f 1) ![m]"
    },
    {
      "name": "ExteriorAlgebra.Î¹_ne_one",
      "statement": "R : Type u1\ninstâœâµ : CommRing R\nM : Type u2\ninstâœâ´ : AddCommGroup M\ninstâœÂ³ : Module R M\nA : Type u_1\ninstâœÂ² : Semiring A\ninstâœÂ¹ : Algebra R A\ninstâœ : Nontrivial R\nx : M\nâŠ¢ (Î¹ R) x â‰  1"
    },
    {
      "name": "Filter.Germ.max_def",
      "statement": "Î± : Type u\nÎ² : Type v\nÏ† : Ultrafilter Î±\ninstâœ : LinearOrder Î²\nx y : (â†‘Ï†).Germ Î²\na b : Î± â†’ Î²\nâŠ¢ max â†‘a â†‘b = mapâ‚‚ max â†‘a â†‘b"
    },
    {
      "name": "Filter.Germ.min_def",
      "statement": "Î± : Type u\nÎ² : Type v\nÏ† : Ultrafilter Î±\nK : LinearOrder Î²\nx y : (â†‘Ï†).Germ Î²\na b : Î± â†’ Î²\nâŠ¢ min â†‘a â†‘b = mapâ‚‚ min â†‘a â†‘b"
    },
    {
      "name": "Filter.biInter_mem",
      "statement": "Î± : Type u\nf g : Filter Î±\nsâœ t : Set Î±\nÎ² : Type v\ns : Î² â†’ Set Î±\nis : Set Î²\nhf : is.Finite\nâŠ¢ â‹‚ i âˆˆ âˆ…, s i âˆˆ f â†” âˆ€ i âˆˆ âˆ…, s i âˆˆ f"
    },
    {
      "name": "Filter.blimsup_false",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ¹ : Type u_4\nÎ¹' : Type u_5\ninstâœ : CompleteLattice Î±\nf : Filter Î²\nu : Î² â†’ Î±\nâŠ¢ (blimsup u f fun x => False) = âŠ¥"
    },
    {
      "name": "Filter.closure_singleton",
      "statement": "Î¹ : Sort u_1\nÎ± : Type u_2\nÎ² : Type u_3\nX : Type u_4\nY : Type u_5\nl : Filter Î±\nâŠ¢ closure {l} = Ici l"
    },
    {
      "name": "Filter.comap_fst_neBot_iff",
      "statement": "Î± : Type u\nÎ² : Type v\nÎ³ : Type w\nÎ´ : Type u_1\nÎ¹ : Sort x\nl fâœ fâ‚ fâ‚‚ : Filter Î±\ng gâ‚ gâ‚‚ : Filter Î²\nm : Î± â†’ Î²\nm' : Î² â†’ Î³\ns : Set Î±\nt : Set Î²\nf : Filter Î±\nâŠ¢ (comap Prod.fst f).NeBot â†” f.NeBot âˆ§ Nonempty Î²"
    },
    {
      "name": "Filter.comap_pure",
      "statement": "Î± : Type u\nÎ² : Type v\nÎ³ : Type w\nÎ´ : Type u_1\nÎ¹ : Sort x\nl f fâ‚ fâ‚‚ : Filter Î±\ng gâ‚ gâ‚‚ : Filter Î²\nm : Î± â†’ Î²\nm' : Î² â†’ Î³\ns : Set Î±\nt : Set Î²\nb : Î²\nâŠ¢ comap m (pure b) = ğ“Ÿ (m â»Â¹' {b})"
    },
    {
      "name": "Filter.exists_subset_subsingleton_mem_of_forall_separating",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nl : Filter Î±\ninstâœ : CountableInterFilter l\nf g : Î± â†’ Î²\np : Set Î± â†’ Prop\ns : Set Î±\nh : HasCountableSeparatingOn Î± p s\nhs : s âˆˆ l\nhl : âˆ€ (U : Set Î±), p U â†’ U âˆˆ l âˆ¨ Uá¶œ âˆˆ l\nâŠ¢ âˆƒ t âŠ† s, t.Subsingleton âˆ§ t âˆˆ l"
    },
    {
      "name": "Filter.frequently_const",
      "statement": "Î± : Type u\nÎ² : Type v\nÎ³ : Type w\nÎ´ : Type u_1\nÎ¹ : Sort x\nf : Filter Î±\ninstâœ : f.NeBot\np : Prop\nâŠ¢ (âˆƒá¶  (x : Î±) in f, p) â†” p"
    },
    {
      "name": "Filter.frequently_or_distrib_right",
      "statement": "Î± : Type u\nÎ² : Type v\nÎ³ : Type w\nÎ´ : Type u_1\nÎ¹ : Sort x\nf : Filter Î±\ninstâœ : f.NeBot\np : Î± â†’ Prop\nq : Prop\nâŠ¢ (âˆƒá¶  (x : Î±) in f, p x âˆ¨ q) â†” (âˆƒá¶  (x : Î±) in f, p x) âˆ¨ q"
    },
    {
      "name": "Filter.frequently_sSup",
      "statement": "Î± : Type u\nÎ² : Type v\nÎ³ : Type w\nÎ´ : Type u_1\nÎ¹ : Sort x\np : Î± â†’ Prop\nfs : Set (Filter Î±)\nâŠ¢ (âˆƒá¶  (x : Î±) in sSup fs, p x) â†” âˆƒ f âˆˆ fs, âˆƒá¶  (x : Î±) in f, p x"
    },
    {
      "name": "Filter.frequently_top",
      "statement": "Î± : Type u\nÎ² : Type v\nÎ³ : Type w\nÎ´ : Type u_1\nÎ¹ : Sort x\np : Î± â†’ Prop\nâŠ¢ (âˆƒá¶  (x : Î±) in âŠ¤, p x) â†” âˆƒ x, p x"
    },
    {
      "name": "Filter.inf_principal",
      "statement": "Î± : Type u\nÎ² : Type v\nÎ³ : Type w\nÎ´ : Type u_1\nÎ¹ : Sort x\nf g : Filter Î±\nsâœ tâœ s t : Set Î±\nâŠ¢ ğ“Ÿ s âŠ“ ğ“Ÿ t â‰¤ ğ“Ÿ (s âˆ© t)"
    },
    {
      "name": "Filter.ker_comap",
      "statement": "Î¹ : Sort u_1\nÎ± : Type u_2\nÎ² : Type u_3\nfâœ g : Filter Î±\ns : Set Î±\na : Î±\nm : Î± â†’ Î²\nf : Filter Î²\nâŠ¢ (comap m f).ker = m â»Â¹' f.ker"
    },
    {
      "name": "Filter.le_cofinite_iff_compl_singleton_mem",
      "statement": "Î¹ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nl : Filter Î±\nâŠ¢ l â‰¤ cofinite â†” âˆ€ (x : Î±), {x}á¶œ âˆˆ l"
    },
    {
      "name": "Filter.map_eq_bot_iff",
      "statement": "Î± : Type u\nÎ² : Type v\nÎ³ : Type w\nÎ´ : Type u_1\nÎ¹ : Sort x\nl f fâ‚ fâ‚‚ : Filter Î±\ng gâ‚ gâ‚‚ : Filter Î²\nm : Î± â†’ Î²\nm' : Î² â†’ Î³\ns : Set Î±\nt : Set Î²\nâŠ¢ map m f = âŠ¥ â†’ f = âŠ¥"
    },
    {
      "name": "Filter.mapâ‚‚_mk_eq_prod",
      "statement": "Î± : Type u_1\nÎ±' : Type u_2\nÎ² : Type u_3\nÎ²' : Type u_4\nÎ³ : Type u_5\nÎ³' : Type u_6\nÎ´ : Type u_7\nÎ´' : Type u_8\nÎµ : Type u_9\nÎµ' : Type u_10\nm : Î± â†’ Î² â†’ Î³\nfâœ fâ‚ fâ‚‚ : Filter Î±\ngâœ gâ‚ gâ‚‚ : Filter Î²\nh hâ‚ hâ‚‚ : Filter Î³\ns sâ‚ sâ‚‚ : Set Î±\nt tâ‚ tâ‚‚ : Set Î²\nu : Set Î³\nv : Set Î´\na : Î±\nb : Î²\nc : Î³\nf : Filter Î±\ng : Filter Î²\nâŠ¢ mapâ‚‚ Prod.mk f g = f Ã—Ë¢ g"
    },
    {
      "name": "Filter.nhds_pure",
      "statement": "Î¹ : Sort u_1\nÎ± : Type u_2\nÎ² : Type u_3\nX : Type u_4\nY : Type u_5\nx : Î±\nâŠ¢ ğ“ (pure x) = ğ“Ÿ {âŠ¥, pure x}"
    },
    {
      "name": "Filter.pi_eq_bot",
      "statement": "Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u_2\nf fâ‚ fâ‚‚ : (i : Î¹) â†’ Filter (Î± i)\ns : (i : Î¹) â†’ Set (Î± i)\np : (i : Î¹) â†’ Î± i â†’ Prop\nâŠ¢ pi f = âŠ¥ â†” âˆƒ i, f i = âŠ¥"
    },
    {
      "name": "Filter.pi_inf_principal_univ_pi_neBot",
      "statement": "Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u_2\nf fâ‚ fâ‚‚ : (i : Î¹) â†’ Filter (Î± i)\ns : (i : Î¹) â†’ Set (Î± i)\np : (i : Î¹) â†’ Î± i â†’ Prop\nâŠ¢ (pi f âŠ“ ğ“Ÿ (univ.pi s)).NeBot â†” âˆ€ (i : Î¹), (f i âŠ“ ğ“Ÿ (s i)).NeBot"
    },
    {
      "name": "Filter.pi_neBot",
      "statement": "Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u_2\nf fâ‚ fâ‚‚ : (i : Î¹) â†’ Filter (Î± i)\ns : (i : Î¹) â†’ Set (Î± i)\np : (i : Î¹) â†’ Î± i â†’ Prop\nâŠ¢ (pi f).NeBot â†” âˆ€ (i : Î¹), (f i).NeBot"
    },
    {
      "name": "Filter.principal_mono",
      "statement": "Î± : Type u\nÎ² : Type v\nÎ³ : Type w\nÎ´ : Type u_1\nÎ¹ : Sort x\nf g : Filter Î±\nsâœ tâœ s t : Set Î±\nâŠ¢ ğ“Ÿ s â‰¤ ğ“Ÿ t â†” s âŠ† t"
    },
    {
      "name": "Filter.principal_singleton",
      "statement": "Î± : Type u\nÎ² : Type v\nÎ³ : Type w\nÎ´ : Type u_1\nÎ¹ : Sort x\nl : Filter Î±\na : Î±\ns : Set Î±\nâŠ¢ s âˆˆ ğ“Ÿ {a} â†” s âˆˆ pure a"
    },
    {
      "name": "Filter.pure_seq_eq_map",
      "statement": "Î± : Type u\nÎ² : Type v\nÎ³ : Type w\nÎ´ : Type u_1\nÎ¹ : Sort x\nl : Filter Î±\ng : Î± â†’ Î²\nf : Filter Î±\nâŠ¢ (pure g).seq f = map g f"
    },
    {
      "name": "Filter.range_mem_map",
      "statement": "Î± : Type u\nÎ² : Type v\nÎ³ : Type w\nÎ´ : Type u_1\nÎ¹ : Sort x\nl f : Filter Î±\nm : Î± â†’ Î²\nm' : Î² â†’ Î³\ns : Set Î±\nt : Set Î²\nâŠ¢ range m âˆˆ map m f"
    },
    {
      "name": "Filter.rcomap'_rcomap'",
      "statement": "Î± : Type u\nÎ² : Type v\nÎ³ : Type w\nr : Rel Î± Î²\ns : Rel Î² Î³\nl : Filter Î³\nt : Set Î±\nâŠ¢ t âˆˆ rcomap' r (rcomap' s l) â†” t âˆˆ rcomap' (r.comp s) l"
    },
    {
      "name": "Filter.seq_pure",
      "statement": "Î± : Type u\nÎ² : Type v\nÎ³ : Type w\nÎ´ : Type u_1\nÎ¹ : Sort x\nl : Filter Î±\nf : Filter (Î± â†’ Î²)\na : Î±\nâŠ¢ f.seq (pure a) = map (fun g => g a) f"
    },
    {
      "name": "Fin.castAdd_inj",
      "statement": "n m : â„•\na b : Fin m\nâŠ¢ castAdd n a = castAdd n b â†” a = b"
    },
    {
      "name": "Fin.castSucc_pred_add_one_eq",
      "statement": "n m : â„•\na : Fin (n + 1)\nha : a â‰  0\nâŠ¢ (a.pred ha).castSucc + 1 = a"
    },
    {
      "name": "Fin.castSucc_succAbove_castSucc",
      "statement": "nâœ m : â„•\np : Fin (nâœ + 1)\niâœ jâœ : Fin nâœ\nn : â„•\ni : Fin (n + 1)\nj : Fin n\nâŠ¢ i.castSucc.succAbove j.castSucc = (i.succAbove j).castSucc"
    },
    {
      "name": "Fin.coe_of_injective_castLE_symm",
      "statement": "nâœ m n k : â„•\nh : n â‰¤ k\ni : Fin k\nhi : i âˆˆ Set.range (castLE h)\nâŠ¢ â†‘((Equiv.ofInjective (castLE h) â‹¯).symm âŸ¨i, hiâŸ©) = â†‘i"
    },
    {
      "name": "Fin.cycleRange_succAbove",
      "statement": "n : â„•\ni : Fin (n + 1)\nj : Fin n\nâŠ¢ i.cycleRange (i.succAbove j) = j.succ"
    },
    {
      "name": "Fin.cycleRange_zero",
      "statement": "n : â„•\nâŠ¢ cycleRange 0 = 1"
    },
    {
      "name": "Fin.foldl_zero",
      "statement": "Î± : Sort u_1\nf : Î± â†’ Fin 0 â†’ Î±\nx : Î±\nâŠ¢ foldl 0 f x = x"
    },
    {
      "name": "Fin.insertNth_apply_succAbove",
      "statement": "m n : â„•\nÎ± : Fin (n + 1) â†’ Type u\nÎ² : Type v\ni : Fin (n + 1)\nx : Î± i\np : (j : Fin n) â†’ Î± (i.succAbove j)\nj : Fin n\nâŠ¢ i.insertNth x p (i.succAbove j) = p j"
    },
    {
      "name": "Fin.map_valEmbedding_Ioi",
      "statement": "n : â„•\na b : Fin n\nâŠ¢ map valEmbedding (Ioi a) = Ioc (â†‘a) (n - 1)"
    },
    {
      "name": "Fin.min_val",
      "statement": "n m : â„•\na : Fin n\nâŠ¢ min (â†‘a) n = â†‘a"
    },
    {
      "name": "Fin.predAbove_last_castSucc",
      "statement": "n m : â„•\ni : Fin (n + 1)\nâŠ¢ (last n).predAbove i.castSucc = i"
    },
    {
      "name": "Fin.repeat_one",
      "statement": "m n : â„•\nÎ±âœ : Fin (n + 1) â†’ Type u\nx : Î±âœ 0\nq : (i : Fin (n + 1)) â†’ Î±âœ i\np : (i : Fin n) â†’ Î±âœ i.succ\ni : Fin n\ny : Î±âœ i.succ\nz : Î±âœ 0\nÎ± : Type u_1\na : Fin n â†’ Î±\nâŠ¢ repeat 1 a = a âˆ˜ cast â‹¯"
    },
    {
      "name": "Fin.snoc_comp_nat_add",
      "statement": "mâœ nâœ : â„•\nÎ±âœ : Fin (nâœ + 1) â†’ Type u\nx : Î±âœ (last nâœ)\nq : (i : Fin (nâœ + 1)) â†’ Î±âœ i\np : (i : Fin nâœ) â†’ Î±âœ i.castSucc\ni : Fin nâœ\ny : Î±âœ i.castSucc\nz : Î±âœ (last nâœ)\nn m : â„•\nÎ± : Type u_1\nf : Fin (m + n) â†’ Î±\na : Î±\nâŠ¢ snoc f a âˆ˜ natAdd m = snoc (f âˆ˜ natAdd m) a"
    },
    {
      "name": "Fin.succ_one_eq_two'",
      "statement": "n m : â„•\ninstâœ : NeZero n\nâŠ¢ succ 1 = 2"
    },
    {
      "name": "Fin.succ_zero_eq_one'",
      "statement": "n m : â„•\ninstâœ : NeZero n\nâŠ¢ succ 0 = 1"
    },
    {
      "name": "Fin.univ_val_map",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nn : â„•\nf : Fin n â†’ Î±\nâŠ¢ Multiset.map f univ.val = â†‘(List.ofFn f)"
    },
    {
      "name": "Fin.update_cons_zero",
      "statement": "m n : â„•\nÎ± : Fin (n + 1) â†’ Type u\nx : Î± 0\nq : (i : Fin (n + 1)) â†’ Î± i\np : (i : Fin n) â†’ Î± i.succ\ni : Fin n\ny : Î± i.succ\nz : Î± 0\nâŠ¢ update (cons x p) 0 z = cons z p"
    },
    {
      "name": "Fin.zero_add",
      "statement": "n m : â„•\ninstâœ : NeZero n\nk : Fin n\nâŠ¢ 0 + k = k"
    },
    {
      "name": "FiniteDimensional.proper_rclike",
      "statement": "K : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike K\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace K E\ninstâœ : FiniteDimensional K E\nâŠ¢ ProperSpace E"
    },
    {
      "name": "Finmap.erase_toFinmap",
      "statement": "Î± : Type u\nÎ² : Î± â†’ Type v\ninstâœ : DecidableEq Î±\na : Î±\ns : AList Î²\nâŠ¢ erase a âŸ¦sâŸ§ = âŸ¦AList.erase a sâŸ§"
    },
    {
      "name": "Finmap.keysLookupEquiv_symm_apply_keys",
      "statement": "Î± : Type u\nÎ² : Î± â†’ Type v\ninstâœ : DecidableEq Î±\nxâœ : Finmap Î²\nâŠ¢ (keysLookupEquiv.symm (keysLookupEquiv xâœ)).keys = (â†‘(keysLookupEquiv xâœ)).1"
    },
    {
      "name": "Finmap.not_mem_erase_self",
      "statement": "Î± : Type u\nÎ² : Î± â†’ Type v\ninstâœ : DecidableEq Î±\na : Î±\ns : Finmap Î²\nâŠ¢ a âˆ‰ erase a s"
    },
    {
      "name": "Finmap.sigma_keys_lookup",
      "statement": "Î± : Type u\nÎ² : Î± â†’ Type v\ninstâœ : DecidableEq Î±\ns : Finmap Î²\nâŠ¢ (s.keys.sigma fun i => (lookup i s).toFinset) = { val := s.entries, nodup := â‹¯ }"
    },
    {
      "name": "Finset.Ico_diff_Ico_left",
      "statement": "Î¹ : Type u_1\nÎ± : Type u_2\ninstâœÂ¹ : LinearOrder Î±\ninstâœ : LocallyFiniteOrder Î±\naâœ bâœ a b c : Î±\nâŠ¢ Ico a b \\ Ico a c = Ico (max a c) b"
    },
    {
      "name": "Finset.Ico_filter_lt",
      "statement": "Î¹ : Type u_1\nÎ± : Type u_2\ninstâœÂ¹ : LinearOrder Î±\ninstâœ : LocallyFiniteOrder Î±\naâœ bâœ a b c : Î±\nâŠ¢ filter (fun x => x < c) (Ico a b) = Ico a (min b c)"
    },
    {
      "name": "Finset.Ioc_eq_empty_iff",
      "statement": "Î¹ : Type u_1\nÎ± : Type u_2\ninstâœÂ¹ : Preorder Î±\ninstâœ : LocallyFiniteOrder Î±\na aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±\nâŠ¢ Ioc a b = âˆ… â†” Â¬a < b"
    },
    {
      "name": "Finset.box_zero",
      "statement": "Î± : Type u_1\ninstâœÂ² : OrderedRing Î±\ninstâœÂ¹ : LocallyFiniteOrder Î±\ninstâœ : DecidableEq Î±\nn : â„•\nâŠ¢ box 0 = {0}"
    },
    {
      "name": "Finset.card_subtype",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nR : Type u_3\nsâœ t u : Finset Î±\nf : Î± â†’ Î²\nn : â„•\np : Î± â†’ Prop\ninstâœ : DecidablePred p\ns : Finset Î±\nâŠ¢ (Finset.subtype p s).card = (filter p s).card"
    },
    {
      "name": "Finset.disjSups_empty_left",
      "statement": "F : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœâ´ : DecidableEq Î±\ninstâœÂ³ : DecidableEq Î²\ninstâœÂ² : SemilatticeSup Î±\ninstâœÂ¹ : OrderBot Î±\ninstâœ : DecidableRel Disjoint\ns sâ‚ sâ‚‚ t tâ‚ tâ‚‚ u : Finset Î±\na b c : Î±\nâŠ¢ âˆ… â—‹ t = âˆ…"
    },
    {
      "name": "Finset.disjoint_insert_right",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœ : DecidableEq Î±\ns t u v : Finset Î±\na b : Î±\nâŠ¢ _root_.Disjoint (insert a t) s â†” a âˆ‰ s âˆ§ _root_.Disjoint s t"
    },
    {
      "name": "Finset.filter_cons",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\np q : Î± â†’ Prop\ninstâœÂ¹ : DecidablePred p\ninstâœ : DecidablePred q\nsâœ : Finset Î±\na : Î±\ns : Finset Î±\nha : a âˆ‰ s\nâŠ¢ _root_.Disjoint (if p a then {a} else âˆ…) (filter p s)"
    },
    {
      "name": "Finset.finsuppAntidiag_empty_of_ne_zero",
      "statement": "Î¹ : Type u_1\nÎ¼ : Type u_2\nÎ¼' : Type u_3\ninstâœâ¶ : DecidableEq Î¹\ninstâœâµ : AddCommMonoid Î¼\ninstâœâ´ : HasAntidiagonal Î¼\ninstâœÂ³ : DecidableEq Î¼\ninstâœÂ² : AddCommMonoid Î¼'\ninstâœÂ¹ : HasAntidiagonal Î¼'\ninstâœ : DecidableEq Î¼'\nn : Î¼\nhn : n â‰  0\nâŠ¢ âˆ….finsuppAntidiag n = âˆ…"
    },
    {
      "name": "Finset.finsuppAntidiag_zero",
      "statement": "Î¹ : Type u_1\nÎ¼ : Type u_2\nÎ¼' : Type u_3\ninstâœÂ³ : DecidableEq Î¹\ninstâœÂ² : CanonicallyOrderedAddCommMonoid Î¼\ninstâœÂ¹ : HasAntidiagonal Î¼\ninstâœ : DecidableEq Î¼\ns : Finset Î¹\nâŠ¢ s.finsuppAntidiag 0 = {0}"
    },
    {
      "name": "Finset.gcd_insert",
      "statement": "Î¹ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\ninstâœÂ² : CancelCommMonoidWithZero Î±\ninstâœÂ¹ : NormalizedGCDMonoid Î±\ns sâ‚ sâ‚‚ : Finset Î²\nf : Î² â†’ Î±\ninstâœ : DecidableEq Î²\nb : Î²\nâŠ¢ (insert b s).gcd f = GCDMonoid.gcd (f b) (s.gcd f)"
    },
    {
      "name": "Finset.imageâ‚‚_mk_eq_product",
      "statement": "Î± : Type u_1\nÎ±' : Type u_2\nÎ² : Type u_3\nÎ²' : Type u_4\nÎ³ : Type u_5\nÎ³' : Type u_6\nÎ´ : Type u_7\nÎ´' : Type u_8\nÎµ : Type u_9\nÎµ' : Type u_10\nÎ¶ : Type u_11\nÎ¶' : Type u_12\nÎ½ : Type u_13\ninstâœâ¹ : DecidableEq Î±'\ninstâœâ¸ : DecidableEq Î²'\ninstâœâ· : DecidableEq Î³\ninstâœâ¶ : DecidableEq Î³'\ninstâœâµ : DecidableEq Î´\ninstâœâ´ : DecidableEq Î´'\ninstâœÂ³ : DecidableEq Îµ\ninstâœÂ² : DecidableEq Îµ'\nf f' : Î± â†’ Î² â†’ Î³\ng g' : Î± â†’ Î² â†’ Î³ â†’ Î´\nsâœ s' : Finset Î±\ntâœ t' : Finset Î²\nu u' : Finset Î³\na a' : Î±\nb b' : Î²\nc : Î³\ninstâœÂ¹ : DecidableEq Î±\ninstâœ : DecidableEq Î²\ns : Finset Î±\nt : Finset Î²\nâŠ¢ imageâ‚‚ Prod.mk s t = s Ã—Ë¢ t"
    },
    {
      "name": "Finset.insert_compl_insert",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ¹ : Fintype Î±\ns t : Finset Î±\ninstâœ : DecidableEq Î±\na : Î±\nha : a âˆ‰ s\nâŠ¢ insert a (insert a s)á¶œ = sá¶œ"
    },
    {
      "name": "Finset.insert_inter_of_mem",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœ : DecidableEq Î±\ns sâ‚âœ sâ‚‚âœ t tâ‚ tâ‚‚ u v : Finset Î±\naâœ b : Î±\nsâ‚ sâ‚‚ : Finset Î±\na : Î±\nh : a âˆˆ sâ‚‚\nx : Î±\nâŠ¢ x âˆˆ insert a sâ‚ âˆ© sâ‚‚ â†” x âˆˆ insert a (sâ‚ âˆ© sâ‚‚)"
    },
    {
      "name": "Finset.insert_sdiff_cancel",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœ : DecidableEq Î±\ns t u v : Finset Î±\na b : Î±\nha : a âˆ‰ s\nâŠ¢ insert a s \\ s = {a}"
    },
    {
      "name": "Finset.inter_sdiff_self",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœ : DecidableEq Î±\ns t u v : Finset Î±\na b : Î±\nsâ‚ sâ‚‚ : Finset Î±\nâŠ¢ âˆ€ (x : Î±), x âˆ‰ sâ‚ âˆ© (sâ‚‚ \\ sâ‚)"
    },
    {
      "name": "Finset.inv_smul_finset_distrib",
      "statement": "F : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\ninstâœÂ³ : DecidableEq Î²\ninstâœÂ² : Group Î±\ninstâœÂ¹ : MulAction Î± Î²\nsâœ t : Finset Î²\naâœ : Î±\nb : Î²\ninstâœ : DecidableEq Î±\na : Î±\ns : Finset Î±\nâŠ¢ (a â€¢ s)â»Â¹ = op aâ»Â¹ â€¢ sâ»Â¹"
    },
    {
      "name": "Finset.isUnit_iff",
      "statement": "F : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\ninstâœÂ² : DecidableEq Î±\ninstâœÂ¹ : DecidableEq Î²\ninstâœ : DivisionMonoid Î±\ns t : Finset Î±\nâŠ¢ IsUnit s â†” âˆƒ a, s = {a} âˆ§ IsUnit a"
    },
    {
      "name": "Finset.lt_sup_iff",
      "statement": "F : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\nÎ¹ : Type u_5\nÎº : Type u_6\ninstâœÂ¹ : LinearOrder Î±\ninstâœ : OrderBot Î±\ns : Finset Î¹\nf : Î¹ â†’ Î±\na : Î±\nâŠ¢ a < s.sup f â†” âˆƒ b âˆˆ s, a < f b"
    },
    {
      "name": "Finset.map_add_left_Ioo",
      "statement": "Î¹ : Type u_1\nÎ± : Type u_2\ninstâœÂ² : OrderedCancelAddCommMonoid Î±\ninstâœÂ¹ : ExistsAddOfLE Î±\ninstâœ : LocallyFiniteOrder Î±\na b c : Î±\nâŠ¢ map (addLeftEmbedding c) (Ioo a b) = Ioo (c + a) (c + b)"
    },
    {
      "name": "Finset.max'_image",
      "statement": "F : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\nÎ¹ : Type u_5\nÎº : Type u_6\ninstâœÂ¹ : LinearOrder Î±\nsâœ : Finset Î±\nH : sâœ.Nonempty\nx : Î±\ninstâœ : LinearOrder Î²\nf : Î± â†’ Î²\nhf : Monotone f\ns : Finset Î±\nh : (image f s).Nonempty\nâŠ¢ (image f s).max' h = f (s.max' â‹¯)"
    },
    {
      "name": "Finset.mem_inv'",
      "statement": "F : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\ninstâœÂ¹ : DecidableEq Î±\ninstâœ : InvolutiveInv Î±\ns : Finset Î±\na : Î±\nâŠ¢ a âˆˆ sâ»Â¹ â†” aâ»Â¹ âˆˆ s"
    },
    {
      "name": "Finset.mem_sum",
      "statement": "Î¹ : Type u_1\nÎº : Type u_2\nÎ± : Type u_3\nÎ² : Type u_4\nÎ³ : Type u_5\nsâœ sâ‚ sâ‚‚ : Finset Î±\na : Î±\nfâœ g : Î± â†’ Î²\nf : Î± â†’ Multiset Î²\ns : Finset Î±\nb : Î²\nâŠ¢ b âˆˆ âˆ‘ x âˆˆ s, f x â†” âˆƒ a âˆˆ s, b âˆˆ f a"
    },
    {
      "name": "Finset.mem_sumLiftâ‚‚",
      "statement": "Î±â‚ : Type u_1\nÎ±â‚‚ : Type u_2\nÎ²â‚ : Type u_3\nÎ²â‚‚ : Type u_4\nÎ³â‚ : Type u_5\nÎ³â‚‚ : Type u_6\nf fâ‚ gâ‚ : Î±â‚ â†’ Î²â‚ â†’ Finset Î³â‚\ng fâ‚‚ gâ‚‚ : Î±â‚‚ â†’ Î²â‚‚ â†’ Finset Î³â‚‚\na : Î±â‚ âŠ• Î±â‚‚\nb : Î²â‚ âŠ• Î²â‚‚\nc : Î³â‚ âŠ• Î³â‚‚\nâŠ¢ c âˆˆ sumLiftâ‚‚ f g a b â†”\n    (âˆƒ aâ‚ bâ‚ câ‚, a = inl aâ‚ âˆ§ b = inl bâ‚ âˆ§ c = inl câ‚ âˆ§ câ‚ âˆˆ f aâ‚ bâ‚) âˆ¨\n      âˆƒ aâ‚‚ bâ‚‚ câ‚‚, a = inr aâ‚‚ âˆ§ b = inr bâ‚‚ âˆ§ c = inr câ‚‚ âˆ§ câ‚‚ âˆˆ g aâ‚‚ bâ‚‚"
    },
    {
      "name": "Finset.mem_sym_iff",
      "statement": "Î± : Type u_1\ninstâœ : DecidableEq Î±\ns t : Finset Î±\na b : Î±\nn : â„•\nm : Sym Î± n\nâŠ¢ m âˆˆ s.sym n â†” âˆ€ a âˆˆ m, a âˆˆ s"
    },
    {
      "name": "Finset.memberSubfamily_nonMemberSubfamily",
      "statement": "Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ â„¬ : Finset (Finset Î±)\ns : Finset Î±\na : Î±\nâŠ¢ memberSubfamily a (nonMemberSubfamily a ğ’œ) = âˆ…"
    },
    {
      "name": "Finset.mk_mem_sym2_iff",
      "statement": "Î± : Type u_1\ns t : Finset Î±\na b : Î±\nâŠ¢ s(a, b) âˆˆ s.sym2 â†” a âˆˆ s âˆ§ b âˆˆ s"
    },
    {
      "name": "Finset.natCast_card_filter",
      "statement": "Î¹ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\nÎº : Î¹ â†’ Type u_5\nsâœ sâ‚ sâ‚‚ : Finset Î¹\ni : Î¹\na : Î±\nf g : Î¹ â†’ Î±\ninstâœÂ¹ : AddCommMonoidWithOne Î±\np : Î¹ â†’ Prop\ninstâœ : DecidablePred p\ns : Finset Î¹\nâŠ¢ â†‘(filter p s).card = âˆ‘ a âˆˆ s, if p a then 1 else 0"
    },
    {
      "name": "Finset.noncommProd_singleton",
      "statement": "F : Type u_1\nÎ¹ : Type u_2\nÎ± : Type u_3\nÎ² : Type u_4\nÎ³ : Type u_5\nfâœ : Î± â†’ Î² â†’ Î²\nop : Î± â†’ Î± â†’ Î±\ninstâœÂ¹ : Monoid Î²\ninstâœ : Monoid Î³\na : Î±\nf : Î± â†’ Î²\nâŠ¢ (â†‘{a}).Pairwise fun a b => Commute (f a) (f b)"
    },
    {
      "name": "Finset.nonempty_Ico",
      "statement": "Î¹ : Type u_1\nÎ± : Type u_2\ninstâœÂ¹ : Preorder Î±\ninstâœ : LocallyFiniteOrder Î±\na aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±\nâŠ¢ (Ico a b).Nonempty â†” a < b"
    },
    {
      "name": "Finset.offDiag_card",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœ : DecidableEq Î±\ns t : Finset Î±\nx : Î± Ã— Î±\nthis : s.diag.card + s.offDiag.card = s.card * s.card\nâŠ¢ s.offDiag.card = s.card * s.card - s.card"
    },
    {
      "name": "Finset.powersetCard_zero",
      "statement": "Î± : Type u_1\nsâœÂ¹ tâœ : Finset Î±\nn : ?m.14430\nsâœ t s : Finset Î±\nâŠ¢ powersetCard 0 s = {âˆ…}"
    },
    {
      "name": "Finset.preimage_mul_left_singleton",
      "statement": "F : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\ninstâœ : Group Î±\ns t : Finset Î±\na b : Î±\nâŠ¢ {b}.preimage (fun x => a * x) â‹¯ = {aâ»Â¹ * b}"
    },
    {
      "name": "Finset.preimage_union",
      "statement": "Î± : Type u\nÎ² : Type v\nÎ¹ : Sort w\nÎ³ : Type x\ninstâœÂ¹ : DecidableEq Î±\ninstâœ : DecidableEq Î²\nf : Î± â†’ Î²\ns t : Finset Î²\nhst : InjOn f (f â»Â¹' â†‘(s âˆª t))\nâŠ¢ â†‘((s âˆª t).preimage f hst) = â†‘(s.preimage f â‹¯ âˆª t.preimage f â‹¯)"
    },
    {
      "name": "Finset.prod_dite_eq'",
      "statement": "Î¹ : Type u_1\nÎº : Type u_2\nÎ± : Type u_3\nÎ² : Type u_4\nÎ³ : Type u_5\nsâœ sâ‚ sâ‚‚ : Finset Î±\naâœ : Î±\nf g : Î± â†’ Î²\ninstâœÂ¹ : CommMonoid Î²\ninstâœ : DecidableEq Î±\ns : Finset Î±\na : Î±\nb : (x : Î±) â†’ x = a â†’ Î²\nâŠ¢ (âˆ x âˆˆ s, if h : x = a then b x h else 1) = if a âˆˆ s then b a â‹¯ else 1"
    },
    {
      "name": "Finset.shatters_shatterer",
      "statement": "Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ â„¬ : Finset (Finset Î±)\ns t : Finset Î±\na : Î±\nn : â„•\nâŠ¢ ğ’œ.shatterer.Shatters s â†” ğ’œ.Shatters s"
    },
    {
      "name": "Finset.sigma_nonempty",
      "statement": "Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u_2\nÎ² : Type u_3\ns sâ‚ sâ‚‚ : Finset Î¹\nt tâ‚ tâ‚‚ : (i : Î¹) â†’ Finset (Î± i)\nâŠ¢ (s.sigma t).Nonempty â†” âˆƒ i âˆˆ s, (t i).Nonempty"
    },
    {
      "name": "Finset.singleton_inter_of_not_mem",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœ : DecidableEq Î±\nsâœ sâ‚ sâ‚‚ t tâ‚ tâ‚‚ u v : Finset Î±\naâœ b a : Î±\ns : Finset Î±\nH : a âˆ‰ s\nâŠ¢ âˆ€ (x : Î±), x âˆ‰ {a} âˆ© s"
    },
    {
      "name": "Finset.singleton_subset_singleton",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ns : Finset Î±\na b : Î±\nâŠ¢ {a} âŠ† {b} â†” a = b"
    },
    {
      "name": "Finset.subset_singleton_iff",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nsâœ : Finset Î±\naâœ b : Î±\ns : Finset Î±\na : Î±\nâŠ¢ s âŠ† {a} â†” s = âˆ… âˆ¨ s = {a}"
    },
    {
      "name": "Finset.sum_card_slice",
      "statement": "Î± : Type u_1\nÎ¹ : Sort u_2\nÎº : Î¹ â†’ Sort u_3\nğ’œ : Finset (Finset Î±)\nA Aâ‚ Aâ‚‚ : Finset Î±\nr râ‚ râ‚‚ : â„•\ninstâœ : Fintype Î±\nâŠ¢ âˆ‘ r âˆˆ Iic (Fintype.card Î±), (ğ’œ # r).card = ğ’œ.card"
    },
    {
      "name": "Finset.sup'_const",
      "statement": "F : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\nÎ¹ : Type u_5\nÎº : Type u_6\ninstâœ : SemilatticeSup Î±\ns : Finset Î²\nH : s.Nonempty\nf : Î² â†’ Î±\na : Î±\nâŠ¢ (s.sup' H fun x => a) = a"
    },
    {
      "name": "Finset.sup_le_iff",
      "statement": "F : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\nÎ¹ : Type u_5\nÎº : Type u_6\ninstâœÂ¹ : SemilatticeSup Î±\ninstâœ : OrderBot Î±\ns sâ‚ sâ‚‚ : Finset Î²\nf g : Î² â†’ Î±\naâœ a : Î±\nâŠ¢ s.sup f â‰¤ a â†” âˆ€ b âˆˆ s, f b â‰¤ a"
    },
    {
      "name": "Finset.sym2_eq_empty",
      "statement": "Î± : Type u_1\ns t : Finset Î±\na b : Î±\nâŠ¢ s.sym2 = âˆ… â†” s = âˆ…"
    },
    {
      "name": "Finset.sym_eq_empty",
      "statement": "Î± : Type u_1\ninstâœ : DecidableEq Î±\ns t : Finset Î±\na b : Î±\nn : â„•\nâŠ¢ s.sym n = âˆ… â†” n â‰  0 âˆ§ s = âˆ…"
    },
    {
      "name": "Finset.val_eq_singleton_iff",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nsâœ : Finset Î±\naâœ b a : Î±\ns : Finset Î±\nâŠ¢ s.val = {a} â†” s = {a}"
    },
    {
      "name": "Finset.weightedVSubOfPoint_congr",
      "statement": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninstâœÂ² : Ring k\ninstâœÂ¹ : AddCommGroup V\ninstâœ : Module k V\nS : AffineSpace V P\nÎ¹ : Type u_4\ns : Finset Î¹\nÎ¹â‚‚ : Type u_5\nsâ‚‚ : Finset Î¹â‚‚\nwâ‚ wâ‚‚ : Î¹ â†’ k\nhw : âˆ€ i âˆˆ s, wâ‚ i = wâ‚‚ i\npâ‚ pâ‚‚ : Î¹ â†’ P\nhp : âˆ€ i âˆˆ s, pâ‚ i = pâ‚‚ i\nb : P\nâŠ¢ (s.weightedVSubOfPoint pâ‚ b) wâ‚ = (s.weightedVSubOfPoint pâ‚‚ b) wâ‚‚"
    },
    {
      "name": "Finset.weightedVSubOfPoint_erase",
      "statement": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninstâœÂ³ : Ring k\ninstâœÂ² : AddCommGroup V\ninstâœÂ¹ : Module k V\nS : AffineSpace V P\nÎ¹ : Type u_4\ns : Finset Î¹\nÎ¹â‚‚ : Type u_5\nsâ‚‚ : Finset Î¹â‚‚\ninstâœ : DecidableEq Î¹\nw : Î¹ â†’ k\np : Î¹ â†’ P\ni : Î¹\nâŠ¢ ((s.erase i).weightedVSubOfPoint p (p i)) w = (s.weightedVSubOfPoint p (p i)) w"
    },
    {
      "name": "Finsupp.comapDomain_single",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ¹ : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS : Type u_12\ninstâœ : Zero M\nf : Î± â†’ Î²\na : Î±\nm : M\nhif : Set.InjOn f (f â»Â¹' â†‘(single (f a) m).support)\nâŠ¢ comapDomain f (single (f a) m) hif = single a m"
    },
    {
      "name": "Finsupp.cons_zero_zero",
      "statement": "n : â„•\ni : Fin n\nM : Type u_1\ninstâœ : Zero M\ny : M\nt : Fin (n + 1) â†’â‚€ M\ns : Fin n â†’â‚€ M\nâŠ¢ cons 0 0 = 0"
    },
    {
      "name": "Finsupp.embDomain_single",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ¹ : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS : Type u_12\ninstâœÂ¹ : Zero M\ninstâœ : Zero N\nf : Î± â†ª Î²\na : Î±\nm : M\nâŠ¢ embDomain f (single a m) = single (f a) m"
    },
    {
      "name": "Finsupp.equivMapDomain_single",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ¹ : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS : Type u_12\ninstâœ : Zero M\nf : Î± â‰ƒ Î²\na : Î±\nb : M\nâŠ¢ equivMapDomain f (single a b) = single (f a) b"
    },
    {
      "name": "Finsupp.erase_add",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ¹ : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS : Type u_12\ninstâœ : AddZeroClass M\na : Î±\nf f' : Î± â†’â‚€ M\nâŠ¢ erase a (f + f') = erase a f + erase a f'"
    },
    {
      "name": "Finsupp.mem_neLocus",
      "statement": "Î± : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\ninstâœÂ² : DecidableEq Î±\ninstâœÂ¹ : DecidableEq N\ninstâœ : Zero N\nfâœ gâœ f g : Î± â†’â‚€ N\na : Î±\nâŠ¢ a âˆˆ f.neLocus g â†” f a â‰  g a"
    },
    {
      "name": "Finsupp.neLocus_self_sub_right",
      "statement": "Î± : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\ninstâœÂ² : DecidableEq Î±\ninstâœÂ¹ : DecidableEq N\ninstâœ : AddGroup N\nf fâ‚ fâ‚‚ g gâ‚ gâ‚‚ : Î± â†’â‚€ N\nâŠ¢ f.neLocus (f - g) = g.support"
    },
    {
      "name": "Finsupp.support_subtypeDomain",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ¹ : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS : Type u_12\ninstâœ : Zero M\np : Î± â†’ Prop\nD : DecidablePred p\nf : Î± â†’â‚€ M\nâŠ¢ (subtypeDomain p f).support = Finset.subtype p f.support"
    },
    {
      "name": "Finsupp.univ_sum_single",
      "statement": "Î± : Type u_1\nÎ¹ : Type u_2\nÎ³ : Type u_3\nA : Type u_4\nB : Type u_5\nC : Type u_6\ninstâœâ´ : AddCommMonoid A\ninstâœÂ³ : AddCommMonoid B\ninstâœÂ² : AddCommMonoid C\nt : Î¹ â†’ A â†’ C\nh0 : âˆ€ (i : Î¹), t i 0 = 0\nh1 : âˆ€ (i : Î¹) (x y : A), t i (x + y) = t i x + t i y\ns : Finset Î±\nfâœ : Î± â†’ Î¹ â†’â‚€ A\ni : Î¹\ng : Î¹ â†’â‚€ A\nk : Î¹ â†’ A â†’ Î³ â†’ B\nx : Î³\nÎ² : Type u_7\nM : Type u_8\nM' : Type u_9\nN : Type u_10\nP : Type u_11\nG : Type u_12\nH : Type u_13\nR : Type u_14\nS : Type u_15\ninstâœÂ¹ : Fintype Î±\ninstâœ : AddCommMonoid M\nf : Î± â†’â‚€ M\nâŠ¢ âˆ‘ a : Î±, single a (f a) = f"
    },
    {
      "name": "Finsupp.univ_sum_single_apply'",
      "statement": "Î± : Type u_1\nÎ¹ : Type u_2\nÎ³ : Type u_3\nA : Type u_4\nB : Type u_5\nC : Type u_6\ninstâœâ´ : AddCommMonoid A\ninstâœÂ³ : AddCommMonoid B\ninstâœÂ² : AddCommMonoid C\nt : Î¹ â†’ A â†’ C\nh0 : âˆ€ (i : Î¹), t i 0 = 0\nh1 : âˆ€ (i : Î¹) (x y : A), t i (x + y) = t i x + t i y\ns : Finset Î±\nf : Î± â†’ Î¹ â†’â‚€ A\niâœ : Î¹\ng : Î¹ â†’â‚€ A\nk : Î¹ â†’ A â†’ Î³ â†’ B\nx : Î³\nÎ² : Type u_7\nM : Type u_8\nM' : Type u_9\nN : Type u_10\nP : Type u_11\nG : Type u_12\nH : Type u_13\nR : Type u_14\nS : Type u_15\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : Fintype Î±\ni : Î±\nm : M\nâŠ¢ âˆ‘ j : Î±, (single j m) i = m"
    },
    {
      "name": "Fintype.card_congr'",
      "statement": "Î±âœ : Type u_1\nÎ²âœ : Type u_2\nÎ³ : Type u_3\nÎ± Î² : Type u_4\ninstâœÂ¹ : Fintype Î±\ninstâœ : Fintype Î²\nh : Î± = Î²\nâŠ¢ Î± â‰ƒ Î²"
    },
    {
      "name": "Fintype.card_piFinset",
      "statement": "Î±âœ : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ¹ : Type u_4\nÎº : Type u_5\nÎ± : Î¹ â†’ Type u_6\ninstâœÂ³ : DecidableEq Î¹\ninstâœÂ² : DecidableEq Îº\ninstâœÂ¹ : Fintype Î¹\ninstâœ : (i : Î¹) â†’ DecidableEq (Î± i)\ns : (i : Î¹) â†’ Finset (Î± i)\nâŠ¢ (piFinset s).card = âˆ i : Î¹, (s i).card"
    },
    {
      "name": "Fintype.mem_piFinset",
      "statement": "Î± : Type u_1\ninstâœÂ¹ : DecidableEq Î±\ninstâœ : Fintype Î±\nÎ³ : Î± â†’ Type u_2\nÎ´ : Î± â†’ Type u_3\ns : (a : Î±) â†’ Finset (Î³ a)\nt : (a : Î±) â†’ Finset (Î´ a)\nf : (a : Î±) â†’ Î´ a\nâŠ¢ f âˆˆ piFinset t â†” âˆ€ (a : Î±), f a âˆˆ t a"
    },
    {
      "name": "Fintype.prod_bool",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœ : CommMonoid Î±\nf : Bool â†’ Î±\nâŠ¢ âˆ b : Bool, f b = f true * f false"
    },
    {
      "name": "FirstOrder.Language.BoundedFormula.castLE_castLE",
      "statement": "L : Language\nL' : Language\nM : Type w\nN : Type u_1\nP : Type u_2\ninstâœÂ² : L.Structure M\ninstâœÂ¹ : L.Structure N\ninstâœ : L.Structure P\nÎ± : Type u'\nÎ² : Type v'\nÎ³ : Type u_3\nnâœ k m n : â„•\nkm : k â‰¤ m\nmn : m â‰¤ n\nÏ† : L.BoundedFormula Î± k\nâŠ¢ castLE mn (castLE km Ï†) = castLE â‹¯ Ï†"
    },
    {
      "name": "FirstOrder.Language.BoundedFormula.castLE_rfl",
      "statement": "L : Language\nL' : Language\nM : Type w\nN : Type u_1\nP : Type u_2\ninstâœÂ² : L.Structure M\ninstâœÂ¹ : L.Structure N\ninstâœ : L.Structure P\nÎ± : Type u'\nÎ² : Type v'\nÎ³ : Type u_3\nnâœ n : â„•\nh : n â‰¤ n\nÏ† : L.BoundedFormula Î± n\nâŠ¢ castLE h Ï† = Ï†"
    },
    {
      "name": "FirstOrder.Language.BoundedFormula.realize_alls",
      "statement": "L : Language\nL' : Language\nM : Type w\nN : Type u_1\nP : Type u_2\ninstâœÂ² : L.Structure M\ninstâœÂ¹ : L.Structure N\ninstâœ : L.Structure P\nÎ± : Type u'\nÎ² : Type v'\nÎ³ : Type u_3\nn : â„•\nT : L.Theory\nÏ† : L.BoundedFormula Î± n\nv : Î± â†’ M\nâŠ¢ Ï†.alls.Realize v â†” âˆ€ (xs : Fin n â†’ M), Ï†.Realize v xs"
    },
    {
      "name": "FirstOrder.Language.BoundedFormula.realize_ex",
      "statement": "L : Language\nL' : Language\nM : Type w\nN : Type u_1\nP : Type u_2\ninstâœÂ² : L.Structure M\ninstâœÂ¹ : L.Structure N\ninstâœ : L.Structure P\nÎ± : Type u'\nÎ² : Type v'\nÎ³ : Type u_3\nn l : â„•\nÏ† Ïˆ : L.BoundedFormula Î± l\nÎ¸ : L.BoundedFormula Î± l.succ\nv : Î± â†’ M\nxs : Fin l â†’ M\nâŠ¢ (âˆƒ'Î¸).Realize v xs â†” âˆƒ a, Î¸.Realize v (snoc xs a)"
    },
    {
      "name": "FirstOrder.Language.BoundedFormula.realize_iSup",
      "statement": "L : Language\nL' : Language\nM : Type w\nN : Type u_1\nP : Type u_2\ninstâœÂ² : L.Structure M\ninstâœÂ¹ : L.Structure N\ninstâœ : L.Structure P\nÎ± : Type u'\nÎ² : Type v'\nÎ³ : Type u_3\nn : â„•\nT : L.Theory\ns : Finset Î²\nf : Î² â†’ L.BoundedFormula Î± n\nv : Î± â†’ M\nv' : Fin n â†’ M\nâŠ¢ (iSup s f).Realize v v' â†” âˆƒ b âˆˆ s, (f b).Realize v v'"
    },
    {
      "name": "FirstOrder.Language.BoundedFormula.realize_liftAt_one_self",
      "statement": "L : Language\nL' : Language\nM : Type w\nN : Type u_1\nP : Type u_2\ninstâœÂ² : L.Structure M\ninstâœÂ¹ : L.Structure N\ninstâœ : L.Structure P\nÎ± : Type u'\nÎ² : Type v'\nÎ³ : Type u_3\nnâœ l : â„•\nÏ†âœ Ïˆ : L.BoundedFormula Î± l\nÎ¸ : L.BoundedFormula Î± l.succ\nvâœ : Î± â†’ M\nxsâœ : Fin l â†’ M\nn : â„•\nÏ† : L.BoundedFormula Î± n\nv : Î± â†’ M\nxs : Fin (n + 1) â†’ M\nâŠ¢ (liftAt 1 n Ï†).Realize v xs â†” Ï†.Realize v (xs âˆ˜ castSucc)"
    },
    {
      "name": "FirstOrder.Language.BoundedFormula.realize_toPrenex",
      "statement": "L : Language\nL' : Language\nM : Type w\nN : Type u_1\nP : Type u_2\ninstâœÂ³ : L.Structure M\ninstâœÂ² : L.Structure N\ninstâœÂ¹ : L.Structure P\nÎ± : Type u'\nÎ² : Type v'\nÎ³ : Type u_3\nn l : â„•\nÏ†âœ Ïˆ : L.BoundedFormula Î± l\nÎ¸ : L.BoundedFormula Î± l.succ\nvâœ : Î± â†’ M\nxs : Fin l â†’ M\ninstâœ : Nonempty M\nÏ† : L.BoundedFormula Î± n\nv : Î± â†’ M\nâŠ¢ âˆ€ {xs : Fin n â†’ M}, Ï†.toPrenex.Realize v xs â†” Ï†.Realize v xs"
    },
    {
      "name": "FirstOrder.Language.DirectLimit.funMap_quotient_mk'_sigma_mk'",
      "statement": "L : Language\nÎ¹ : Type v\ninstâœâ´ : Preorder Î¹\nG : Î¹ â†’ Type w\ninstâœÂ³ : (i : Î¹) â†’ L.Structure (G i)\nf : (i j : Î¹) â†’ i â‰¤ j â†’ G i â†ª[L] G j\ninstâœÂ² : IsDirected Î¹ fun x x_1 => x â‰¤ x_1\ninstâœÂ¹ : DirectedSystem G fun i j h => â‡‘(f i j h)\ninstâœ : Nonempty Î¹\nn : â„•\nF : L.Functions n\ni : Î¹\nx : Fin n â†’ G i\nâŠ¢ (funMap F fun a => âŸ¦Structure.Sigma.mk f i (x a)âŸ§) = âŸ¦Structure.Sigma.mk f i (funMap F x)âŸ§"
    },
    {
      "name": "FirstOrder.Language.Formula.realize_equivSentence_symm_con",
      "statement": "L : Language\nL' : Language\nM : Type w\nN : Type u_1\nP : Type u_2\ninstâœâ´ : L.Structure M\ninstâœÂ³ : L.Structure N\ninstâœÂ² : L.Structure P\nÎ± : Type u'\nÎ² : Type v'\nÎ³ : Type u_3\nn : â„•\ninstâœÂ¹ : L[[Î±]].Structure M\ninstâœ : (L.lhomWithConstants Î±).IsExpansionOn M\nÏ† : L[[Î±]].Sentence\nâŠ¢ ((equivSentence.symm Ï†).Realize fun a => â†‘(L.con a)) â†” M âŠ¨ Ï†"
    },
    {
      "name": "FirstOrder.Language.Formula.realize_relâ‚‚",
      "statement": "L : Language\nL' : Language\nM : Type w\nN : Type u_1\nP : Type u_2\ninstâœÂ² : L.Structure M\ninstâœÂ¹ : L.Structure N\ninstâœ : L.Structure P\nÎ± : Type u'\nÎ² : Type v'\nÎ³ : Type u_3\nn : â„•\nÏ† Ïˆ : L.Formula Î±\nv : Î± â†’ M\nR : L.Relations 2\ntâ‚ tâ‚‚ : L.Term Î±\nâŠ¢ (R.formulaâ‚‚ tâ‚ tâ‚‚).Realize v â†” RelMap R ![Term.realize v tâ‚, Term.realize v tâ‚‚]"
    },
    {
      "name": "FirstOrder.Language.IsUltrahomogeneous.amalgamation_age",
      "statement": "L : Language\nK : Set (Bundled L.Structure)\nM : Type w\ninstâœÂ¹ : L.Structure M\nN : Type w\ninstâœ : L.Structure N\nh : L.IsUltrahomogeneous M\nâŠ¢ Amalgamation (L.age M)"
    },
    {
      "name": "FirstOrder.Language.LHom.realize_onTerm",
      "statement": "L : Language\nL' : Language\nM : Type w\nN : Type u_1\nP : Type u_2\ninstâœâ´ : L.Structure M\ninstâœÂ³ : L.Structure N\ninstâœÂ² : L.Structure P\nÎ± : Type u'\nÎ² : Type v'\nÎ³ : Type u_3\ninstâœÂ¹ : L'.Structure M\nÏ† : L â†’á´¸ L'\ninstâœ : Ï†.IsExpansionOn M\nt : L.Term Î±\nv : Î± â†’ M\nâŠ¢ Term.realize v (Ï†.onTerm t) = Term.realize v t"
    },
    {
      "name": "FirstOrder.Language.LHom.setOf_realize_onFormula",
      "statement": "L : Language\nL' : Language\nM : Type w\nN : Type u_1\nP : Type u_2\ninstâœâ´ : L.Structure M\ninstâœÂ³ : L.Structure N\ninstâœÂ² : L.Structure P\nÎ± : Type u'\nÎ² : Type v'\nÎ³ : Type u_3\nn : â„•\ninstâœÂ¹ : L'.Structure M\nÏ† : L â†’á´¸ L'\ninstâœ : Ï†.IsExpansionOn M\nÏˆ : L.Formula Î±\nâŠ¢ setOf (Ï†.onFormula Ïˆ).Realize = setOf Ïˆ.Realize"
    },
    {
      "name": "FirstOrder.Language.Substructure.comap_id",
      "statement": "L : Language\nM : Type w\nN : Type u_1\nP : Type u_2\ninstâœÂ² : L.Structure M\ninstâœÂ¹ : L.Structure N\ninstâœ : L.Structure P\nSâœ : L.Substructure M\ns : Set M\nS : L.Substructure P\nâŠ¢ âˆ€ (x : P), x âˆˆ comap (Hom.id L P) S â†” x âˆˆ S"
    },
    {
      "name": "FirstOrder.Language.Term.realize_functions_applyâ‚",
      "statement": "L : Language\nL' : Language\nM : Type w\nN : Type u_1\nP : Type u_2\ninstâœÂ² : L.Structure M\ninstâœÂ¹ : L.Structure N\ninstâœ : L.Structure P\nÎ± : Type u'\nÎ² : Type v'\nÎ³ : Type u_3\nf : L.Functions 1\nt : L.Term Î±\nv : Î± â†’ M\nâŠ¢ realize v (f.applyâ‚ t) = funMap f ![realize v t]"
    },
    {
      "name": "FirstOrder.Language.Term.realize_subst",
      "statement": "L : Language\nL' : Language\nM : Type w\nN : Type u_1\nP : Type u_2\ninstâœÂ² : L.Structure M\ninstâœÂ¹ : L.Structure N\ninstâœ : L.Structure P\nÎ± : Type u'\nÎ² : Type v'\nÎ³ : Type u_3\nt : L.Term Î±\ntf : Î± â†’ L.Term Î²\nv : Î² â†’ M\nâŠ¢ realize v (t.subst tf) = realize (fun a => realize v (tf a)) t"
    },
    {
      "name": "FirstOrder.Language.Term.relabel_id",
      "statement": "L : Language\nL' : Language\nM : Type w\nN : Type u_1\nP : Type u_2\ninstâœÂ² : L.Structure M\ninstâœÂ¹ : L.Structure N\ninstâœ : L.Structure P\nÎ± : Type u'\nÎ² : Type v'\nÎ³ : Type u_3\nt : L.Term Î±\nâŠ¢ relabel id t = t"
    },
    {
      "name": "FormalMultilinearSeries.coeff_iterate_fslope",
      "statement": "ğ•œ : Type u\nğ•œ' : Type u'\nE : Type v\nF : Type w\nG : Type x\ninstâœÂ² : NontriviallyNormedField ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\np : FormalMultilinearSeries ğ•œ ğ•œ E\nnâœ k n : â„•\nâŠ¢ (fslope^[k] p).coeff n = p.coeff (n + k)"
    },
    {
      "name": "FormalMultilinearSeries.compPartialSumTarget_tendsto_atTop",
      "statement": "ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\nH : Type u_5\ninstâœâ¸ : NontriviallyNormedField ğ•œ\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : NormedAddCommGroup H\ninstâœ : NormedSpace ğ•œ H\nâŠ¢ Tendsto (fun N => compPartialSumTarget 0 N N) atTop atTop"
    },
    {
      "name": "FormalMultilinearSeries.id_comp",
      "statement": "ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\nH : Type u_5\ninstâœâ¸ : NontriviallyNormedField ğ•œ\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : NormedAddCommGroup H\ninstâœ : NormedSpace ğ•œ H\np : FormalMultilinearSeries ğ•œ E F\nh : p 0 = 0\nâŠ¢ (id ğ•œ F).comp p = p"
    },
    {
      "name": "FormalMultilinearSeries.rightInv_coeff_zero",
      "statement": "ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\ni : E â‰ƒL[ğ•œ] F\nâŠ¢ p.rightInv i 0 = 0"
    },
    {
      "name": "FractionalIdeal.coe_spanSingleton",
      "statement": "R : Type u_1\ninstâœâ¶ : CommRing R\nS : Submonoid R\nP : Type u_2\ninstâœâµ : CommRing P\ninstâœâ´ : Algebra R P\nloc : IsLocalization S P\nRâ‚ : Type u_3\ninstâœÂ³ : CommRing Râ‚\nK : Type u_4\ninstâœÂ² : Field K\ninstâœÂ¹ : Algebra Râ‚ K\ninstâœ : IsFractionRing Râ‚ K\nx : P\nâŠ¢ â†‘(spanSingleton S x) = span R {x}"
    },
    {
      "name": "FractionalIdeal.den_mem_inv",
      "statement": "R : Type u_1\nA : Type u_2\nK : Type u_3\ninstâœâ¹ : CommRing R\ninstâœâ¸ : CommRing A\ninstâœâ· : Field K\nRâ‚ : Type u_4\ninstâœâ¶ : CommRing Râ‚\ninstâœâµ : IsDomain Râ‚\ninstâœâ´ : Algebra Râ‚ K\ninstâœÂ³ : IsFractionRing Râ‚ K\nIâœ J : FractionalIdeal Râ‚â° K\nK' : Type u_5\ninstâœÂ² : Field K'\ninstâœÂ¹ : Algebra Râ‚ K'\ninstâœ : IsFractionRing Râ‚ K'\nI : FractionalIdeal Râ‚â° K\nhI : I â‰  âŠ¥\nâŠ¢ (algebraMap Râ‚ K) â†‘I.den âˆˆ Iâ»Â¹"
    },
    {
      "name": "FractionalIdeal.div_one",
      "statement": "R : Type u_1\ninstâœâ¶ : CommRing R\nS : Submonoid R\nP : Type u_2\ninstâœâµ : CommRing P\ninstâœâ´ : Algebra R P\nloc : IsLocalization S P\nRâ‚ : Type u_3\ninstâœÂ³ : CommRing Râ‚\nK : Type u_4\ninstâœÂ² : Field K\ninstâœÂ¹ : Algebra Râ‚ K\nfrac : IsFractionRing Râ‚ K\ninstâœ : IsDomain Râ‚\nIâœ J I : FractionalIdeal Râ‚â° K\nâŠ¢ I / 1 = I"
    },
    {
      "name": "FractionalIdeal.div_spanSingleton",
      "statement": "R : Type u_1\ninstâœâ· : CommRing R\nS : Submonoid R\nP : Type u_2\ninstâœâ¶ : CommRing P\ninstâœâµ : Algebra R P\nloc : IsLocalization S P\nRâ‚ : Type u_3\ninstâœâ´ : CommRing Râ‚\nK : Type u_4\ninstâœÂ³ : Field K\ninstâœÂ² : Algebra Râ‚ K\ninstâœÂ¹ : IsFractionRing Râ‚ K\ninstâœ : IsDomain Râ‚\nJ : FractionalIdeal Râ‚â° K\nd : K\nâŠ¢ J / spanSingleton Râ‚â° d = spanSingleton Râ‚â° dâ»Â¹ * J"
    },
    {
      "name": "FractionalIdeal.map_coeIdeal",
      "statement": "R : Type u_1\ninstâœâ¶ : CommRing R\nS : Submonoid R\nP : Type u_2\ninstâœâµ : CommRing P\ninstâœâ´ : Algebra R P\nloc : IsLocalization S P\nP' : Type u_3\ninstâœÂ³ : CommRing P'\ninstâœÂ² : Algebra R P'\nloc' : IsLocalization S P'\nP'' : Type u_4\ninstâœÂ¹ : CommRing P''\ninstâœ : Algebra R P''\nloc'' : IsLocalization S P''\nIâœ J : FractionalIdeal S P\ng : P â†’â‚[R] P'\nI : Ideal R\nâŠ¢ map g â†‘I = â†‘I"
    },
    {
      "name": "FractionalIdeal.map_div",
      "statement": "R : Type u_1\ninstâœâ¹ : CommRing R\nS : Submonoid R\nP : Type u_2\ninstâœâ¸ : CommRing P\ninstâœâ· : Algebra R P\nloc : IsLocalization S P\nRâ‚ : Type u_3\ninstâœâ¶ : CommRing Râ‚\nK : Type u_4\ninstâœâµ : Field K\ninstâœâ´ : Algebra Râ‚ K\nfrac : IsFractionRing Râ‚ K\ninstâœÂ³ : IsDomain Râ‚\nIâœ Jâœ : FractionalIdeal Râ‚â° K\nK' : Type u_5\ninstâœÂ² : Field K'\ninstâœÂ¹ : Algebra Râ‚ K'\ninstâœ : IsFractionRing Râ‚ K'\nI J : FractionalIdeal Râ‚â° K\nh : K â‰ƒâ‚[Râ‚] K'\nâŠ¢ map (â†‘h) (I / J) = map (â†‘h) I / map (â†‘h) J"
    },
    {
      "name": "FractionalIdeal.map_map_symm",
      "statement": "R : Type u_1\ninstâœâ¶ : CommRing R\nS : Submonoid R\nP : Type u_2\ninstâœâµ : CommRing P\ninstâœâ´ : Algebra R P\nloc : IsLocalization S P\nP' : Type u_3\ninstâœÂ³ : CommRing P'\ninstâœÂ² : Algebra R P'\nloc' : IsLocalization S P'\nP'' : Type u_4\ninstâœÂ¹ : CommRing P''\ninstâœ : Algebra R P''\nloc'' : IsLocalization S P''\nI J : FractionalIdeal S P\ngâœ : P â†’â‚[R] P'\ng : P â‰ƒâ‚[R] P'\nâŠ¢ map (â†‘g.symm) (map (â†‘g) I) = I"
    },
    {
      "name": "FractionalIdeal.right_inverse_eq",
      "statement": "R : Type u_1\nA : Type u_2\nK : Type u_3\ninstâœâ¶ : CommRing R\ninstâœâµ : CommRing A\ninstâœâ´ : Field K\nRâ‚ : Type u_4\ninstâœÂ³ : CommRing Râ‚\ninstâœÂ² : IsDomain Râ‚\ninstâœÂ¹ : Algebra Râ‚ K\ninstâœ : IsFractionRing Râ‚ K\nIâœ Jâœ I J : FractionalIdeal Râ‚â° K\nh : I * J = 1\nâŠ¢ J = Iâ»Â¹"
    },
    {
      "name": "FractionalIdeal.spanSingleton_pow",
      "statement": "R : Type u_1\ninstâœâ¶ : CommRing R\nS : Submonoid R\nP : Type u_2\ninstâœâµ : CommRing P\ninstâœâ´ : Algebra R P\nloc : IsLocalization S P\nRâ‚ : Type u_3\ninstâœÂ³ : CommRing Râ‚\nK : Type u_4\ninstâœÂ² : Field K\ninstâœÂ¹ : Algebra Râ‚ K\ninstâœ : IsFractionRing Râ‚ K\nx : P\nn : â„•\nâŠ¢ spanSingleton S x ^ n = spanSingleton S (x ^ n)"
    },
    {
      "name": "FractionalIdeal.zero_le",
      "statement": "R : Type u_1\ninstâœÂ² : CommRing R\nS : Submonoid R\nP : Type u_2\ninstâœÂ¹ : CommRing P\ninstâœ : Algebra R P\nloc : IsLocalization S P\nI : FractionalIdeal S P\nâŠ¢ 0 â‰¤ I"
    },
    {
      "name": "FreeAbelianGroup.support_neg",
      "statement": "X : Type u_1\na : FreeAbelianGroup X\nâŠ¢ (-a).support = a.support"
    },
    {
      "name": "FreeAbelianGroup.support_zsmul",
      "statement": "X : Type u_1\nk : â„¤\nh : k â‰  0\na : FreeAbelianGroup X\nâŠ¢ (k â€¢ a).support = a.support"
    },
    {
      "name": "FreeAbelianGroup.toFinsupp_comp_toFreeAbelianGroup",
      "statement": "X : Type u_1\nâŠ¢ toFinsupp.comp toFreeAbelianGroup = AddMonoidHom.id (X â†’â‚€ â„¤)"
    },
    {
      "name": "FreeAbelianGroup.toFinsupp_toFreeAbelianGroup",
      "statement": "X : Type u_1\nf : X â†’â‚€ â„¤\nâŠ¢ toFinsupp (toFreeAbelianGroup f) = f"
    },
    {
      "name": "FreeAlgebra.adjoin_range_Î¹",
      "statement": "R : Type u_1\ninstâœ : CommSemiring R\nX : Type u_2\nâŠ¢ Algebra.adjoin R (Set.range (Î¹ R)) = âŠ¤"
    },
    {
      "name": "FreeAlgebra.toTensor_Î¹",
      "statement": "R : Type u_1\ninstâœÂ² : CommSemiring R\nM : Type u_2\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : Module R M\nm : M\nâŠ¢ toTensor (Î¹ R m) = (TensorAlgebra.Î¹ R) m"
    },
    {
      "name": "FreeAlgebra.Î¹_comp_lift",
      "statement": "R : Type u_1\ninstâœÂ² : CommSemiring R\nX : Type u_2\nA : Type u_3\ninstâœÂ¹ : Semiring A\ninstâœ : Algebra R A\nf : X â†’ A\nâŠ¢ â‡‘((lift R) f) âˆ˜ Î¹ R = f"
    },
    {
      "name": "FreeGroup.invRev_length",
      "statement": "Î± : Type u\nL Lâ‚ Lâ‚‚ Lâ‚ƒ Lâ‚„ : List (Î± Ã— Bool)\nâŠ¢ (invRev Lâ‚).length = Lâ‚.length"
    },
    {
      "name": "FreeMagma.length_toFreeSemigroup",
      "statement": "Î± : Type u\nÎ² : Type v\nxâœ x y : FreeMagma Î±\nhx : (toFreeSemigroup x).length = x.length\nhy : (toFreeSemigroup y).length = y.length\nâŠ¢ (toFreeSemigroup (x * y)).length = (x * y).length"
    },
    {
      "name": "Function.HasTemperateGrowth.of_fderiv",
      "statement": "ğ•œ : Type u_1\nğ•œ' : Type u_2\nD : Type u_3\nE : Type u_4\nF : Type u_5\nG : Type u_6\nV : Type u_7\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace â„ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace â„ F\nf : E â†’ F\nh'f : Function.HasTemperateGrowth (fderiv â„ f)\nhf : Differentiable â„ f\nk : â„•\nC : â„\nh : âˆ€ (x : E), â€–f xâ€– â‰¤ C * (1 + â€–xâ€–) ^ k\nâŠ¢ Function.HasTemperateGrowth f"
    },
    {
      "name": "Function.HasTemperateGrowth.zero",
      "statement": "ğ•œ : Type u_1\nğ•œ' : Type u_2\nD : Type u_3\nE : Type u_4\nF : Type u_5\nG : Type u_6\nV : Type u_7\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace â„ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace â„ F\nâŠ¢ Function.HasTemperateGrowth fun x => 0"
    },
    {
      "name": "Function.Injective.preimage_surjective",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ¹ : Sort u_3\nf : Î± â†’ Î²\nhf : Injective f\nâŠ¢ Surjective (preimage f)"
    },
    {
      "name": "Function.IsFixedPt.apply",
      "statement": "Î± : Type u\nÎ² : Type v\nf fa g : Î± â†’ Î±\nxâœ y : Î±\nfb : Î² â†’ Î²\nm n k : â„•\ne : Perm Î±\nx : Î±\nhx : IsFixedPt f x\nâŠ¢ IsFixedPt f (f x)"
    },
    {
      "name": "Function.Periodic.smul",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nf g : Î± â†’ Î²\nc câ‚ câ‚‚ x : Î±\ninstâœÂ¹ : Add Î±\ninstâœ : SMul Î³ Î²\nh : Periodic f c\na : Î³\nâŠ¢ Periodic (a â€¢ f) c"
    },
    {
      "name": "Function.iterate_id",
      "statement": "Î± : Type u\nÎ² : Type v\nf : Î± â†’ Î±\nnâœ n : â„•\nihn : id^[n] = id\nâŠ¢ id^[n.succ] = id"
    },
    {
      "name": "Function.minimalPeriod_eq_one_iff_isFixedPt",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nf fa : Î± â†’ Î±\nfb : Î² â†’ Î²\nx y : Î±\nm n : â„•\nâŠ¢ minimalPeriod f x = 1 â†” IsFixedPt f x"
    },
    {
      "name": "Function.periodicOrbit_eq_nil_iff_not_periodic_pt",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nf fa : Î± â†’ Î±\nfb : Î² â†’ Î²\nx y : Î±\nm n : â„•\nâŠ¢ periodicOrbit f x = Cycle.nil â†” x âˆ‰ periodicPts f"
    },
    {
      "name": "Function.update_idem",
      "statement": "Î±âœ : Sort u\nÎ²âœ : Î±âœ â†’ Sort v\nÎ±' : Sort w\ninstâœÂ² : DecidableEq Î±âœ\ninstâœÂ¹ : DecidableEq Î±'\nfâœ g : (a : Î±âœ) â†’ Î²âœ a\naâœ : Î±âœ\nb : Î²âœ aâœ\nÎ± : Sort u_2\ninstâœ : DecidableEq Î±\nÎ² : Î± â†’ Sort u_1\na : Î±\nv w : Î² a\nf : (a : Î±) â†’ Î² a\nâŠ¢ update (update f a v) a w = update f a w"
    },
    {
      "name": "GaussianInt.intCast_complex_norm",
      "statement": "x : â„¤[i]\nâŠ¢ â†‘(norm x) = â†‘(normSq (toComplex x))"
    },
    {
      "name": "GaussianInt.natCast_natAbs_norm",
      "statement": "Î± : Type u_1\ninstâœ : Ring Î±\nx : â„¤[i]\nâŠ¢ â†‘(norm x).natAbs = â†‘(norm x)"
    },
    {
      "name": "GaussianInt.toComplex_inj",
      "statement": "x y : â„¤[i]\nâŠ¢ toComplex x = toComplex y â†” x = y"
    },
    {
      "name": "GaussianInt.toComplex_star",
      "statement": "x : â„¤[i]\nâŠ¢ toComplex (star x) = (starRingEnd â„‚) (toComplex x)"
    },
    {
      "name": "GradedRing.proj_recompose",
      "statement": "Î¹ : Type u_1\nR : Type u_2\nA : Type u_3\nÏƒ : Type u_4\ninstâœâ· : DecidableEq Î¹\ninstâœâ¶ : AddMonoid Î¹\ninstâœâµ : CommSemiring R\ninstâœâ´ : Semiring A\ninstâœÂ³ : Algebra R A\ninstâœÂ² : SetLike Ïƒ A\ninstâœÂ¹ : AddSubmonoidClass Ïƒ A\nğ’œ : Î¹ â†’ Ïƒ\ninstâœ : GradedRing ğ’œ\na : â¨ (i : Î¹), â†¥(ğ’œ i)\ni : Î¹\nâŠ¢ (proj ğ’œ i) ((decompose ğ’œ).symm a) = (decompose ğ’œ).symm ((of (fun i => â†¥(ğ’œ i)) i) (a i))"
    },
    {
      "name": "GroupAlgebra.mul_average_left",
      "statement": "k : Type u_1\nG : Type u_2\ninstâœÂ³ : CommSemiring k\ninstâœÂ² : Group G\ninstâœÂ¹ : Fintype G\ninstâœ : Invertible â†‘(Fintype.card G)\ng : G\nâŠ¢ Finsupp.single g 1 * average k G = average k G"
    },
    {
      "name": "HNNExtension.toSubgroupEquiv_neg_apply",
      "statement": "G : Type u_1\ninstâœÂ² : Group G\nA B : Subgroup G\nÏ† : â†¥A â‰ƒ* â†¥B\nH : Type u_2\ninstâœÂ¹ : Group H\nM : Type u_3\ninstâœ : Monoid M\nu : â„¤Ë£\na : â†¥(toSubgroup A B u)\nâŠ¢ â†‘((toSubgroupEquiv Ï† (-u)) ((toSubgroupEquiv Ï† u) a)) = â†‘a"
    },
    {
      "name": "HahnSeries.SummableFamily.hsum_add",
      "statement": "Î“ : Type u_1\nR : Type u_2\ninstâœÂ¹ : PartialOrder Î“\ninstâœ : AddCommMonoid R\nÎ± : Type u_3\ns t : SummableFamily Î“ R Î±\nâŠ¢ (s + t).hsum = s.hsum + t.hsum"
    },
    {
      "name": "HahnSeries.single_pow",
      "statement": "Î“ : Type u_1\nÎ“' : Type u_2\nR : Type u_3\ninstâœÂ¹ : OrderedCancelAddCommMonoid Î“\ninstâœ : Semiring R\na : Î“\nn : â„•\nr : R\nâŠ¢ (single a) r ^ n = (single (n â€¢ a)) (r ^ n)"
    },
    {
      "name": "HasLineDerivWithinAt.smul",
      "statement": "ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nF : Type u_2\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nE : Type u_3\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nf : E â†’ F\ns : Set E\nx v : E\nf' : F\nh : HasLineDerivWithinAt ğ•œ f f' s x v\nc : ğ•œ\nâŠ¢ HasLineDerivWithinAt ğ•œ f (c â€¢ f') s x (c â€¢ v)"
    },
    {
      "name": "HilbertBasis.orthonormal",
      "statement": "Î¹ : Type u_1\nğ•œ : Type u_2\ninstâœâ´ : RCLike ğ•œ\nE : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\ncplt : CompleteSpace E\nG : Î¹ â†’ Type u_4\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (G i)\ninstâœ : (i : Î¹) â†’ InnerProductSpace ğ•œ (G i)\nb : HilbertBasis Î¹ ğ•œ E\nâŠ¢ Orthonormal ğ•œ fun i => b.repr.symm (lp.single 2 i 1)"
    },
    {
      "name": "Homeomorph.comp_isOpenMap_iff",
      "statement": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninstâœâ´ : TopologicalSpace X\ninstâœÂ³ : TopologicalSpace Y\ninstâœÂ² : TopologicalSpace Z\nX' : Type u_4\nY' : Type u_5\ninstâœÂ¹ : TopologicalSpace X'\ninstâœ : TopologicalSpace Y'\nh : X â‰ƒâ‚œ Y\nf : Z â†’ X\nâŠ¢ IsOpenMap (â‡‘h âˆ˜ f) â†” IsOpenMap f"
    },
    {
      "name": "Homeomorph.comp_isOpenMap_iff'",
      "statement": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninstâœâ´ : TopologicalSpace X\ninstâœÂ³ : TopologicalSpace Y\ninstâœÂ² : TopologicalSpace Z\nX' : Type u_4\nY' : Type u_5\ninstâœÂ¹ : TopologicalSpace X'\ninstâœ : TopologicalSpace Y'\nh : X â‰ƒâ‚œ Y\nf : Y â†’ Z\nâŠ¢ IsOpenMap (f âˆ˜ â‡‘h) â†” IsOpenMap f"
    },
    {
      "name": "HomogeneousIdeal.toIdeal_iSup",
      "statement": "Î¹ : Type u_1\nÏƒ : Type u_2\nR : Type u_3\nA : Type u_4\ninstâœâµ : Semiring A\ninstâœâ´ : DecidableEq Î¹\ninstâœÂ³ : AddMonoid Î¹\ninstâœÂ² : SetLike Ïƒ A\ninstâœÂ¹ : AddSubmonoidClass Ïƒ A\nğ’œ : Î¹ â†’ Ïƒ\ninstâœ : GradedRing ğ’œ\nÎº : Sort u_5\ns : Îº â†’ HomogeneousIdeal ğ’œ\nâŠ¢ (â¨† i, s i).toIdeal = â¨† i, (s i).toIdeal"
    },
    {
      "name": "HomogeneousIdeal.toIdeal_iSupâ‚‚",
      "statement": "Î¹ : Type u_1\nÏƒ : Type u_2\nR : Type u_3\nA : Type u_4\ninstâœâµ : Semiring A\ninstâœâ´ : DecidableEq Î¹\ninstâœÂ³ : AddMonoid Î¹\ninstâœÂ² : SetLike Ïƒ A\ninstâœÂ¹ : AddSubmonoidClass Ïƒ A\nğ’œ : Î¹ â†’ Ïƒ\ninstâœ : GradedRing ğ’œ\nÎº : Sort u_5\nÎº' : Îº â†’ Sort u_6\ns : (i : Îº) â†’ Îº' i â†’ HomogeneousIdeal ğ’œ\nâŠ¢ (â¨† i, â¨† j, s i j).toIdeal = â¨† i, â¨† j, (s i j).toIdeal"
    },
    {
      "name": "HomogeneousLocalization.val_add",
      "statement": "Î¹ : Type u_1\nR : Type u_2\nA : Type u_3\ninstâœâµ : AddCommMonoid Î¹\ninstâœâ´ : DecidableEq Î¹\ninstâœÂ³ : CommRing R\ninstâœÂ² : CommRing A\ninstâœÂ¹ : Algebra R A\nğ’œ : Î¹ â†’ Submodule R A\ninstâœ : GradedAlgebra ğ’œ\nx : Submonoid A\ny1 y2 : NumDenSameDeg ğ’œ x\nâŠ¢ (Quotient.mk'' y1 + Quotient.mk'' y2).val = val (Quotient.mk'' y1) + val (Quotient.mk'' y2)"
    },
    {
      "name": "HomogeneousLocalization.val_sub",
      "statement": "Î¹ : Type u_1\nR : Type u_2\nA : Type u_3\ninstâœâµ : AddCommMonoid Î¹\ninstâœâ´ : DecidableEq Î¹\ninstâœÂ³ : CommRing R\ninstâœÂ² : CommRing A\ninstâœÂ¹ : Algebra R A\nğ’œ : Î¹ â†’ Submodule R A\ninstâœ : GradedAlgebra ğ’œ\nx : Submonoid A\ny1 y2 : HomogeneousLocalization ğ’œ x\nâŠ¢ (y1 - y2).val = y1.val - y2.val"
    },
    {
      "name": "HomologicalComplex.XIsoOfEq_hom_comp_XIsoOfEq_inv",
      "statement": "Î¹ : Type u_1\nV : Type u\ninstâœÂ¹ : Category.{v, u} V\ninstâœ : HasZeroMorphisms V\nc : ComplexShape Î¹\nK : HomologicalComplex V c\npâ‚ pâ‚‚ pâ‚ƒ : Î¹\nhâ‚â‚‚ : pâ‚ = pâ‚‚\nhâ‚ƒâ‚‚ : pâ‚ƒ = pâ‚‚\nâŠ¢ (K.XIsoOfEq hâ‚â‚‚).hom â‰« (K.XIsoOfEq hâ‚ƒâ‚‚).inv = (K.XIsoOfEq â‹¯).hom"
    },
    {
      "name": "HomologicalComplex.boundaries_eq_bot",
      "statement": "Î¹ : Type u_1\nV : Type u\ninstâœÂ³ : Category.{v, u} V\ninstâœÂ² : HasZeroMorphisms V\nc : ComplexShape Î¹\nC : HomologicalComplex V c\ninstâœÂ¹ : HasImages V\ninstâœ : HasZeroObject V\nj : Î¹\nh : Â¬c.Rel (c.prev j) j\nâŠ¢ C.boundaries j = âŠ¥"
    },
    {
      "name": "HomologicalComplex.cylinder.Î¹â‚_desc",
      "statement": "C : Type u_1\ninstâœâµ : Category.{u_3, u_1} C\ninstâœâ´ : Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nF G K : HomologicalComplex C c\nÏ† : F âŸ¶ G\ninstâœÂ³ : HasHomotopyCofiber Ï†\ninstâœÂ² : DecidableRel c.Rel\ninstâœÂ¹ : âˆ€ (i : Î¹), HasBinaryBiproduct (K.X i) (K.X i)\ninstâœ : HasHomotopyCofiber (biprod.lift (ğŸ™ K) (-ğŸ™ K))\nÏ†â‚€ Ï†â‚ : K âŸ¶ F\nh : Homotopy Ï†â‚€ Ï†â‚\nâŠ¢ Î¹â‚ K â‰« desc Ï†â‚€ Ï†â‚ h = Ï†â‚"
    },
    {
      "name": "HomologicalComplex.d_pOpcycles",
      "statement": "C : Type u_1\ninstâœÂ³ : Category.{u_3, u_1} C\ninstâœÂ² : HasZeroMorphisms C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nK L M : HomologicalComplex C c\nÏ† : K âŸ¶ L\nÏˆ : L âŸ¶ M\ni j k : Î¹\ninstâœÂ¹ : K.HasHomology i\ninstâœ : K.HasHomology j\nâŠ¢ K.d i j â‰« K.pOpcycles j = 0"
    },
    {
      "name": "HomologicalComplex.ext",
      "statement": "Î¹ : Type u_1\nV : Type u\ninstâœÂ¹ : Category.{v, u} V\ninstâœ : HasZeroMorphisms V\nc : ComplexShape Î¹\nCâ‚ Câ‚‚ : HomologicalComplex V c\nh_X : Câ‚.X = Câ‚‚.X\nh_d : âˆ€ (i j : Î¹), c.Rel i j â†’ Câ‚.d i j â‰« eqToHom â‹¯ = eqToHom â‹¯ â‰« Câ‚‚.d i j\nâŠ¢ Câ‚ = Câ‚‚"
    },
    {
      "name": "HomologicalComplex.homotopyCofiber.inlX_sndX",
      "statement": "C : Type u_1\ninstâœÂ³ : Category.{u_3, u_1} C\ninstâœÂ² : Preadditive C\nÎ¹ : Type u_2\nc : ComplexShape Î¹\nF G K : HomologicalComplex C c\nÏ† : F âŸ¶ G\ninstâœÂ¹ : HasHomotopyCofiber Ï†\ninstâœ : DecidableRel c.Rel\ni j : Î¹\nhij : c.Rel j i\nâŠ¢ inlX Ï† i j hij â‰« sndX Ï† j = 0"
    },
    {
      "name": "HomologicalComplex.opcyclesToCycles_iCycles",
      "statement": "C : Type u_1\nÎ¹ : Type u_2\ninstâœâµ : Category.{u_3, u_1} C\ninstâœâ´ : HasZeroMorphisms C\nc : ComplexShape Î¹\nK L : HomologicalComplex C c\nÏ† : K âŸ¶ L\ni j : Î¹\ninstâœÂ³ : K.HasHomology i\ninstâœÂ² : K.HasHomology j\ninstâœÂ¹ : L.HasHomology i\ninstâœ : L.HasHomology j\nâŠ¢ K.opcyclesToCycles i j â‰« K.iCycles j = K.fromOpcycles i j"
    },
    {
      "name": "HomologicalComplexâ‚‚.Dâ‚_Dâ‚‚",
      "statement": "C : Type u_1\ninstâœâ´ : Category.{u_5, u_1} C\ninstâœÂ³ : Preadditive C\nIâ‚ : Type u_2\nIâ‚‚ : Type u_3\nIâ‚â‚‚ : Type u_4\ncâ‚ : ComplexShape Iâ‚\ncâ‚‚ : ComplexShape Iâ‚‚\nK L M : HomologicalComplexâ‚‚ C câ‚ câ‚‚\nÏ† : K âŸ¶ L\ne : K â‰… L\nÏˆ : L âŸ¶ M\ncâ‚â‚‚ : ComplexShape Iâ‚â‚‚\ninstâœÂ² : DecidableEq Iâ‚â‚‚\ninstâœÂ¹ : TotalComplexShape câ‚ câ‚‚ câ‚â‚‚\ninstâœ : K.HasTotal câ‚â‚‚\niâ‚â‚‚ iâ‚â‚‚' iâ‚â‚‚'' : Iâ‚â‚‚\nâŠ¢ K.Dâ‚ câ‚â‚‚ iâ‚â‚‚ iâ‚â‚‚' â‰« K.Dâ‚‚ câ‚â‚‚ iâ‚â‚‚' iâ‚â‚‚'' = -K.Dâ‚‚ câ‚â‚‚ iâ‚â‚‚ iâ‚â‚‚' â‰« K.Dâ‚ câ‚â‚‚ iâ‚â‚‚' iâ‚â‚‚''"
    },
    {
      "name": "HomologicalComplexâ‚‚.total.mapAux.dâ‚_mapMap",
      "statement": "C : Type u_1\ninstâœâµ : Category.{u_5, u_1} C\ninstâœâ´ : Preadditive C\nIâ‚ : Type u_2\nIâ‚‚ : Type u_3\nIâ‚â‚‚ : Type u_4\ncâ‚ : ComplexShape Iâ‚\ncâ‚‚ : ComplexShape Iâ‚‚\nK L M : HomologicalComplexâ‚‚ C câ‚ câ‚‚\nÏ† : K âŸ¶ L\ne : K â‰… L\nÏˆ : L âŸ¶ M\ncâ‚â‚‚ : ComplexShape Iâ‚â‚‚\ninstâœÂ³ : DecidableEq Iâ‚â‚‚\ninstâœÂ² : TotalComplexShape câ‚ câ‚‚ câ‚â‚‚\ninstâœÂ¹ : K.HasTotal câ‚â‚‚\ninstâœ : L.HasTotal câ‚â‚‚\niâ‚ : Iâ‚\niâ‚‚ : Iâ‚‚\niâ‚â‚‚ : Iâ‚â‚‚\nâŠ¢ K.dâ‚ câ‚â‚‚ iâ‚ iâ‚‚ iâ‚â‚‚ â‰« GradedObject.mapMap (toGradedObjectMap Ï†) (câ‚.Ï€ câ‚‚ câ‚â‚‚) iâ‚â‚‚ = (Ï†.f iâ‚).f iâ‚‚ â‰« L.dâ‚ câ‚â‚‚ iâ‚ iâ‚‚ iâ‚â‚‚"
    },
    {
      "name": "HomologicalComplexâ‚‚.Î¹Total_totalFlipIso_f_inv",
      "statement": "C : Type u_1\nIâ‚ : Type u_2\nIâ‚‚ : Type u_3\nJ : Type u_4\ninstâœâ· : Category.{?u.40369, u_1} C\ninstâœâ¶ : Preadditive C\ncâ‚ : ComplexShape Iâ‚\ncâ‚‚ : ComplexShape Iâ‚‚\nK : HomologicalComplexâ‚‚ C câ‚ câ‚‚\nc : ComplexShape J\ninstâœâµ : TotalComplexShape câ‚ câ‚‚ c\ninstâœâ´ : TotalComplexShape câ‚‚ câ‚ c\ninstâœÂ³ : TotalComplexShapeSymmetry câ‚ câ‚‚ c\ninstâœÂ² : K.HasTotal c\ninstâœÂ¹ : K.flip.HasTotal c\ninstâœ : DecidableEq J\niâ‚ : Iâ‚\niâ‚‚ : Iâ‚‚\nj : J\nh : câ‚.Ï€ câ‚‚ c (iâ‚, iâ‚‚) = j\nâŠ¢ câ‚‚.Ï€ câ‚ c (iâ‚‚, iâ‚) = j"
    },
    {
      "name": "Hyperreal.st_inv",
      "statement": "x : â„*\nâŠ¢ xâ»Â¹.st = x.stâ»Â¹"
    },
    {
      "name": "Ideal.Quotient.factor_comp_mk",
      "statement": "R : Type u\ninstâœÂ¹ : CommRing R\nI : Ideal R\na b : R\nSâœ : Type v\nx y : R\ninstâœ : Semiring Sâœ\nS T : Ideal R\nH : S â‰¤ T\nâŠ¢ (factor S T H).comp (mk S) = mk T"
    },
    {
      "name": "Ideal.isPrime_of_prime",
      "statement": "R : Type u_1\nA : Type u_2\nK : Type u_3\ninstâœâµ : CommRing R\ninstâœâ´ : CommRing A\ninstâœÂ³ : Field K\ninstâœÂ² : IsDedekindDomain A\ninstâœÂ¹ : Algebra A K\ninstâœ : IsFractionRing A K\nP : Ideal A\nh : Prime P\nâŠ¢ P.IsPrime"
    },
    {
      "name": "Ideal.isUnit_iff",
      "statement": "R : Type u\nÎ¹ : Type u_1\ninstâœ : CommSemiring R\nIâœ J K L I : Ideal R\nh : I = âŠ¤\nâŠ¢ âŠ¤ = I * âŠ¤"
    },
    {
      "name": "Ideal.map_snd_prod",
      "statement": "R : Type u\nS : Type v\ninstâœÂ¹ : Semiring R\ninstâœ : Semiring S\nIâœ I' : Ideal R\nJâœ J' : Ideal S\nI : Ideal R\nJ : Ideal S\nâŠ¢ map (RingHom.snd R S) (I.prod J) = J"
    },
    {
      "name": "Ideal.mem_colon_singleton",
      "statement": "R : Type u_1\nM : Type u_2\nM' : Type u_3\nF : Type u_4\nG : Type u_5\ninstâœÂ² : CommRing R\ninstâœÂ¹ : AddCommGroup M\ninstâœ : Module R M\nN Nâ‚ Nâ‚‚ P Pâ‚ Pâ‚‚ : Submodule R M\nI : Ideal R\nx r : R\nâŠ¢ r âˆˆ colon I (Ideal.span {x}) â†” r * x âˆˆ I"
    },
    {
      "name": "Ideal.span_pair_add_mul_left",
      "statement": "Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : Semiring Î±\nI : Ideal Î±\na b : Î±\nR : Type u\ninstâœ : CommRing R\nx y z : R\nâŠ¢ span {x + y * z, y} = span {x, y}"
    },
    {
      "name": "Ideal.sup_mul_inf",
      "statement": "R : Type u_1\nA : Type u_2\nK : Type u_3\ninstâœâµ : CommRing R\ninstâœâ´ : CommRing A\ninstâœÂ³ : Field K\ninstâœÂ² : IsDedekindDomain A\ninstâœÂ¹ : Algebra A K\ninstâœ : IsFractionRing A K\nI J : Ideal A\nâŠ¢ (I âŠ” J) * (I âŠ“ J) = I * J"
    },
    {
      "name": "IndepMatroid.ofFinset_indep'",
      "statement": "Î± : Type u_1\nIâœ B X : Set Î±\ninstâœ : DecidableEq Î±\nE : Set Î±\nIndep : Finset Î± â†’ Prop\nindep_empty : Indep âˆ…\nindep_subset : âˆ€ â¦ƒI J : Finset Î±â¦„, Indep J â†’ I âŠ† J â†’ Indep I\nindep_aug : âˆ€ â¦ƒI J : Finset Î±â¦„, Indep I â†’ Indep J â†’ I.card < J.card â†’ âˆƒ e âˆˆ J, e âˆ‰ I âˆ§ Indep (insert e I)\nsubset_ground : âˆ€ â¦ƒI : Finset Î±â¦„, Indep I â†’ â†‘I âŠ† E\nI : Set Î±\nâŠ¢ (IndepMatroid.ofFinset E Indep indep_empty indep_subset indep_aug subset_ground).Indep I â†”\n    âˆ€ (J : Finset Î±), â†‘J âŠ† I â†’ Indep J"
    },
    {
      "name": "Int.bitwise_bit",
      "statement": "f : Bool â†’ Bool â†’ Bool\na : Bool\nm : â„¤\nb : Bool\nn : â„¤\nâŠ¢ bitwise f (bit a m) (bit b n) = bit (f a b) (bitwise f m n)"
    },
    {
      "name": "Int.cast_eq_zero",
      "statement": "F : Type u_1\nÎ¹ : Type u_2\nÎ± : Type u_3\nÎ² : Type u_4\ninstâœÂ¹ : AddGroupWithOne Î±\ninstâœ : CharZero Î±\nm n : â„¤\nh : â†‘n = 0\nâŠ¢ n = 0"
    },
    {
      "name": "Int.cast_mul",
      "statement": "Î± : Type u_1\ninstâœ : NonAssocRing Î±\nm : â„¤\nâŠ¢ âˆ€ (n : â„¤), â†‘(m * n) = â†‘m * â†‘n"
    },
    {
      "name": "Int.cast_natAbs",
      "statement": "R : Type u_1\ninstâœ : LinearOrderedRing R\na b n : â„¤\nx : R\nâŠ¢ â†‘n.natAbs = â†‘|n|"
    },
    {
      "name": "Int.coe_leastOfBdd_eq",
      "statement": "P : â„¤ â†’ Prop\ninstâœ : DecidablePred P\nb b' : â„¤\nHb : âˆ€ (z : â„¤), P z â†’ b â‰¤ z\nHb' : âˆ€ (z : â„¤), P z â†’ b' â‰¤ z\nHinh : âˆƒ z, P z\nâŠ¢ â†‘(b.leastOfBdd Hb Hinh) = â†‘(b'.leastOfBdd Hb' Hinh)"
    },
    {
      "name": "Int.existsUnique_mem_box",
      "statement": "n : â„•\nxâœ x : â„¤ Ã— â„¤\nâŠ¢ âˆƒ! n, x âˆˆ box n"
    },
    {
      "name": "Int.gcd_a_modEq",
      "statement": "m n aâœ bâœ c d : â„¤\na b : â„•\nâŠ¢ â†‘a * a.gcdA b â‰¡ â†‘(a.gcd b) [ZMOD â†‘b]"
    },
    {
      "name": "Int.gcd_zero_right",
      "statement": "i : â„¤\nâŠ¢ i.gcd 0 = i.natAbs"
    },
    {
      "name": "Int.le_add_one_iff",
      "statement": "a b c d m n : â„¤\nâŠ¢ m â‰¤ n + 1 â†” m â‰¤ n âˆ¨ m = n + 1"
    },
    {
      "name": "Int.le_iff_eq_or_lt",
      "statement": "aâœ bâœ câœ d m n a b c : â„¤\nâŠ¢ a â‰¤ b â†” a = b âˆ¨ a < b"
    },
    {
      "name": "Int.lt_toNat",
      "statement": "a b c d mâœ n : â„¤\nm : â„•\nâŠ¢ m < n.toNat â†” â†‘m < n"
    },
    {
      "name": "Int.lxor_bit",
      "statement": "a : Bool\nm : â„¤\nb : Bool\nn : â„¤\nâŠ¢ (bit a m).xor (bit b n) = bit (xor a b) (m.xor n)"
    },
    {
      "name": "Int.natAbs_pow",
      "statement": "a b c d m nâœ n : â„¤\nk : â„•\nâŠ¢ (n ^ k).natAbs = n.natAbs ^ k"
    },
    {
      "name": "Int.negOnePow_mul_self",
      "statement": "n : â„¤\nâŠ¢ (n * n).negOnePow = n.negOnePow"
    },
    {
      "name": "Int.preimage_Ici",
      "statement": "F : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : LinearOrderedRing Î±\ninstâœ : FloorRing Î±\nz : â„¤\na : Î±\nâŠ¢ Int.cast â»Â¹' Ici a = Ici âŒˆaâŒ‰"
    },
    {
      "name": "Int.preimage_Iic",
      "statement": "F : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : LinearOrderedRing Î±\ninstâœ : FloorRing Î±\nz : â„¤\na : Î±\nâŠ¢ Int.cast â»Â¹' Iic a = Iic âŒŠaâŒ‹"
    },
    {
      "name": "Int.preimage_Ioc",
      "statement": "F : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : LinearOrderedRing Î±\ninstâœ : FloorRing Î±\nz : â„¤\naâœ a b : Î±\nâŠ¢ Int.cast â»Â¹' Ioc a b = Ioc âŒŠaâŒ‹ âŒŠbâŒ‹"
    },
    {
      "name": "Int.shiftRight_neg",
      "statement": "m n : â„¤\nâŠ¢ m >>> (-n) = m <<< n"
    },
    {
      "name": "Int.testBit_lxor",
      "statement": "m n : â„¤\nk : â„•\nâŠ¢ (m.xor n).testBit k = xor (m.testBit k) (n.testBit k)"
    },
    {
      "name": "Int.toNat_add_toNat_neg_eq_nnnorm",
      "statement": "n : â„¤\nâŠ¢ â†‘n.toNat + â†‘(-n).toNat = â€–nâ€–â‚Š"
    },
    {
      "name": "Int.two_mul",
      "statement": "a b c d m nâœ : â„¤\nn : â„•\nâŠ¢ 2 * â†‘n = â†‘n + â†‘n"
    },
    {
      "name": "Int.units_ne_iff_eq_neg",
      "statement": "u v : â„¤Ë£\nâŠ¢ u â‰  v â†” u = -v"
    },
    {
      "name": "IntermediateField.AdjoinSimple.isIntegral_gen",
      "statement": "F : Type u_1\ninstâœÂ² : Field F\nE : Type u_2\ninstâœÂ¹ : Field E\ninstâœ : Algebra F E\nS : Set E\nÎ± : E\nâŠ¢ IsIntegral F (gen F Î±) â†” IsIntegral F Î±"
    },
    {
      "name": "IntermediateField.finInsepDegree_bot",
      "statement": "F : Type u\nE : Type v\ninstâœâ´ : Field F\ninstâœÂ³ : Field E\ninstâœÂ² : Algebra F E\nK : Type w\ninstâœÂ¹ : Field K\ninstâœ : Algebra F K\nâŠ¢ finInsepDegree F â†¥âŠ¥ = 1"
    },
    {
      "name": "IntermediateField.sInf_toSubalgebra",
      "statement": "F : Type u_1\ninstâœÂ² : Field F\nE : Type u_2\ninstâœÂ¹ : Field E\ninstâœ : Algebra F E\nS : Set (IntermediateField F E)\nâŠ¢ â†‘(sInf S).toSubalgebra = â†‘(sInf (toSubalgebra '' S))"
    },
    {
      "name": "Interval.coe_inf",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\nÎ¹ : Sort u_5\nÎº : Î¹ â†’ Sort u_6\ninstâœÂ¹ : Lattice Î±\ninstâœ : DecidableRel fun x x_1 => x â‰¤ x_1\nxâœ : Interval Î±\nâŠ¢ â†‘(âŠ¥ âŠ“ xâœ) = â†‘âŠ¥ âˆ© â†‘xâœ"
    },
    {
      "name": "Interval.dual_map",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\nÎ¹ : Sort u_5\nÎº : Î¹ â†’ Sort u_6\ninstâœÂ² : Preorder Î±\ninstâœÂ¹ : Preorder Î²\ninstâœ : Preorder Î³\nf : Î± â†’o Î²\ns : Interval Î±\nâŠ¢ dual (map f s) = map (OrderHom.dual f) (dual s)"
    },
    {
      "name": "Irrational.neg",
      "statement": "q : â„š\nx y : â„\nh : Irrational x\nâŠ¢ Irrational (- -x)"
    },
    {
      "name": "Irrational.of_one_div",
      "statement": "q : â„š\nx y : â„\nh : Irrational (1 / x)\nâŠ¢ Irrational (â†‘1 / x)"
    },
    {
      "name": "IsAdjoinRoot.aequiv_map",
      "statement": "R : Type u\nS : Type v\ninstâœâ´ : CommRing R\ninstâœÂ³ : CommRing S\ninstâœÂ² : Algebra R S\nf : R[X]\nT : Type u_1\ninstâœÂ¹ : CommRing T\ninstâœ : Algebra R T\nh : IsAdjoinRoot S f\nh' : IsAdjoinRoot T f\nz : R[X]\nâŠ¢ (h.aequiv h') (h.map z) = h'.map z"
    },
    {
      "name": "IsBezout.iff_span_pair_isPrincipal",
      "statement": "R : Type u\ninstâœ : CommRing R\nâŠ¢ IsBezout R â†” âˆ€ (x y : R), Submodule.IsPrincipal (Ideal.span {x, y})"
    },
    {
      "name": "IsCauSeq.cauchyâ‚‚",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : LinearOrderedField Î±\ninstâœÂ¹ : Ring Î²\nabv : Î² â†’ Î±\ninstâœ : IsAbsoluteValue abv\nf g : â„• â†’ Î²\nhf : IsCauSeq abv f\nÎµ : Î±\nÎµ0 : 0 < Îµ\nâŠ¢ âˆƒ i, âˆ€ j â‰¥ i, âˆ€ k â‰¥ i, abv (f j - f k) < Îµ"
    },
    {
      "name": "IsCompact.union",
      "statement": "X : Type u\nY : Type v\nÎ¹ : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\ns t : Set X\nhs : IsCompact s\nht : IsCompact t\nâŠ¢ IsCompact (s âˆª t)"
    },
    {
      "name": "IsCyclotomicExtension.finite_of_singleton",
      "statement": "n : â„•+\nS T : Set â„•+\nA : Type u\nB : Type v\nK : Type w\nL : Type z\ninstâœâ¶ : CommRing A\ninstâœâµ : CommRing B\ninstâœâ´ : Algebra A B\ninstâœÂ³ : Field K\ninstâœÂ² : Field L\ninstâœÂ¹ : Algebra K L\ninstâœ : IsDomain B\nh : IsCyclotomicExtension {n} A B\nâŠ¢ Module.Finite A B"
    },
    {
      "name": "IsCyclotomicExtension.numberField",
      "statement": "n : â„•+\nS T : Set â„•+\nA : Type u\nB : Type v\nK : Type w\nL : Type z\ninstâœâ· : CommRing A\ninstâœâ¶ : CommRing B\ninstâœâµ : Algebra A B\ninstâœâ´ : Field K\ninstâœÂ³ : Field L\ninstâœÂ² : Algebra K L\nh : NumberField K\ninstâœÂ¹ : Finite â†‘S\ninstâœ : IsCyclotomicExtension S K L\nâŠ¢ FiniteDimensional â„š L"
    },
    {
      "name": "IsDedekindDomain.HeightOneSpectrum.valuationOfNeZeroToFun_eq",
      "statement": "R : Type u\ninstâœâ´ : CommRing R\ninstâœÂ³ : IsDedekindDomain R\nK : Type v\ninstâœÂ² : Field K\ninstâœÂ¹ : Algebra R K\ninstâœ : IsFractionRing R K\nv : HeightOneSpectrum R\nx : KË£\nâŠ¢ â†‘(v.valuationOfNeZeroToFun x) = v.valuation â†‘x"
    },
    {
      "name": "IsDedekindDomain.HeightOneSpectrum.valuation_of_unit_eq",
      "statement": "R : Type u\ninstâœâ´ : CommRing R\ninstâœÂ³ : IsDedekindDomain R\nK : Type v\ninstâœÂ² : Field K\ninstâœÂ¹ : Algebra R K\ninstâœ : IsFractionRing R K\nv : HeightOneSpectrum R\nx : RË£\nâŠ¢ v.valuationOfNeZero ((Units.map â†‘(algebraMap R K)) x) = 1"
    },
    {
      "name": "IsDedekindDomainInv.isNoetherianRing",
      "statement": "R : Type u_1\nA : Type u_2\nK : Type u_3\ninstâœâµ : CommRing R\ninstâœâ´ : CommRing A\ninstâœÂ³ : Field K\ninstâœÂ² : IsDomain A\ninstâœÂ¹ : Algebra A K\ninstâœ : IsFractionRing A K\nh : IsDedekindDomainInv A\nâŠ¢ IsNoetherianRing A"
    },
    {
      "name": "IsIntegral.fg_adjoin_singleton",
      "statement": "R : Type u_1\nA : Type u_2\nB : Type u_3\nS : Type u_4\ninstâœâµ : CommRing R\ninstâœâ´ : CommRing A\ninstâœÂ³ : Ring B\ninstâœÂ² : CommRing S\ninstâœÂ¹ : Algebra R A\ninstâœ : Algebra R B\nf : R â†’+* S\nx : B\nhx : IsIntegral R x\nâŠ¢ (Subalgebra.toSubmodule (Algebra.adjoin R {x})).FG"
    },
    {
      "name": "IsIntegralClosure.mk'_one",
      "statement": "R : Type u_1\nA : Type u_2\nB : Type u_3\ninstâœâµ : CommRing R\ninstâœâ´ : CommRing A\ninstâœÂ³ : CommRing B\ninstâœÂ² : Algebra R B\ninstâœÂ¹ : Algebra A B\ninstâœ : IsIntegralClosure A R B\nh : optParam (IsIntegral R 1) â‹¯\nâŠ¢ (algebraMap A B) (mk' A 1 h) = (algebraMap A B) 1"
    },
    {
      "name": "IsLocalization.coeSubmodule_span_singleton",
      "statement": "R : Type u_1\ninstâœÂ³ : CommRing R\nM : Submonoid R\nS : Type u_2\ninstâœÂ² : CommRing S\ninstâœÂ¹ : Algebra R S\nP : Type u_3\ninstâœ : CommRing P\nx : R\nâŠ¢ coeSubmodule S (Ideal.span {x}) = Submodule.span R {(algebraMap R S) x}"
    },
    {
      "name": "IsLocalization.injective",
      "statement": "R : Type u_1\ninstâœâ´ : CommRing R\nM : Submonoid R\nS : Type u_2\ninstâœÂ³ : CommRing S\ninstâœÂ² : Algebra R S\nP : Type u_3\ninstâœÂ¹ : CommRing P\nK : Type u_4\ninstâœ : IsLocalization M S\nhM : M â‰¤ nonZeroDivisors R\nâŠ¢ Injective â‡‘(algebraMap R S)"
    },
    {
      "name": "IsLocalization.smul_toInvSubmonoid",
      "statement": "R : Type u_1\ninstâœâ´ : CommRing R\nM : Submonoid R\nS : Type u_2\ninstâœÂ³ : CommRing S\ninstâœÂ² : Algebra R S\nP : Type u_3\ninstâœÂ¹ : CommRing P\ninstâœ : IsLocalization M S\nm : â†¥M\nâŠ¢ m â€¢ â†‘((toInvSubmonoid M S) m) = 1"
    },
    {
      "name": "IsNilpotent.neg",
      "statement": "R : Type u_1\nS : Type u_2\nx y : R\ninstâœ : Ring R\nh : IsNilpotent x\nâŠ¢ IsNilpotent (-x)"
    },
    {
      "name": "IsNoetherian.iff_rank_lt_aleph0",
      "statement": "K : Type u\nV : Type v\ninstâœÂ² : DivisionRing K\ninstâœÂ¹ : AddCommGroup V\ninstâœ : Module K V\nâŠ¢ IsNoetherian K V â†” Module.rank K V < â„µâ‚€"
    },
    {
      "name": "IsPGroup.powEquiv_symm_apply",
      "statement": "p : â„•\nG : Type u_1\ninstâœ : Group G\nhG : IsPGroup p G\nn : â„•\nhn : p.Coprime n\ng : G\nâŠ¢ (hG.powEquiv hn).symm g = g ^ (orderOf g).gcdB n"
    },
    {
      "name": "IsPrimitiveRoot.coe_submonoidClass_iff",
      "statement": "Mâœ : Type u_1\nNâœ : Type u_2\nG : Type u_3\nR : Type u_4\nS : Type u_5\nF : Type u_6\ninstâœâµ : CommMonoid Mâœ\ninstâœâ´ : CommMonoid Nâœ\ninstâœÂ³ : DivisionCommMonoid G\nk l : â„•\nÎ¶âœ : Mâœ\nf : F\nh : IsPrimitiveRoot Î¶âœ k\nM : Type u_7\nB : Type u_8\ninstâœÂ² : CommMonoid M\ninstâœÂ¹ : SetLike B M\ninstâœ : SubmonoidClass B M\nN : B\nÎ¶ : â†¥N\nâŠ¢ IsPrimitiveRoot (â†‘Î¶) k â†” IsPrimitiveRoot Î¶ k"
    },
    {
      "name": "IsPrimitiveRoot.inv_iff",
      "statement": "M : Type u_1\nN : Type u_2\nG : Type u_3\nR : Type u_4\nS : Type u_5\nF : Type u_6\ninstâœÂ² : CommMonoid M\ninstâœÂ¹ : CommMonoid N\ninstâœ : DivisionCommMonoid G\nk l : â„•\nÎ¶ : G\nâŠ¢ IsPrimitiveRoot Î¶â»Â¹ k â†” IsPrimitiveRoot Î¶ k"
    },
    {
      "name": "IsPrimitiveRoot.neZero'",
      "statement": "M : Type u_1\nN : Type u_2\nG : Type u_3\nR : Type u_4\nS : Type u_5\nF : Type u_6\ninstâœâ´ : CommMonoid M\ninstâœÂ³ : CommMonoid N\ninstâœÂ² : DivisionCommMonoid G\nk l : â„•\nÎ¶ : R\ninstâœÂ¹ : CommRing R\ninstâœ : IsDomain R\nn : â„•+\nhÎ¶ : IsPrimitiveRoot Î¶ â†‘n\nâŠ¢ NeZero â†‘â†‘n"
    },
    {
      "name": "IsSMulRegular.one",
      "statement": "R : Type u_1\nS : Type u_2\nM : Type u_3\naâœ bâœ : R\ns : S\ninstâœÂ¹ : Monoid R\ninstâœ : MulAction R M\na b : M\nab : (fun x => 1 â€¢ x) a = (fun x => 1 â€¢ x) b\nâŠ¢ a = b"
    },
    {
      "name": "IsSl2Triple.symm",
      "statement": "R : Type u_1\nL : Type u_2\nM : Type u_3\ninstâœâ¶ : CommRing R\ninstâœâµ : LieRing L\ninstâœâ´ : LieAlgebra R L\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\ninstâœÂ¹ : LieRingModule L M\ninstâœ : LieModule R L M\nh e f : L\nht : IsSl2Triple h e f\nâŠ¢ -h â‰  0"
    },
    {
      "name": "IsSquare.pow",
      "statement": "F : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nR : Type u_4\ninstâœ : Monoid Î±\nnâœ : â„•\na : Î±\nn : â„•\nâŠ¢ IsSquare a â†’ IsSquare (a ^ n)"
    },
    {
      "name": "IsometryEquiv.image_closedBall",
      "statement": "Î¹ : Type u_1\nÎ± : Type u\nÎ² : Type v\nÎ³ : Type w\ninstâœÂ¹ : PseudoMetricSpace Î±\ninstâœ : PseudoMetricSpace Î²\nhâœ h : Î± â‰ƒáµ¢ Î²\nx : Î±\nr : â„\nâŠ¢ â‡‘h '' Metric.closedBall x r = Metric.closedBall (h x) r"
    },
    {
      "name": "LSeries.abscissaOfAbsConv_logMul",
      "statement": "f : â„• â†’ â„‚\nâŠ¢ abscissaOfAbsConv (logMul f) = abscissaOfAbsConv f"
    },
    {
      "name": "LSeries.absicssaOfAbsConv_logPowMul",
      "statement": "f : â„• â†’ â„‚\nm : â„•\nâŠ¢ abscissaOfAbsConv (logMul^[m] f) = abscissaOfAbsConv f"
    },
    {
      "name": "Lagrange.degree_interpolate_lt",
      "statement": "F : Type u_1\ninstâœÂ¹ : Field F\nÎ¹ : Type u_2\ninstâœ : DecidableEq Î¹\ns t : Finset Î¹\ni j : Î¹\nv r r' : Î¹ â†’ F\nhvs : Set.InjOn v â†‘s\nâŠ¢ ((interpolate s v) r).degree < â†‘s.card"
    },
    {
      "name": "Lagrange.nodal_subgroup_eq_X_pow_card_sub_one",
      "statement": "R : Type u_1\ninstâœÂ² : CommRing R\nÎ¹ : Type u_2\ns : Finset Î¹\nv : Î¹ â†’ R\ninstâœÂ¹ : IsDomain R\nG : Subgroup RË£\ninstâœ : Fintype â†¥G\nâŠ¢ nodal (â†‘G).toFinset Units.val = X ^ Fintype.card â†¥G - 1"
    },
    {
      "name": "Language.map_kstar",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nlâœ m : Language Î±\na b x : List Î±\nf : Î± â†’ Î²\nl : Language Î±\nâŠ¢ (map f) lâˆ— = ((map f) l)âˆ—"
    },
    {
      "name": "LaurentPolynomial.degree_eq_bot_iff",
      "statement": "R : Type u_1\ninstâœ : Semiring R\nf : R[T;Tâ»Â¹]\nâŠ¢ f.degree = âŠ¥ â†” f = 0"
    },
    {
      "name": "LaurentPolynomial.leftInverse_trunc_toLaurent",
      "statement": "R : Type u_1\ninstâœ : Semiring R\nâŠ¢ LeftInverse â‡‘trunc â‡‘toLaurent"
    },
    {
      "name": "LaurentPolynomial.trunc_C_mul_T",
      "statement": "R : Type u_1\ninstâœ : Semiring R\nn : â„¤\nr : R\nâŠ¢ trunc (C r * T n) = if 0 â‰¤ n then (monomial n.toNat) r else 0"
    },
    {
      "name": "LieAlgebra.isEngelian_of_subsingleton",
      "statement": "R : Type uâ‚\nL : Type uâ‚‚\nLâ‚‚ : Type uâ‚ƒ\nM : Type uâ‚„\ninstâœâ¹ : CommRing R\ninstâœâ¸ : LieRing L\ninstâœâ· : LieAlgebra R L\ninstâœâ¶ : LieRing Lâ‚‚\ninstâœâµ : LieAlgebra R Lâ‚‚\ninstâœâ´ : AddCommGroup M\ninstâœÂ³ : Module R M\ninstâœÂ² : LieRingModule L M\ninstâœÂ¹ : LieModule R L M\ninstâœ : Subsingleton L\nâŠ¢ IsEngelian R L"
    },
    {
      "name": "LieAlgebra.zeroRootSubalgebra_normalizer_eq_self",
      "statement": "R : Type u_1\nL : Type u_2\ninstâœâ· : CommRing R\ninstâœâ¶ : LieRing L\ninstâœâµ : LieAlgebra R L\nH : LieSubalgebra R L\ninstâœâ´ : IsNilpotent R â†¥H\nM : Type u_3\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\ninstâœÂ¹ : LieRingModule L M\ninstâœ : LieModule R L M\nâŠ¢ (zeroRootSubalgebra R L H).normalizer = zeroRootSubalgebra R L H"
    },
    {
      "name": "LieDerivation.IsKilling.ad_apply_eq_zero_iff",
      "statement": "R : Type u_1\nL : Type u_2\ninstâœâ´ : Field R\ninstâœÂ³ : LieRing L\ninstâœÂ² : LieAlgebra R L\ninstâœÂ¹ : Module.Finite R L\ninstâœ : LieAlgebra.IsKilling R L\nx : L\nâŠ¢ (ad R L) x = 0 â†” x = 0"
    },
    {
      "name": "LieDerivation.coe_ad_apply_eq_ad_apply",
      "statement": "R : Type u_1\nL : Type u_2\ninstâœÂ² : CommRing R\ninstâœÂ¹ : LieRing L\ninstâœ : LieAlgebra R L\nx : L\nâŠ¢ â†‘((ad R L) x) = (LieAlgebra.ad R L) x"
    },
    {
      "name": "LieHom.idealRange_eq_top_of_surjective",
      "statement": "R : Type u\nL : Type v\nL' : Type wâ‚‚\nM : Type w\nM' : Type wâ‚\ninstâœÂ¹Â² : CommRing R\ninstâœÂ¹Â¹ : LieRing L\ninstâœÂ¹â° : LieAlgebra R L\ninstâœâ¹ : LieRing L'\ninstâœâ¸ : LieAlgebra R L'\ninstâœâ· : AddCommGroup M\ninstâœâ¶ : Module R M\ninstâœâµ : LieRingModule L M\ninstâœâ´ : LieModule R L M\ninstâœÂ³ : AddCommGroup M'\ninstâœÂ² : Module R M'\ninstâœÂ¹ : LieRingModule L M'\ninstâœ : LieModule R L M'\nf : L â†’â‚—â…Râ† L'\nI : LieIdeal R L\nJ : LieIdeal R L'\nh : Function.Surjective â‡‘f\nâŠ¢ f.idealRange = âŠ¤"
    },
    {
      "name": "LieIdeal.map_sup_ker_eq_map'",
      "statement": "R : Type u\nL : Type v\nL' : Type wâ‚‚\nM : Type w\nM' : Type wâ‚\ninstâœÂ¹Â² : CommRing R\ninstâœÂ¹Â¹ : LieRing L\ninstâœÂ¹â° : LieAlgebra R L\ninstâœâ¹ : LieRing L'\ninstâœâ¸ : LieAlgebra R L'\ninstâœâ· : AddCommGroup M\ninstâœâ¶ : Module R M\ninstâœâµ : LieRingModule L M\ninstâœâ´ : LieModule R L M\ninstâœÂ³ : AddCommGroup M'\ninstâœÂ² : Module R M'\ninstâœÂ¹ : LieRingModule L M'\ninstâœ : LieModule R L M'\nf : L â†’â‚—â…Râ† L'\nI : LieIdeal R L\nJ : LieIdeal R L'\nâŠ¢ map f I âŠ” map f f.ker = map f I"
    },
    {
      "name": "LieModule.Weight.hasEigenvalueAt",
      "statement": "K : Type u_1\nR : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ· : CommRing R\ninstâœâ¶ : LieRing L\ninstâœâµ : LieAlgebra R L\ninstâœâ´ : LieAlgebra.IsNilpotent R L\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\ninstâœÂ¹ : LieRingModule L M\ninstâœ : LieModule R L M\nÏ‡ : Weight R L M\nx : L\nâŠ¢ ((toEnd R L M) x).HasEigenvalue (Ï‡ x)"
    },
    {
      "name": "LieModule.iInf_lowerCentralSeries_eq_posFittingComp",
      "statement": "K : Type u_1\nR : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ¹ : CommRing R\ninstâœâ¸ : LieRing L\ninstâœâ· : LieAlgebra R L\ninstâœâ¶ : LieAlgebra.IsNilpotent R L\ninstâœâµ : AddCommGroup M\ninstâœâ´ : Module R M\ninstâœÂ³ : LieRingModule L M\ninstâœÂ² : LieModule R L M\ninstâœÂ¹ : IsNoetherian R M\ninstâœ : IsArtinian R M\nâŠ¢ â¨… k, lowerCentralSeries R L M k = posFittingComp R L M"
    },
    {
      "name": "LieModule.isNilpotent_toEnd_of_isNilpotent",
      "statement": "R : Type u\nL : Type v\nM : Type w\ninstâœÂ¹Â¹ : CommRing R\ninstâœÂ¹â° : LieRing L\ninstâœâ¹ : LieAlgebra R L\ninstâœâ¸ : AddCommGroup M\ninstâœâ· : Module R M\ninstâœâ¶ : LieRingModule L M\ninstâœâµ : LieModule R L M\nk : â„•\nN : LieSubmodule R L M\nMâ‚‚ : Type wâ‚\ninstâœâ´ : AddCommGroup Mâ‚‚\ninstâœÂ³ : Module R Mâ‚‚\ninstâœÂ² : LieRingModule L Mâ‚‚\ninstâœÂ¹ : LieModule R L Mâ‚‚\ninstâœ : IsNilpotent R L M\nx : L\nâŠ¢ _root_.IsNilpotent ((toEnd R L M) x)"
    },
    {
      "name": "LieModule.mem_ker",
      "statement": "R : Type u\nL : Type v\nM : Type w\nN : Type wâ‚\ninstâœÂ¹â° : CommRing R\ninstâœâ¹ : LieRing L\ninstâœâ¸ : LieAlgebra R L\ninstâœâ· : AddCommGroup M\ninstâœâ¶ : Module R M\ninstâœâµ : LieRingModule L M\ninstâœâ´ : LieModule R L M\ninstâœÂ³ : AddCommGroup N\ninstâœÂ² : Module R N\ninstâœÂ¹ : LieRingModule L N\ninstâœ : LieModule R L N\nx : L\nâŠ¢ x âˆˆ LieModule.ker R L M â†” âˆ€ (m : M), â…x, mâ† = 0"
    },
    {
      "name": "LieModule.toEnd_lie",
      "statement": "R : Type u\nL : Type v\nM : Type w\ninstâœâ¶ : CommRing R\ninstâœâµ : LieRing L\ninstâœâ´ : LieAlgebra R L\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\ninstâœÂ¹ : LieRingModule L M\ninstâœ : LieModule R L M\nx y : L\nz : M\nâŠ¢ (Ï† x) â…y, zâ† = â…((ad R L) x) y, zâ† + â…y, (Ï† x) zâ†"
    },
    {
      "name": "LieModule.toModuleHom_apply",
      "statement": "R : Type u\ninstâœâ¶ : CommRing R\nL : Type v\nM : Type w\ninstâœâµ : LieRing L\ninstâœâ´ : LieAlgebra R L\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\ninstâœÂ¹ : LieRingModule L M\ninstâœ : LieModule R L M\nx : L\nm : M\nâŠ¢ (toModuleHom R L M) (x âŠ—â‚œ[R] m) = â…x, mâ†"
    },
    {
      "name": "LieModule.traceForm_eq_sum_finrank_nsmul_mul",
      "statement": "R : Type u_1\nK : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœÂ¹â¸ : CommRing R\ninstâœÂ¹â· : LieRing L\ninstâœÂ¹â¶ : LieAlgebra R L\ninstâœÂ¹âµ : AddCommGroup M\ninstâœÂ¹â´ : Module R M\ninstâœÂ¹Â³ : LieRingModule L M\ninstâœÂ¹Â² : LieModule R L M\ninstâœÂ¹Â¹ : Module.Free R M\ninstâœÂ¹â° : Module.Finite R M\ninstâœâ¹ : Module.Free R L\ninstâœâ¸ : Module.Finite R L\ninstâœâ· : Field K\ninstâœâ¶ : LieAlgebra K L\ninstâœâµ : Module K M\ninstâœâ´ : LieModule K L M\ninstâœÂ³ : FiniteDimensional K M\ninstâœÂ² : LieAlgebra.IsNilpotent K L\ninstâœÂ¹ : LinearWeights K L M\ninstâœ : IsTriangularizable K L M\nx y : L\nâŠ¢ ((traceForm K L M) x) y = âˆ‘ Ï‡ : Weight K L M, finrank K â†¥â†‘(weightSpace M â‡‘Ï‡) â€¢ (Ï‡ x * Ï‡ y)"
    },
    {
      "name": "LieModuleEquiv.symm_symm",
      "statement": "R : Type u\nL : Type v\nM : Type w\nN : Type wâ‚\nP : Type wâ‚‚\ninstâœÂ¹â´ : CommRing R\ninstâœÂ¹Â³ : LieRing L\ninstâœÂ¹Â² : LieAlgebra R L\ninstâœÂ¹Â¹ : AddCommGroup M\ninstâœÂ¹â° : AddCommGroup N\ninstâœâ¹ : AddCommGroup P\ninstâœâ¸ : Module R M\ninstâœâ· : Module R N\ninstâœâ¶ : Module R P\ninstâœâµ : LieRingModule L M\ninstâœâ´ : LieRingModule L N\ninstâœÂ³ : LieRingModule L P\ninstâœÂ² : LieModule R L M\ninstâœÂ¹ : LieModule R L N\ninstâœ : LieModule R L P\ne : M â‰ƒâ‚—â…R,Lâ† N\nâŠ¢ e.symm.symm = e"
    },
    {
      "name": "LieSubalgebra.engel_zero",
      "statement": "R : Type u_1\nL : Type u_2\nM : Type u_3\ninstâœâ¶ : CommRing R\ninstâœâµ : LieRing L\ninstâœâ´ : LieAlgebra R L\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\ninstâœÂ¹ : LieRingModule L M\ninstâœ : LieModule R L M\nâŠ¢ engel R 0 = âŠ¤"
    },
    {
      "name": "LieSubmodule.range_incl",
      "statement": "R : Type u\nL : Type v\nM : Type w\ninstâœâ¶ : CommRing R\ninstâœâµ : LieRing L\ninstâœâ´ : LieAlgebra R L\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\ninstâœÂ¹ : LieRingModule L M\ninstâœ : LieModule R L M\nN : LieSubmodule R L M\nâŠ¢ N.incl.range = N"
    },
    {
      "name": "LieSubmodule.sSup_image_lieSpan_singleton",
      "statement": "R : Type u\nL : Type v\nM : Type w\ninstâœâ¶ : CommRing R\ninstâœâµ : LieRing L\ninstâœâ´ : LieAlgebra R L\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\ninstâœÂ¹ : LieRingModule L M\ninstâœ : LieModule R L M\nN N' : LieSubmodule R L M\nI J : LieIdeal R L\ns : Set M\nâŠ¢ sSup ((fun x => lieSpan R L {x}) '' â†‘N) = N"
    },
    {
      "name": "LieSubmodule.sup_lie",
      "statement": "R : Type u\nL : Type v\nM : Type w\nMâ‚‚ : Type wâ‚\ninstâœÂ¹â° : CommRing R\ninstâœâ¹ : LieRing L\ninstâœâ¸ : LieAlgebra R L\ninstâœâ· : AddCommGroup M\ninstâœâ¶ : Module R M\ninstâœâµ : LieRingModule L M\ninstâœâ´ : LieModule R L M\ninstâœÂ³ : AddCommGroup Mâ‚‚\ninstâœÂ² : Module R Mâ‚‚\ninstâœÂ¹ : LieRingModule L Mâ‚‚\ninstâœ : LieModule R L Mâ‚‚\nN N' : LieSubmodule R L M\nI J : LieIdeal R L\nNâ‚‚ : LieSubmodule R L Mâ‚‚\nâŠ¢ â…I âŠ” J, Nâ† = â…I, Nâ† âŠ” â…J, Nâ†"
    },
    {
      "name": "LieSubmodule.trivial_lie_oper_zero",
      "statement": "R : Type u\nL : Type v\nM : Type w\ninstâœâ· : CommRing R\ninstâœâ¶ : LieRing L\ninstâœâµ : LieAlgebra R L\ninstâœâ´ : AddCommGroup M\ninstâœÂ³ : Module R M\ninstâœÂ² : LieRingModule L M\ninstâœÂ¹ : LieModule R L M\nN N' : LieSubmodule R L M\nI J : LieIdeal R L\ninstâœ : LieModule.IsTrivial L M\nâŠ¢ â…I, Nâ† = âŠ¥"
    },
    {
      "name": "LinearEquiv.conj_trans",
      "statement": "R : Type u_1\nRâ‚ : Type u_2\nRâ‚‚ : Type u_3\nRâ‚ƒ : Type u_4\nk : Type u_5\nK : Type u_6\nS : Type u_7\nM : Type u_8\nMâ‚ : Type u_9\nMâ‚‚ : Type u_10\nMâ‚ƒ : Type u_11\nNâ‚ : Type u_12\nNâ‚‚ : Type u_13\nNâ‚ƒ : Type u_14\nNâ‚„ : Type u_15\nÎ¹ : Type u_16\ninstâœâ¶ : CommSemiring R\ninstâœâµ : AddCommMonoid M\ninstâœâ´ : AddCommMonoid Mâ‚‚\ninstâœÂ³ : AddCommMonoid Mâ‚ƒ\ninstâœÂ² : Module R M\ninstâœÂ¹ : Module R Mâ‚‚\ninstâœ : Module R Mâ‚ƒ\neâ‚ : M â‰ƒâ‚—[R] Mâ‚‚\neâ‚‚ : Mâ‚‚ â‰ƒâ‚—[R] Mâ‚ƒ\nâŠ¢ eâ‚.conj â‰ªâ‰«â‚— eâ‚‚.conj = (eâ‚ â‰ªâ‰«â‚— eâ‚‚).conj"
    },
    {
      "name": "LinearEquiv.det_conj",
      "statement": "R : Type u_1\ninstâœâ¶ : CommRing R\nM : Type u_2\ninstâœâµ : AddCommGroup M\ninstâœâ´ : Module R M\nM' : Type u_3\ninstâœÂ³ : AddCommGroup M'\ninstâœÂ² : Module R M'\nÎ¹ : Type u_4\ninstâœÂ¹ : DecidableEq Î¹\ninstâœ : Fintype Î¹\neâœ : Basis Î¹ R M\nf : M â‰ƒâ‚—[R] M\ne : M â‰ƒâ‚—[R] M'\nâŠ¢ LinearEquiv.det (e.symm â‰ªâ‰«â‚— f â‰ªâ‰«â‚— e) = LinearEquiv.det f"
    },
    {
      "name": "LinearEquiv.lTensor_zpow",
      "statement": "R : Type u_1\ninstâœÂ¹â¶ : CommSemiring R\nR' : Type u_2\ninstâœÂ¹âµ : Monoid R'\nR'' : Type u_3\ninstâœÂ¹â´ : Semiring R''\nM : Type u_4\nN : Type u_5\nP : Type u_6\nQ : Type u_7\nS : Type u_8\nT : Type u_9\ninstâœÂ¹Â³ : AddCommMonoid M\ninstâœÂ¹Â² : AddCommMonoid N\ninstâœÂ¹Â¹ : AddCommMonoid P\ninstâœÂ¹â° : AddCommMonoid Q\ninstâœâ¹ : AddCommMonoid S\ninstâœâ¸ : AddCommMonoid T\ninstâœâ· : Module R M\ninstâœâ¶ : Module R N\ninstâœâµ : Module R P\ninstâœâ´ : Module R Q\ninstâœÂ³ : Module R S\ninstâœÂ² : Module R T\ninstâœÂ¹ : DistribMulAction R' M\ninstâœ : Module R'' M\ng : P â‰ƒâ‚—[R] Q\nfâœ : N â‰ƒâ‚—[R] P\nm : M\nnâœ : N\np : P\nx : M âŠ—[R] N\ny : N âŠ—[R] M\nf : N â‰ƒâ‚—[R] N\nn : â„¤\nâŠ¢ lTensor M f ^ n = lTensor M (f ^ n)"
    },
    {
      "name": "LinearEquiv.neg_apply",
      "statement": "R : Type u_1\nRâ‚ : Type u_2\nRâ‚‚ : Type u_3\nRâ‚ƒ : Type u_4\nk : Type u_5\nK : Type u_6\nS : Type u_7\nM : Type u_8\nMâ‚ : Type u_9\nMâ‚‚ : Type u_10\nMâ‚ƒ : Type u_11\nNâ‚ : Type u_12\nNâ‚‚ : Type u_13\nNâ‚ƒ : Type u_14\nNâ‚„ : Type u_15\nÎ¹ : Type u_16\ninstâœÂ² : Semiring R\ninstâœÂ¹ : AddCommGroup M\ninstâœ : Module R M\nx : M\nâŠ¢ (neg R) x = -x"
    },
    {
      "name": "LinearEquiv.piRing_symm_apply",
      "statement": "R : Type u\nK : Type u'\nM : Type v\nV : Type v'\nMâ‚‚ : Type w\nVâ‚‚ : Type w'\nMâ‚ƒ : Type y\nVâ‚ƒ : Type y'\nMâ‚„ : Type z\nÎ¹ : Type x\nÎ¹' : Type x'\ninstâœÂ¹Â³ : Semiring R\nÏ† : Î¹ â†’ Type u_1\nÏˆ : Î¹ â†’ Type u_2\nÏ‡ : Î¹ â†’ Type u_3\ninstâœÂ¹Â² : (i : Î¹) â†’ AddCommMonoid (Ï† i)\ninstâœÂ¹Â¹ : (i : Î¹) â†’ Module R (Ï† i)\ninstâœÂ¹â° : (i : Î¹) â†’ AddCommMonoid (Ïˆ i)\ninstâœâ¹ : (i : Î¹) â†’ Module R (Ïˆ i)\ninstâœâ¸ : (i : Î¹) â†’ AddCommMonoid (Ï‡ i)\ninstâœâ· : (i : Î¹) â†’ Module R (Ï‡ i)\nS : Type u_4\ninstâœâ¶ : Fintype Î¹\ninstâœâµ : DecidableEq Î¹\ninstâœâ´ : Semiring S\ninstâœÂ³ : AddCommMonoid M\ninstâœÂ² : Module R M\ninstâœÂ¹ : Module S M\ninstâœ : SMulCommClass R S M\nf : Î¹ â†’ M\ng : Î¹ â†’ R\nâŠ¢ ((piRing R M Î¹ S).symm f) g = âˆ‘ i : Î¹, g i â€¢ f i"
    },
    {
      "name": "LinearEquiv.snd_comp_prodComm",
      "statement": "R : Type u\nK : Type u'\nM : Type v\nV : Type v'\nMâ‚‚ : Type w\nVâ‚‚ : Type w'\nMâ‚ƒ : Type y\nVâ‚ƒ : Type y'\nMâ‚„ : Type z\nÎ¹ : Type x\nMâ‚… : Type u_1\nMâ‚† : Type u_2\ninstâœâ´ : Semiring R\ninstâœÂ³ : AddCommMonoid M\ninstâœÂ² : AddCommMonoid Mâ‚‚\ninstâœÂ¹ : Module R M\ninstâœ : Module R Mâ‚‚\nâŠ¢ LinearMap.snd R Mâ‚‚ M âˆ˜â‚— â†‘(prodComm R M Mâ‚‚) = LinearMap.fst R M Mâ‚‚"
    },
    {
      "name": "LinearEquiv.toLinearEquiv_toContinuousLinearEquiv",
      "statement": "ğ•œ : Type u\nhnorm : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœÂ¹â¸ : AddCommGroup E\ninstâœÂ¹â· : Module ğ•œ E\ninstâœÂ¹â¶ : TopologicalSpace E\ninstâœÂ¹âµ : TopologicalAddGroup E\ninstâœÂ¹â´ : ContinuousSMul ğ•œ E\nF : Type w\ninstâœÂ¹Â³ : AddCommGroup F\ninstâœÂ¹Â² : Module ğ•œ F\ninstâœÂ¹Â¹ : TopologicalSpace F\ninstâœÂ¹â° : TopologicalAddGroup F\ninstâœâ¹ : ContinuousSMul ğ•œ F\nF' : Type x\ninstâœâ¸ : AddCommGroup F'\ninstâœâ· : Module ğ•œ F'\ninstâœâ¶ : TopologicalSpace F'\ninstâœâµ : TopologicalAddGroup F'\ninstâœâ´ : ContinuousSMul ğ•œ F'\ninstâœÂ³ : CompleteSpace ğ•œ\ninstâœÂ² : T2Space E\ninstâœÂ¹ : T2Space F\ninstâœ : FiniteDimensional ğ•œ E\ne : E â‰ƒâ‚—[ğ•œ] F\nâŠ¢ e.toContinuousLinearEquiv.toLinearEquiv = e"
    },
    {
      "name": "LinearIsometry.norm_toContinuousLinearMap",
      "statement": "ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nğ•œâ‚ƒ : Type u_3\nE : Type u_4\nEâ‚— : Type u_5\nF : Type u_6\nFâ‚— : Type u_7\nG : Type u_8\nGâ‚— : Type u_9\nğ“• : Type u_10\ninstâœÂ¹Â² : NormedAddCommGroup E\ninstâœÂ¹Â¹ : NormedAddCommGroup F\ninstâœÂ¹â° : NormedAddCommGroup G\ninstâœâ¹ : NormedAddCommGroup Fâ‚—\ninstâœâ¸ : NontriviallyNormedField ğ•œ\ninstâœâ· : NontriviallyNormedField ğ•œâ‚‚\ninstâœâ¶ : NontriviallyNormedField ğ•œâ‚ƒ\ninstâœâµ : NormedSpace ğ•œ E\ninstâœâ´ : NormedSpace ğ•œâ‚‚ F\ninstâœÂ³ : NormedSpace ğ•œâ‚ƒ G\ninstâœÂ² : NormedSpace ğ•œ Fâ‚—\nc : ğ•œ\nÏƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚\nÏƒâ‚‚â‚ƒ : ğ•œâ‚‚ â†’+* ğ•œâ‚ƒ\nfâœ g : E â†’SL[Ïƒâ‚â‚‚] F\nx y z : E\ninstâœÂ¹ : Nontrivial E\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nf : E â†’â‚›â‚—áµ¢[Ïƒâ‚â‚‚] F\nâŠ¢ âˆ€ (x : E), â€–f.toContinuousLinearMap xâ€– = 1 * â€–xâ€–"
    },
    {
      "name": "LinearIsometryEquiv.piLpCongrLeft_symm",
      "statement": "p : â„â‰¥0âˆ\nğ•œ : Type u_1\nÎ¹ : Type u_2\nÎ± : Î¹ â†’ Type u_3\nÎ² : Î¹ â†’ Type u_4\ninstâœâ¹ : Fact (1 â‰¤ p)\ninstâœâ¸ : Fintype Î¹\ninstâœâ· : Semiring ğ•œ\ninstâœâ¶ : (i : Î¹) â†’ SeminormedAddCommGroup (Î± i)\ninstâœâµ : (i : Î¹) â†’ SeminormedAddCommGroup (Î² i)\ninstâœâ´ : (i : Î¹) â†’ Module ğ•œ (Î± i)\ninstâœÂ³ : (i : Î¹) â†’ Module ğ•œ (Î² i)\nc : ğ•œ\nÎ¹' : Type u_5\ninstâœÂ² : Fintype Î¹'\nE : Type u_6\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : Module ğ•œ E\ne : Î¹ â‰ƒ Î¹'\nz : PiLp p fun x => E\nâŠ¢ (LinearIsometryEquiv.piLpCongrLeft p ğ•œ E e).symm z = (LinearIsometryEquiv.piLpCongrLeft p ğ•œ E e.symm) z"
    },
    {
      "name": "LinearMap.IsProj.codRestrict_apply_cod",
      "statement": "R : Type u_1\ninstâœâ¹ : Ring R\nE : Type u_2\ninstâœâ¸ : AddCommGroup E\ninstâœâ· : Module R E\nF : Type u_3\ninstâœâ¶ : AddCommGroup F\ninstâœâµ : Module R F\nG : Type u_4\ninstâœâ´ : AddCommGroup G\ninstâœÂ³ : Module R G\np q : Submodule R E\nS : Type u_5\ninstâœÂ² : Semiring S\nM : Type u_6\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : Module S M\nm : Submodule S M\nf : M â†’â‚—[S] M\nh : IsProj m f\nx : â†¥m\nâŠ¢ h.codRestrict â†‘x = x"
    },
    {
      "name": "LinearMap.IsSymmetric.coe_reApplyInnerSelf_apply",
      "statement": "ğ•œ : Type u_1\nE : Type u_2\nE' : Type u_3\nF : Type u_4\nG : Type u_5\ninstâœâ¸ : RCLike ğ•œ\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : InnerProductSpace ğ•œ E\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : InnerProductSpace ğ•œ F\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : InnerProductSpace ğ•œ G\ninstâœÂ¹ : NormedAddCommGroup E'\ninstâœ : InnerProductSpace â„ E'\nT : E â†’L[ğ•œ] E\nhT : (â†‘T).IsSymmetric\nx : E\nâŠ¢ â†‘(T.reApplyInnerSelf x) = âŸªT x, xâŸ«_ğ•œ"
    },
    {
      "name": "LinearMap.adjoint_adjoint",
      "statement": "ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninstâœâ¹ : RCLike ğ•œ\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedAddCommGroup G\ninstâœâµ : InnerProductSpace ğ•œ E\ninstâœâ´ : InnerProductSpace ğ•œ F\ninstâœÂ³ : InnerProductSpace ğ•œ G\ninstâœÂ² : FiniteDimensional ğ•œ E\ninstâœÂ¹ : FiniteDimensional ğ•œ F\ninstâœ : FiniteDimensional ğ•œ G\nA : E â†’â‚—[ğ•œ] F\nâŠ¢ adjoint (adjoint A) = A"
    },
    {
      "name": "LinearMap.adjoint_inner_left",
      "statement": "ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninstâœâ¹ : RCLike ğ•œ\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedAddCommGroup G\ninstâœâµ : InnerProductSpace ğ•œ E\ninstâœâ´ : InnerProductSpace ğ•œ F\ninstâœÂ³ : InnerProductSpace ğ•œ G\ninstâœÂ² : FiniteDimensional ğ•œ E\ninstâœÂ¹ : FiniteDimensional ğ•œ F\ninstâœ : FiniteDimensional ğ•œ G\nA : E â†’â‚—[ğ•œ] F\nx : E\ny : F\nâŠ¢ âŸª(adjoint A) y, xâŸ«_ğ•œ = âŸªy, A xâŸ«_ğ•œ"
    },
    {
      "name": "LinearMap.det_smul",
      "statement": "R : Type u_1\ninstâœÂ¹Â² : CommRing R\nMâœ : Type u_2\ninstâœÂ¹Â¹ : AddCommGroup Mâœ\ninstâœÂ¹â° : Module R Mâœ\nM' : Type u_3\ninstâœâ¹ : AddCommGroup M'\ninstâœâ¸ : Module R M'\nÎ¹ : Type u_4\ninstâœâ· : DecidableEq Î¹\ninstâœâ¶ : Fintype Î¹\ne : Basis Î¹ R Mâœ\nA : Type u_5\ninstâœâµ : CommRing A\ninstâœâ´ : Module A Mâœ\nÎº : Type u_6\ninstâœÂ³ : Fintype Îº\nğ•œ : Type u_7\ninstâœÂ² : Field ğ•œ\nM : Type u_8\ninstâœÂ¹ : AddCommGroup M\ninstâœ : Module ğ•œ M\nc : ğ•œ\nf : M â†’â‚—[ğ•œ] M\nâŠ¢ LinearMap.det (c â€¢ f) = c ^ FiniteDimensional.finrank ğ•œ M * LinearMap.det f"
    },
    {
      "name": "LinearMap.det_toMatrix'",
      "statement": "R : Type u_1\ninstâœÂ¹Â¹ : CommRing R\nM : Type u_2\ninstâœÂ¹â° : AddCommGroup M\ninstâœâ¹ : Module R M\nM' : Type u_3\ninstâœâ¸ : AddCommGroup M'\ninstâœâ· : Module R M'\nÎ¹âœ : Type u_4\ninstâœâ¶ : DecidableEq Î¹âœ\ninstâœâµ : Fintype Î¹âœ\ne : Basis Î¹âœ R M\nA : Type u_5\ninstâœâ´ : CommRing A\ninstâœÂ³ : Module A M\nÎº : Type u_6\ninstâœÂ² : Fintype Îº\nÎ¹ : Type u_7\ninstâœÂ¹ : Fintype Î¹\ninstâœ : DecidableEq Î¹\nf : (Î¹ â†’ A) â†’â‚—[A] Î¹ â†’ A\nâŠ¢ (toMatrix' f).det = LinearMap.det f"
    },
    {
      "name": "LinearMap.injective_domRestrict_iff",
      "statement": "R : Type u_1\nRâ‚ : Type u_2\nRâ‚‚ : Type u_3\nRâ‚ƒ : Type u_4\nK : Type u_5\nM : Type u_6\nMâ‚ : Type u_7\nMâ‚‚ : Type u_8\nMâ‚ƒ : Type u_9\nV : Type u_10\nVâ‚‚ : Type u_11\ninstâœÂ¹Â¹ : Ring R\ninstâœÂ¹â° : Ring Râ‚‚\ninstâœâ¹ : Ring Râ‚ƒ\ninstâœâ¸ : AddCommGroup M\ninstâœâ· : AddCommGroup Mâ‚‚\ninstâœâ¶ : AddCommGroup Mâ‚ƒ\ninstâœâµ : Module R M\ninstâœâ´ : Module Râ‚‚ Mâ‚‚\ninstâœÂ³ : Module Râ‚ƒ Mâ‚ƒ\nÏ„â‚â‚‚ : R â†’+* Râ‚‚\nÏ„â‚‚â‚ƒ : Râ‚‚ â†’+* Râ‚ƒ\nÏ„â‚â‚ƒ : R â†’+* Râ‚ƒ\ninstâœÂ² : RingHomCompTriple Ï„â‚â‚‚ Ï„â‚‚â‚ƒ Ï„â‚â‚ƒ\nF : Type u_12\ninstâœÂ¹ : FunLike F M Mâ‚‚\ninstâœ : SemilinearMapClass F Ï„â‚â‚‚ M Mâ‚‚\nfâœ : F\nf : M â†’â‚›â‚—[Ï„â‚â‚‚] Mâ‚‚\nS : Submodule R M\nâŠ¢ Injective â‡‘(f.domRestrict S) â†” S âŠ“ ker f = âŠ¥"
    },
    {
      "name": "LinearMap.isNilpotent_toMatrix_iff",
      "statement": "R : Type u_1\nS : Type u_2\nx y : R\nA : Type v\ninstâœâ¶ : CommSemiring R\ninstâœâµ : Semiring A\ninstâœâ´ : Algebra R A\nÎ¹ : Type u_3\nM : Type u_4\ninstâœÂ³ : Fintype Î¹\ninstâœÂ² : DecidableEq Î¹\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : Module R M\nb : Basis Î¹ R M\nf : M â†’â‚—[R] M\nâŠ¢ IsNilpotent ((toMatrix b b) f) â†” IsNilpotent f"
    },
    {
      "name": "LinearMap.isOpenMap_of_finiteDimensional",
      "statement": "ğ•œ : Type u\nhnorm : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœÂ¹â· : AddCommGroup E\ninstâœÂ¹â¶ : Module ğ•œ E\ninstâœÂ¹âµ : TopologicalSpace E\ninstâœÂ¹â´ : TopologicalAddGroup E\ninstâœÂ¹Â³ : ContinuousSMul ğ•œ E\nF : Type w\ninstâœÂ¹Â² : AddCommGroup F\ninstâœÂ¹Â¹ : Module ğ•œ F\ninstâœÂ¹â° : TopologicalSpace F\ninstâœâ¹ : TopologicalAddGroup F\ninstâœâ¸ : ContinuousSMul ğ•œ F\nF' : Type x\ninstâœâ· : AddCommGroup F'\ninstâœâ¶ : Module ğ•œ F'\ninstâœâµ : TopologicalSpace F'\ninstâœâ´ : TopologicalAddGroup F'\ninstâœÂ³ : ContinuousSMul ğ•œ F'\ninstâœÂ² : CompleteSpace ğ•œ\ninstâœÂ¹ : T2Space E\ninstâœ : FiniteDimensional ğ•œ E\nf : F â†’â‚—[ğ•œ] E\nhf : Function.Surjective â‡‘f\nâŠ¢ IsOpenMap â‡‘f"
    },
    {
      "name": "LinearMap.mulLeft_eq_zero_iff",
      "statement": "R : Type u_1\nA : Type u_2\nB : Type u_3\ninstâœâ´ : CommSemiring R\ninstâœÂ³ : Semiring A\ninstâœÂ² : Semiring B\ninstâœÂ¹ : Algebra R A\ninstâœ : Algebra R B\na : A\nâŠ¢ mulLeft R a = 0 â†” a = 0"
    },
    {
      "name": "LinearMap.mulRight_eq_zero_iff",
      "statement": "R : Type u_1\nA : Type u_2\nB : Type u_3\ninstâœâ´ : CommSemiring R\ninstâœÂ³ : Semiring A\ninstâœÂ² : Semiring B\ninstâœÂ¹ : Algebra R A\ninstâœ : Algebra R B\na : A\nâŠ¢ mulRight R a = 0 â†” a = 0"
    },
    {
      "name": "LinearMap.ofIsCompl_right_apply",
      "statement": "R : Type u_1\ninstâœâ¹ : Ring R\nE : Type u_2\ninstâœâ¸ : AddCommGroup E\ninstâœâ· : Module R E\nF : Type u_3\ninstâœâ¶ : AddCommGroup F\ninstâœâµ : Module R F\nG : Type u_4\ninstâœâ´ : AddCommGroup G\ninstâœÂ³ : Module R G\np q : Submodule R E\nS : Type u_5\ninstâœÂ² : Semiring S\nM : Type u_6\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : Module S M\nm : Submodule S M\nh : IsCompl p q\nÏ† : â†¥p â†’â‚—[R] F\nÏˆ : â†¥q â†’â‚—[R] F\nv : â†¥q\nâŠ¢ (ofIsCompl h Ï† Ïˆ) â†‘v = Ïˆ v"
    },
    {
      "name": "LinearMap.pi_zero",
      "statement": "R : Type u\nK : Type u'\nM : Type v\nV : Type v'\nMâ‚‚ : Type w\nVâ‚‚ : Type w'\nMâ‚ƒ : Type y\nVâ‚ƒ : Type y'\nMâ‚„ : Type z\nÎ¹ : Type x\nÎ¹' : Type x'\ninstâœâ¶ : Semiring R\ninstâœâµ : AddCommMonoid Mâ‚‚\ninstâœâ´ : Module R Mâ‚‚\ninstâœÂ³ : AddCommMonoid Mâ‚ƒ\ninstâœÂ² : Module R Mâ‚ƒ\nÏ† : Î¹ â†’ Type i\ninstâœÂ¹ : (i : Î¹) â†’ AddCommMonoid (Ï† i)\ninstâœ : (i : Î¹) â†’ Module R (Ï† i)\nâŠ¢ (pi fun i => 0) = 0"
    },
    {
      "name": "LinearMap.polyCharpolyAux_map_eq_charpoly",
      "statement": "R : Type u_1\nL : Type u_2\nM : Type u_3\nn : Type u_4\nÎ¹ : Type u_5\nÎ¹' : Type u_6\nÎ¹M : Type u_7\ninstâœÂ¹Â² : CommRing R\ninstâœÂ¹Â¹ : AddCommGroup L\ninstâœÂ¹â° : Module R L\ninstâœâ¹ : AddCommGroup M\ninstâœâ¸ : Module R M\nÏ† : L â†’â‚—[R] Module.End R M\ninstâœâ· : Fintype Î¹\ninstâœâ¶ : Fintype Î¹'\ninstâœâµ : Fintype Î¹M\ninstâœâ´ : DecidableEq Î¹\ninstâœÂ³ : DecidableEq Î¹'\ninstâœÂ² : DecidableEq Î¹M\nb : Basis Î¹ R L\nbâ‚˜ : Basis Î¹M R M\ninstâœÂ¹ : Module.Finite R M\ninstâœ : Module.Free R M\nx : L\nâŠ¢ Polynomial.map (MvPolynomial.eval â‡‘(b.repr x)) (Ï†.polyCharpolyAux b bâ‚˜) = charpoly (Ï† x)"
    },
    {
      "name": "LinearMap.range_rangeRestrict",
      "statement": "R : Type u_1\nRâ‚‚ : Type u_2\nRâ‚ƒ : Type u_3\nK : Type u_4\nKâ‚‚ : Type u_5\nM : Type u_6\nMâ‚‚ : Type u_7\nMâ‚ƒ : Type u_8\nV : Type u_9\nVâ‚‚ : Type u_10\ninstâœÂ¹â° : Semiring R\ninstâœâ¹ : Semiring Râ‚‚\ninstâœâ¸ : Semiring Râ‚ƒ\ninstâœâ· : AddCommMonoid M\ninstâœâ¶ : AddCommMonoid Mâ‚‚\ninstâœâµ : AddCommMonoid Mâ‚ƒ\ninstâœâ´ : Module R M\ninstâœÂ³ : Module Râ‚‚ Mâ‚‚\ninstâœÂ² : Module Râ‚ƒ Mâ‚ƒ\nÏ„â‚â‚‚ : R â†’+* Râ‚‚\nÏ„â‚‚â‚ƒ : Râ‚‚ â†’+* Râ‚ƒ\nÏ„â‚â‚ƒ : R â†’+* Râ‚ƒ\ninstâœÂ¹ : RingHomCompTriple Ï„â‚â‚‚ Ï„â‚‚â‚ƒ Ï„â‚â‚ƒ\ninstâœ : RingHomSurjective Ï„â‚â‚‚\nf : M â†’â‚›â‚—[Ï„â‚â‚‚] Mâ‚‚\nâŠ¢ range f.rangeRestrict = âŠ¤"
    },
    {
      "name": "LinearMap.range_zero",
      "statement": "R : Type u_1\nRâ‚‚ : Type u_2\nRâ‚ƒ : Type u_3\nK : Type u_4\nKâ‚‚ : Type u_5\nM : Type u_6\nMâ‚‚ : Type u_7\nMâ‚ƒ : Type u_8\nV : Type u_9\nVâ‚‚ : Type u_10\ninstâœÂ¹Â³ : Semiring R\ninstâœÂ¹Â² : Semiring Râ‚‚\ninstâœÂ¹Â¹ : Semiring Râ‚ƒ\ninstâœÂ¹â° : AddCommMonoid M\ninstâœâ¹ : AddCommMonoid Mâ‚‚\ninstâœâ¸ : AddCommMonoid Mâ‚ƒ\nÏƒâ‚â‚‚ : R â†’+* Râ‚‚\nÏƒâ‚‚â‚ƒ : Râ‚‚ â†’+* Râ‚ƒ\nÏƒâ‚â‚ƒ : R â†’+* Râ‚ƒ\ninstâœâ· : RingHomCompTriple Ïƒâ‚â‚‚ Ïƒâ‚‚â‚ƒ Ïƒâ‚â‚ƒ\ninstâœâ¶ : Module R M\ninstâœâµ : Module Râ‚‚ Mâ‚‚\ninstâœâ´ : Module Râ‚ƒ Mâ‚ƒ\nÏƒâ‚‚â‚ : Râ‚‚ â†’+* R\nÏ„â‚â‚‚ : R â†’+* Râ‚‚\nÏ„â‚‚â‚ƒ : Râ‚‚ â†’+* Râ‚ƒ\nÏ„â‚â‚ƒ : R â†’+* Râ‚ƒ\ninstâœÂ³ : RingHomCompTriple Ï„â‚â‚‚ Ï„â‚‚â‚ƒ Ï„â‚â‚ƒ\nF : Type u_11\ninstâœÂ² : FunLike F M Mâ‚‚\ninstâœÂ¹ : SemilinearMapClass F Ï„â‚â‚‚ M Mâ‚‚\ninstâœ : RingHomSurjective Ï„â‚â‚‚\nâŠ¢ range 0 = âŠ¥"
    },
    {
      "name": "LinearMap.subset_bipolar",
      "statement": "ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedCommRing ğ•œ\ninstâœÂ³ : AddCommMonoid E\ninstâœÂ² : AddCommMonoid F\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œ F\nB : E â†’â‚—[ğ•œ] F â†’â‚—[ğ•œ] ğ•œ\ns : Set E\nx : E\nhx : x âˆˆ s\ny : F\nhy : y âˆˆ B.polar s\nâŠ¢ â€–(B.flip y) xâ€– â‰¤ 1"
    },
    {
      "name": "LinearMap.toMatrixâ‚‚'_complâ‚â‚‚",
      "statement": "R : Type u_1\nRâ‚ : Type u_2\nRâ‚‚ : Type u_3\nM : Type u_4\nMâ‚ : Type u_5\nMâ‚‚ : Type u_6\nMâ‚' : Type u_7\nMâ‚‚' : Type u_8\nn : Type u_9\nm : Type u_10\nn' : Type u_11\nm' : Type u_12\nÎ¹ : Type u_13\ninstâœÂ¹â° : CommSemiring R\ninstâœâ¹ : Semiring Râ‚\ninstâœâ¸ : Semiring Râ‚‚\ninstâœâ· : Fintype n\ninstâœâ¶ : Fintype m\ninstâœâµ : DecidableEq n\ninstâœâ´ : DecidableEq m\nÏƒâ‚ : Râ‚ â†’+* R\nÏƒâ‚‚ : Râ‚‚ â†’+* R\ninstâœÂ³ : Fintype n'\ninstâœÂ² : Fintype m'\ninstâœÂ¹ : DecidableEq n'\ninstâœ : DecidableEq m'\nB : (n â†’ R) â†’â‚—[R] (m â†’ R) â†’â‚—[R] R\nl : (n' â†’ R) â†’â‚—[R] n â†’ R\nr : (m' â†’ R) â†’â‚—[R] m â†’ R\nâŠ¢ toMatrixâ‚‚' (B.complâ‚â‚‚ l r) = (toMatrix' l)áµ€ * toMatrixâ‚‚' B * toMatrix' r"
    },
    {
      "name": "LinearPMap.mem_range_iff",
      "statement": "R : Type u_1\ninstâœâ¹ : Ring R\nE : Type u_2\ninstâœâ¸ : AddCommGroup E\ninstâœâ· : Module R E\nF : Type u_3\ninstâœâ¶ : AddCommGroup F\ninstâœâµ : Module R F\nG : Type u_4\ninstâœâ´ : AddCommGroup G\ninstâœÂ³ : Module R G\nM : Type u_5\ninstâœÂ² : Monoid M\ninstâœÂ¹ : DistribMulAction M F\ninstâœ : SMulCommClass R M F\nyâœ : M\nf : E â†’â‚—.[R] F\ny : F\nâŠ¢ y âˆˆ Set.range â†‘f â†” âˆƒ x, (x, y) âˆˆ f.graph"
    },
    {
      "name": "Liouville.liouvilleWith",
      "statement": "x : â„\nhx : Liouville x\np : â„\nâŠ¢ LiouvilleWith p x"
    },
    {
      "name": "LiouvilleWith.int_sub_iff",
      "statement": "p q x y : â„\nr : â„š\nm : â„¤\nn : â„•\nâŠ¢ LiouvilleWith p (â†‘m - x) â†” LiouvilleWith p x"
    },
    {
      "name": "LiouvilleWith.nat_sub_iff",
      "statement": "p q x y : â„\nr : â„š\nm : â„¤\nn : â„•\nâŠ¢ LiouvilleWith p (â†‘n - x) â†” LiouvilleWith p x"
    },
    {
      "name": "LiouvilleWith.sub_nat_iff",
      "statement": "p q x y : â„\nr : â„š\nm : â„¤\nn : â„•\nâŠ¢ LiouvilleWith p (x - â†‘n) â†” LiouvilleWith p x"
    },
    {
      "name": "List.Duplicate.of_duplicate_cons",
      "statement": "Î± : Type u_1\nl : List Î±\nx y : Î±\nh : x âˆˆ+ y :: l\nhx : x â‰  y\nâŠ¢ x âˆˆ+ l"
    },
    {
      "name": "List.Ico.eq_nil_of_le",
      "statement": "n m : â„•\nh : m â‰¤ n\nâŠ¢ Ico n m = []"
    },
    {
      "name": "List.Ico.filter_le_of_bot",
      "statement": "n m : â„•\nhnm : n < m\nâŠ¢ filter (fun x => decide (x â‰¤ n)) (Ico n m) = [n]"
    },
    {
      "name": "List.Ico.filter_le_of_top_le",
      "statement": "n m l : â„•\nhml : m â‰¤ l\nk : â„•\nhk : k âˆˆ Ico n m\nâŠ¢ Â¬decide (l â‰¤ k) = true"
    },
    {
      "name": "List.Ico.filter_lt_of_top_le",
      "statement": "n m l : â„•\nhml : m â‰¤ l\nk : â„•\nhk : k âˆˆ Ico n m\nâŠ¢ decide (k < l) = true"
    },
    {
      "name": "List.Ico.mem",
      "statement": "n m l : â„•\nâŠ¢ l âˆˆ Ico n m â†” n â‰¤ l âˆ§ l < m"
    },
    {
      "name": "List.Ico.pred_singleton",
      "statement": "m : â„•\nh : 0 < m\nâŠ¢ Ico (m - 1) m = [m - 1]"
    },
    {
      "name": "List.IsPrefix.map",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nl lâ‚ lâ‚‚ lâ‚ƒ : List Î±\na b : Î±\nm n : â„•\nh : lâ‚ <+: lâ‚‚\nf : Î± â†’ Î²\nâŠ¢ map f lâ‚ <+: map f lâ‚‚"
    },
    {
      "name": "List.IsRotated.refl",
      "statement": "Î± : Type u\nlâœ l' l : List Î±\nâŠ¢ l.rotate 0 = l"
    },
    {
      "name": "List.IsRotated.symm",
      "statement": "Î± : Type u\nl l' : List Î±\nh : l ~r l'\nâŠ¢ l' ~r l"
    },
    {
      "name": "List.Perm.bagInter_right",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nl lâ‚âœ lâ‚‚âœ : List Î±\na : Î±\ninstâœ : DecidableEq Î±\nlâ‚ lâ‚‚ t : List Î±\nh : lâ‚ ~ lâ‚‚\nâŠ¢ lâ‚.bagInter t ~ lâ‚‚.bagInter t"
    },
    {
      "name": "List.Perm.permutations'",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nl lâ‚ lâ‚‚ : List Î±\na : Î±\ns t : List Î±\np : s ~ t\nâŠ¢ s.permutations' ~ t.permutations'"
    },
    {
      "name": "List.Sublist.reverse",
      "statement": "Î±âœ : Type u_1\nlâ‚âœ lâ‚‚ lâ‚ lâ‚‚âœ : List Î±âœ\naâœ : Î±âœ\nh : lâ‚ <+ lâ‚‚âœ\nâŠ¢ lâ‚.reverse <+ (aâœ :: lâ‚‚âœ).reverse"
    },
    {
      "name": "List.chain_append_cons_cons",
      "statement": "Î± : Type u\nÎ² : Type v\nR r : Î± â†’ Î± â†’ Prop\nl lâ‚âœ lâ‚‚âœ : List Î±\naâœ bâœ a b c : Î±\nlâ‚ lâ‚‚ : List Î±\nâŠ¢ Chain R a (lâ‚ ++ b :: c :: lâ‚‚) â†” Chain R a (lâ‚ ++ [b]) âˆ§ R b c âˆ§ Chain R c lâ‚‚"
    },
    {
      "name": "List.cons_bagInter_of_pos",
      "statement": "Î± : Type u_1\nl lâ‚âœ lâ‚‚ : List Î±\np : Î± â†’ Prop\na : Î±\ninstâœ : DecidableEq Î±\nlâ‚ : List Î±\nh : a âˆˆ lâ‚‚\nâŠ¢ (a :: lâ‚).bagInter lâ‚‚ = a :: lâ‚.bagInter (lâ‚‚.erase a)"
    },
    {
      "name": "List.cons_union",
      "statement": "Î± : Type u_1\ninstâœ : BEq Î±\na : Î±\nlâ‚ lâ‚‚ : List Î±\nâŠ¢ a :: lâ‚ âˆª lâ‚‚ = List.insert a (lâ‚ âˆª lâ‚‚)"
    },
    {
      "name": "List.count_attach",
      "statement": "Î± : Type u_1\nl : List Î±\ninstâœ : DecidableEq Î±\na xâœÂ¹ : { x // x âˆˆ l }\nxâœ : xâœÂ¹ âˆˆ l.attach\nâŠ¢ (xâœÂ¹ == a) = true â†” (â†‘xâœÂ¹ == â†‘a) = true"
    },
    {
      "name": "List.dlookup_kunion_right",
      "statement": "Î± : Type u\nÎ² : Î± â†’ Type v\nl lâ‚âœ lâ‚‚âœ : List (Sigma Î²)\ninstâœ : DecidableEq Î±\na : Î±\nlâ‚ lâ‚‚ : List (Sigma Î²)\nh : a âˆ‰ lâ‚.keys\nâŠ¢ dlookup a (lâ‚.kunion lâ‚‚) = dlookup a lâ‚‚"
    },
    {
      "name": "List.dropWhile_eq_self_iff",
      "statement": "Î± : Type u_1\np : Î± â†’ Bool\nl : List Î±\nn : â„•\nâŠ¢ dropWhile p l = l â†” âˆ€ (hl : 0 < l.length), Â¬p (l.get âŸ¨0, hlâŸ©) = true"
    },
    {
      "name": "List.eraseP_of_forall_not",
      "statement": "Î± : Type u_1\np : Î± â†’ Bool\nl : List Î±\nh : âˆ€ (a : Î±), a âˆˆ l â†’ Â¬p a = true\nâŠ¢ eraseP p l = l"
    },
    {
      "name": "List.extractP_eq_find?_eraseP",
      "statement": "Î± : Type u_1\np : Î± â†’ Bool\nl : List Î±\nâŠ¢ extractP p l = (find? p l, eraseP p l)"
    },
    {
      "name": "List.filter_true",
      "statement": "Î¹ : Type u_1\nÎ± : Type u\nÎ² : Type v\nÎ³ : Type w\nlâ‚ lâ‚‚ : List Î±\np : Î± â†’ Bool\nl : List Î±\nâŠ¢ filter (fun x => true) l = l"
    },
    {
      "name": "List.findIdx_lt_length_of_exists",
      "statement": "case nil\nÎ± : Type u_1\np : Î± â†’ Bool\nh : âˆƒ x, x âˆˆ [] âˆ§ p x = true\nâŠ¢ findIdx p [] < [].length"
    },
    {
      "name": "List.foldr_max_of_ne_nil",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : LinearOrder Î±\ninstâœ : OrderBot Î±\nl : List Î±\nh : l â‰  []\nâŠ¢ â†‘(foldr max âŠ¥ l) = l.maximum"
    },
    {
      "name": "List.forallâ‚‚_eq_eq_eq",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\nR S : Î± â†’ Î² â†’ Prop\nP : Î³ â†’ Î´ â†’ Prop\nRâ‚ : Î± â†’ Î± â†’ Prop\nâŠ¢ (Forallâ‚‚ fun x x_1 => x = x_1) = Eq"
    },
    {
      "name": "List.forallâ‚‚_nil_right_iff",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\nR S : Î± â†’ Î² â†’ Prop\nP : Î³ â†’ Î´ â†’ Prop\nRâ‚ : Î± â†’ Î± â†’ Prop\nl : List Î±\nH : Forallâ‚‚ R l []\nâŠ¢ l = []"
    },
    {
      "name": "List.getD_eq_get",
      "statement": "case nil\nÎ± : Type u\nÎ² : Type v\nl : List Î±\nx : Î±\nxs : List Î±\nnâœ : â„•\nd : Î±\nn : â„•\nhn : n < [].length\nâŠ¢ [].getD n d = [].get âŸ¨n, hnâŸ©"
    },
    {
      "name": "List.get_attach",
      "statement": "Î¹ : Type u_1\nÎ± : Type u\nÎ² : Type v\nÎ³ : Type w\nlâ‚ lâ‚‚ L : List Î±\ni : Fin L.attach.length\nâŠ¢ â†‘(L.attach.get i) = L.get âŸ¨â†‘i, â‹¯âŸ©"
    },
    {
      "name": "List.head_cyclicPermutations",
      "statement": "Î± : Type u\nlâœ l' l : List Î±\nâŠ¢ l.cyclicPermutations.head â‹¯ = l"
    },
    {
      "name": "List.isSublist_iff_sublist",
      "statement": "Î± : Type u_1\ninstâœÂ¹ : BEq Î±\ninstâœ : LawfulBEq Î±\nlâ‚ lâ‚‚ : List Î±\nâŠ¢ lâ‚.isSublist lâ‚‚ = true â†” lâ‚ <+ lâ‚‚"
    },
    {
      "name": "List.length_merge",
      "statement": "Î± : Type u_1\ns : Î± â†’ Î± â†’ Bool\nl râœ r : List Î±\nâŠ¢ (merge s [] r).length = [].length + r.length"
    },
    {
      "name": "List.mapIdx_append_one",
      "statement": "Î± : Type u\nÎ² : Type v\nâŠ¢ âˆ€ (f : â„• â†’ Î± â†’ Î²) (l : List Î±) (e : Î±), mapIdx f (l ++ [e]) = mapIdx f l ++ [f l.length e]"
    },
    {
      "name": "List.map_injective_iff",
      "statement": "Î¹ : Type u_1\nÎ± : Type u\nÎ² : Type v\nÎ³ : Type w\nlâ‚ lâ‚‚ : List Î±\nf : Î± â†’ Î²\nh : Injective (map f)\nx y : Î±\nhxy : f x = f y\nâŠ¢ x = y"
    },
    {
      "name": "List.map_leftInverse_iff",
      "statement": "Î¹ : Type u_1\nÎ± : Type u\nÎ² : Type v\nÎ³ : Type w\nlâ‚ lâ‚‚ : List Î±\nf : Î± â†’ Î²\ng : Î² â†’ Î±\nh : LeftInverse (map f) (map g)\nx : Î²\nâŠ¢ f (g x) = x"
    },
    {
      "name": "List.mem_dedup",
      "statement": "case refine_2\nÎ± : Type u\ninstâœ : DecidableEq Î±\na : Î±\nl : List Î±\nthis : (Â¬âˆ€ b âˆˆ pwFilter (fun x x_1 => x â‰  x_1) l, a â‰  b) â†” Â¬âˆ€ b âˆˆ l, a â‰  b\nâŠ¢ a âˆˆ l.dedup â†” a âˆˆ l"
    },
    {
      "name": "List.mem_eraseP_of_neg",
      "statement": "Î± : Type u_1\np : Î± â†’ Bool\na : Î±\nl : List Î±\npa : Â¬p a = true\nâŠ¢ a âˆˆ eraseP p l â†” a âˆˆ l"
    },
    {
      "name": "List.mem_inits",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nl lâ‚ lâ‚‚ lâ‚ƒ : List Î±\na b : Î±\nm n : â„•\ns : List Î±\nthis : s = [] â†” s <+: []\nâŠ¢ s âˆˆ [].inits â†” s <+: []"
    },
    {
      "name": "List.mem_orderedInsert",
      "statement": "Î± : Type u\nr : Î± â†’ Î± â†’ Prop\ninstâœ : DecidableRel r\na b : Î±\nl : List Î±\nâŠ¢ a âˆˆ orderedInsert r b [] â†” a = b âˆ¨ a âˆˆ []"
    },
    {
      "name": "List.mem_sublists'",
      "statement": "Î± : Type u\nÎ² : Type v\nÎ³ : Type w\ns t : List Î±\nâŠ¢ s âˆˆ t.sublists' â†” s <+ t"
    },
    {
      "name": "List.mergeSort_nil",
      "statement": "Î± : Type u\nr : Î± â†’ Î± â†’ Prop\ninstâœ : DecidableRel r\nâŠ¢ mergeSort r [] = []"
    },
    {
      "name": "List.nil_eq_rotate_iff",
      "statement": "Î± : Type u\nl : List Î±\nn : â„•\nâŠ¢ [] = l.rotate n â†” [] = l"
    },
    {
      "name": "List.nodup_sublists'",
      "statement": "Î± : Type u\nÎ² : Type v\nÎ³ : Type w\nl : List Î±\nâŠ¢ l.sublists'.Nodup â†” l.Nodup"
    },
    {
      "name": "List.ofFnRec_ofFn",
      "statement": "Î± : Type u\nC : List Î± â†’ Sort u_1\nh : (n : â„•) â†’ (f : Fin n â†’ Î±) â†’ C (ofFn f)\nn : â„•\nf : Fin n â†’ Î±\nâŠ¢ ofFnRec h (ofFn f) = h n f"
    },
    {
      "name": "List.perm_append_singleton",
      "statement": "Î± : Type u_1\na : Î±\nl : List Î±\nâŠ¢ a :: (l ++ []) ~ a :: l"
    },
    {
      "name": "List.permutationsAux_cons",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nt : Î±\nts is : List Î±\nâŠ¢ (t :: ts).permutationsAux is =\n    foldr (fun y r => (permutationsAux2 t ts r y id).2) (ts.permutationsAux (t :: is)) is.permutations"
    },
    {
      "name": "List.pmap_append",
      "statement": "Î¹ : Type u_1\nÎ± : Type u\nÎ² : Type v\nÎ³ : Type w\nlâ‚âœ lâ‚‚âœ : List Î±\np : Î¹ â†’ Prop\nf : (a : Î¹) â†’ p a â†’ Î±\nlâ‚ lâ‚‚ : List Î¹\nh : âˆ€ (a : Î¹), a âˆˆ lâ‚ ++ lâ‚‚ â†’ p a\nâŠ¢ pmap f (lâ‚ ++ lâ‚‚) h = pmap f lâ‚ â‹¯ ++ pmap f lâ‚‚ â‹¯"
    },
    {
      "name": "List.prod_eq_one",
      "statement": "Î¹ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nM : Type u_4\nN : Type u_5\nP : Type u_6\nG : Type u_7\ninstâœÂ² : Monoid M\ninstâœÂ¹ : Monoid N\ninstâœ : Monoid P\nl lâ‚ lâ‚‚ : List M\na : M\nhl : âˆ€ x âˆˆ l, x = 1\nâŠ¢ l.prod = 1"
    },
    {
      "name": "List.prod_map_erase",
      "statement": "Î¹ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nM : Type u_4\nN : Type u_5\nP : Type u_6\nG : Type u_7\ninstâœÂ¹ : CommMonoid M\naâœ : M\nlâœ lâ‚ lâ‚‚ : List M\ninstâœ : DecidableEq Î±\nf : Î± â†’ M\na b : Î±\nl : List Î±\nh : a âˆˆ b :: l\nâŠ¢ f a * (map f ((b :: l).erase a)).prod = (map f (b :: l)).prod"
    },
    {
      "name": "List.prod_set",
      "statement": "Î¹ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nM : Type u_4\nN : Type u_5\nP : Type u_6\nG : Type u_7\ninstâœÂ² : Monoid M\ninstâœÂ¹ : Monoid N\ninstâœ : Monoid P\nl lâ‚ lâ‚‚ : List M\naâœ x : M\nxs : List M\na : M\nâŠ¢ ((x :: xs).set 0 a).prod =\n    ((take 0 (x :: xs)).prod * if 0 < (x :: xs).length then a else 1) * (drop (0 + 1) (x :: xs)).prod"
    },
    {
      "name": "List.rdropWhile_eq_nil_iff",
      "statement": "Î± : Type u_1\np : Î± â†’ Bool\nl : List Î±\nn : â„•\nâŠ¢ rdropWhile p l = [] â†” âˆ€ (x : Î±), x âˆˆ l â†’ p x = true"
    },
    {
      "name": "List.rotate'_length_mul",
      "statement": "Î± : Type u\nl : List Î±\nâŠ¢ l.rotate' (l.length * 0) = l"
    },
    {
      "name": "List.subperm_singleton_iff",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nl lâ‚ lâ‚‚ : List Î±\na : Î±\nâŠ¢ l <+~ [a] â†” l = [] âˆ¨ l = [a]"
    },
    {
      "name": "List.suffix_insert",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nlâœ lâ‚ lâ‚‚ lâ‚ƒ : List Î±\naâœ b : Î±\nm n : â„•\ninstâœ : DecidableEq Î±\na : Î±\nl : List Î±\nâŠ¢ l <:+ List.insert a l"
    },
    {
      "name": "List.tail_append_of_ne_nil",
      "statement": "Î¹ : Type u_1\nÎ± : Type u\nÎ² : Type v\nÎ³ : Type w\nlâ‚ lâ‚‚ l l' : List Î±\nh : l â‰  []\nâŠ¢ (l ++ l').tail = l.tail ++ l'"
    },
    {
      "name": "List.tail_drop",
      "statement": "case nil\nÎ± : Type u_1\nn : Nat\nâŠ¢ (drop n []).tail = drop (n + 1) []"
    },
    {
      "name": "List.takeWhile_cons_of_neg",
      "statement": "Î¹ : Type u_1\nÎ± : Type u\nÎ² : Type v\nÎ³ : Type w\nlâ‚ lâ‚‚ : List Î±\np : Î± â†’ Bool\nl : List Î±\nx : Î±\nh : Â¬p x = true\nâŠ¢ takeWhile p (x :: l) = []"
    },
    {
      "name": "List.takeWhile_cons_of_pos",
      "statement": "Î¹ : Type u_1\nÎ± : Type u\nÎ² : Type v\nÎ³ : Type w\nlâ‚ lâ‚‚ : List Î±\np : Î± â†’ Bool\nl : List Î±\nx : Î±\nh : p x = true\nâŠ¢ takeWhile p (x :: l) = x :: takeWhile p l"
    },
    {
      "name": "List.takeWhile_eq_nil_iff",
      "statement": "Î¹ : Type u_1\nÎ± : Type u\nÎ² : Type v\nÎ³ : Type w\nlâ‚ lâ‚‚ : List Î±\np : Î± â†’ Bool\nl : List Î±\nâŠ¢ takeWhile p l = [] â†” âˆ€ (hl : 0 < l.length), Â¬p (l.nthLe 0 hl) = true"
    },
    {
      "name": "List.take_range",
      "statement": "Î± : Type u\nm n : â„•\nâŠ¢ take m (range n) = range (min m n)"
    },
    {
      "name": "Localization.mk_self",
      "statement": "M : Type u_1\ninstâœÂ² : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninstâœÂ¹ : CommMonoid N\nP : Type u_3\ninstâœ : CommMonoid P\na : â†¥S\nâŠ¢ mk (â†‘a) a = 1"
    },
    {
      "name": "LocalizedModule.mk_cancel_common_left",
      "statement": "R : Type u\ninstâœâµ : CommSemiring R\nS : Submonoid R\nM : Type v\ninstâœâ´ : AddCommMonoid M\ninstâœÂ³ : Module R M\nT : Type u_1\ninstâœÂ² : CommSemiring T\ninstâœÂ¹ : Algebra R T\ninstâœ : IsLocalization S T\ns' s : â†¥S\nm : M\nâŠ¢ 1 â€¢ s â€¢ s' â€¢ m = 1 â€¢ (s' * s) â€¢ m"
    },
    {
      "name": "LocalizedModule.smul'_mul",
      "statement": "R : Type u\ninstâœâ· : CommSemiring R\nS : Submonoid R\nM : Type v\ninstâœâ¶ : AddCommMonoid M\ninstâœâµ : Module R M\nT : Type u_1\ninstâœâ´ : CommSemiring T\ninstâœÂ³ : Algebra R T\ninstâœÂ² : IsLocalization S T\nA : Type u_2\ninstâœÂ¹ : Semiring A\ninstâœ : Algebra R A\nx : T\npâ‚ pâ‚‚ : LocalizedModule S A\nâŠ¢ x â€¢ pâ‚ * pâ‚‚ = x â€¢ (pâ‚ * pâ‚‚)"
    },
    {
      "name": "LowerSet.Iic_sInf",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ¹ : Sort u_4\nÎº : Î¹ â†’ Sort u_5\ninstâœ : CompleteLattice Î±\nS : Set Î±\nc : Î±\nâŠ¢ c âˆˆ Iic (sInf S) â†” c âˆˆ â¨… a âˆˆ S, Iic a"
    },
    {
      "name": "LowerSet.coe_iSupâ‚‚",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ¹ : Sort u_4\nÎº : Î¹ â†’ Sort u_5\ninstâœ : LE Î±\nS : Set (LowerSet Î±)\ns t : LowerSet Î±\na : Î±\nf : (i : Î¹) â†’ Îº i â†’ LowerSet Î±\nâŠ¢ â†‘(â¨† i, â¨† j, f i j) = â‹ƒ i, â‹ƒ j, â†‘(f i j)"
    },
    {
      "name": "LowerSet.disjoint_coe",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ¹ : Sort u_4\nÎº : Î¹ â†’ Sort u_5\ninstâœ : LE Î±\nS : Set (LowerSet Î±)\ns t : LowerSet Î±\na : Î±\nâŠ¢ Disjoint â†‘s â†‘t â†” Disjoint s t"
    },
    {
      "name": "LowerSet.mem_iSup_iff",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ¹ : Sort u_4\nÎº : Î¹ â†’ Sort u_5\ninstâœ : LE Î±\nS : Set (LowerSet Î±)\ns t : LowerSet Î±\na : Î±\nf : Î¹ â†’ LowerSet Î±\nâŠ¢ a âˆˆ â¨† i, f i â†” âˆƒ i, a âˆˆ f i"
    },
    {
      "name": "LucasLehmer.X.ext",
      "statement": "q : â„•+\nx y : X q\nhâ‚ : x.1 = y.1\nhâ‚‚ : x.2 = y.2\nâŠ¢ x = y"
    },
    {
      "name": "Mathlib.Meta.NormNum.isInt_emod_neg",
      "statement": "a b : â„¤\nr : â„•\nh : IsNat (a % -b) r\nâŠ¢ a % b = â†‘r"
    },
    {
      "name": "Mathlib.Meta.NormNum.isRat_div",
      "statement": "Î± : Type u_1\ninstâœ : DivisionRing Î±\nxâœÂ³ xâœÂ² : Î±\nxâœÂ¹ : â„¤\nxâœ : â„•\nh : IsRat (xâœÂ³ * xâœÂ²â»Â¹) xâœÂ¹ xâœ\nâŠ¢ IsRat (xâœÂ³ / xâœÂ²) xâœÂ¹ xâœ"
    },
    {
      "name": "Mathlib.Tactic.Abel.subst_into_addg",
      "statement": "Î± : Type u_1\ninstâœ : AddCommGroup Î±\nl r tl tr t : Î±\nprl : l = tl\nprr : r = tr\nprt : tl + tr = t\nâŠ¢ l + r = t"
    },
    {
      "name": "Mathlib.Tactic.ComputeDegree.coeff_add_of_eq",
      "statement": "R : Type u_1\ninstâœ : Semiring R\nn : â„•\na b : R\nf g : R[X]\nh_add_left : f.coeff n = a\nh_add_right : g.coeff n = b\nâŠ¢ (f + g).coeff n = a + b"
    },
    {
      "name": "Mathlib.Tactic.Ring.atom_pf",
      "statement": "u : Lean.Level\nR : Type u_1\nÎ± : Q(Type u)\nsÎ± : Q(CommSemiring Â«$Î±Â»)\ninstâœ : CommSemiring R\na : R\nâŠ¢ a = a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0"
    },
    {
      "name": "Matrix.IsAdjMatrix.apply_diag_ne",
      "statement": "V : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nA : Matrix V V Î±\ninstâœÂ¹ : MulZeroOneClass Î±\ninstâœ : Nontrivial Î±\nh : A.IsAdjMatrix\ni : V\nâŠ¢ Â¬A i i = 1"
    },
    {
      "name": "Matrix.J_squared",
      "statement": "l : Type u_1\nR : Type u_2\ninstâœÂ² : DecidableEq l\ninstâœÂ¹ : CommRing R\ninstâœ : Fintype l\nâŠ¢ J l R * J l R = -1"
    },
    {
      "name": "Matrix.PosDef.posSemidef",
      "statement": "m : Type u_1\nn : Type u_2\nR : Type u_3\nğ•œ : Type u_4\ninstâœâ¶ : Fintype m\ninstâœâµ : Fintype n\ninstâœâ´ : CommRing R\ninstâœÂ³ : PartialOrder R\ninstâœÂ² : StarRing R\ninstâœÂ¹ : StarOrderedRing R\ninstâœ : RCLike ğ•œ\nM : Matrix n n R\nhM : M.PosDef\nâŠ¢ M.PosSemidef"
    },
    {
      "name": "Matrix.PosDef.transpose",
      "statement": "m : Type u_1\nn : Type u_2\nR : Type u_3\nğ•œ : Type u_4\ninstâœâ¶ : Fintype m\ninstâœâµ : Fintype n\ninstâœâ´ : CommRing R\ninstâœÂ³ : PartialOrder R\ninstâœÂ² : StarRing R\ninstâœÂ¹ : StarOrderedRing R\ninstâœ : RCLike ğ•œ\nM : Matrix n n R\nhM : M.PosDef\nâŠ¢ Máµ€.PosDef"
    },
    {
      "name": "Matrix.StdBasisMatrix.apply_of_ne",
      "statement": "l : Type u_1\nm : Type u_2\nn : Type u_3\nR : Type u_4\nÎ± : Type u_5\ninstâœÂ³ : DecidableEq l\ninstâœÂ² : DecidableEq m\ninstâœÂ¹ : DecidableEq n\ninstâœ : Semiring Î±\ni : m\nj : n\nc : Î±\ni' : m\nj' : n\nh : Â¬(i = i' âˆ§ j = j')\nâŠ¢ stdBasisMatrix i j c i' j' = 0"
    },
    {
      "name": "Matrix.adjugate_mul_distrib",
      "statement": "m : Type u\nn : Type v\nÎ± : Type w\ninstâœâ´ : DecidableEq n\ninstâœÂ³ : Fintype n\ninstâœÂ² : DecidableEq m\ninstâœÂ¹ : Fintype m\ninstâœ : CommRing Î±\nA B : Matrix n n Î±\nâŠ¢ (A * B).adjugate = B.adjugate * A.adjugate"
    },
    {
      "name": "Matrix.blockDiag'_diagonal",
      "statement": "l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\np : Type u_5\nq : Type u_6\nm' : o â†’ Type u_7\nn' : o â†’ Type u_8\np' : o â†’ Type u_9\nR : Type u_10\nS : Type u_11\nÎ± : Type u_12\nÎ² : Type u_13\ninstâœÂ³ : Zero Î±\ninstâœÂ² : Zero Î²\ninstâœÂ¹ : DecidableEq o\ninstâœ : (i : o) â†’ DecidableEq (m' i)\nd : (i : o) Ã— m' i â†’ Î±\nk : o\ni j : m' k\nâŠ¢ (diagonal d).blockDiag' k i j = diagonal (fun i => d âŸ¨k, iâŸ©) i j"
    },
    {
      "name": "Matrix.blockDiagonal'_diagonal",
      "statement": "l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\np : Type u_5\nq : Type u_6\nm' : o â†’ Type u_7\nn' : o â†’ Type u_8\np' : o â†’ Type u_9\nR : Type u_10\nS : Type u_11\nÎ± : Type u_12\nÎ² : Type u_13\ninstâœÂ³ : DecidableEq o\ninstâœÂ² : Zero Î±\ninstâœÂ¹ : Zero Î²\ninstâœ : (i : o) â†’ DecidableEq (m' i)\nd : (i : o) â†’ m' i â†’ Î±\nâŠ¢ (blockDiagonal' fun k => diagonal (d k)) = diagonal fun ik => d ik.fst ik.snd"
    },
    {
      "name": "Matrix.blockDiagonal'_transpose",
      "statement": "l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\np : Type u_5\nq : Type u_6\nm' : o â†’ Type u_7\nn' : o â†’ Type u_8\np' : o â†’ Type u_9\nR : Type u_10\nS : Type u_11\nÎ± : Type u_12\nÎ² : Type u_13\ninstâœÂ² : DecidableEq o\ninstâœÂ¹ : Zero Î±\ninstâœ : Zero Î²\nM : (i : o) â†’ Matrix (m' i) (n' i) Î±\nâŠ¢ (blockDiagonal' M)áµ€ = blockDiagonal' fun k => (M k)áµ€"
    },
    {
      "name": "Matrix.blockDiagonal_add",
      "statement": "l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\np : Type u_5\nq : Type u_6\nm' : o â†’ Type u_7\nn' : o â†’ Type u_8\np' : o â†’ Type u_9\nR : Type u_10\nS : Type u_11\nÎ± : Type u_12\nÎ² : Type u_13\ninstâœÂ¹ : DecidableEq o\ninstâœ : AddZeroClass Î±\nM N : o â†’ Matrix m n Î±\nâŠ¢ blockDiagonal (M + N) = blockDiagonal M + blockDiagonal N"
    },
    {
      "name": "Matrix.charmatrix_apply_ne",
      "statement": "R : Type u_1\nS : Type u_2\ninstâœâµ : CommRing R\ninstâœâ´ : CommRing S\nm : Type u_3\nn : Type u_4\ninstâœÂ³ : DecidableEq m\ninstâœÂ² : DecidableEq n\ninstâœÂ¹ : Fintype m\ninstâœ : Fintype n\nMâ‚â‚ : Matrix m m R\nMâ‚â‚‚ : Matrix m n R\nMâ‚‚â‚ : Matrix n m R\nMâ‚‚â‚‚ M : Matrix n n R\ni j : n\nh : i â‰  j\nâŠ¢ M.charmatrix i j = -C (M i j)"
    },
    {
      "name": "Matrix.charpoly.univ_coeff_card",
      "statement": "R : Type u_1\nS : Type u_2\nn : Type u_3\ninstâœÂ³ : CommRing R\ninstâœÂ² : CommRing S\ninstâœÂ¹ : Fintype n\ninstâœ : DecidableEq n\nf : R â†’+* S\nâŠ¢ (univ R n).coeff (Fintype.card n) = 1"
    },
    {
      "name": "Matrix.conjTranspose_one",
      "statement": "l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nm' : o â†’ Type u_5\nn' : o â†’ Type u_6\nR : Type u_7\nS : Type u_8\nÎ± : Type v\nÎ² : Type w\nÎ³ : Type u_9\ninstâœÂ² : DecidableEq n\ninstâœÂ¹ : Semiring Î±\ninstâœ : StarRing Î±\nâŠ¢ 1á´´ = 1"
    },
    {
      "name": "Matrix.conjTranspose_zero",
      "statement": "l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nm' : o â†’ Type u_5\nn' : o â†’ Type u_6\nR : Type u_7\nS : Type u_8\nÎ± : Type v\nÎ² : Type w\nÎ³ : Type u_9\ninstâœÂ¹ : AddMonoid Î±\ninstâœ : StarAddMonoid Î±\nâŠ¢ âˆ€ (i : n) (j : m), 0á´´ i j = 0 i j"
    },
    {
      "name": "Matrix.conjTranspose_zpow",
      "statement": "n' : Type u_1\ninstâœÂ³ : DecidableEq n'\ninstâœÂ² : Fintype n'\nR : Type u_2\ninstâœÂ¹ : CommRing R\ninstâœ : StarRing R\nA : M\nn : â„•\nâŠ¢ (A ^ â†‘n)á´´ = Aá´´ ^ â†‘n"
    },
    {
      "name": "Matrix.cons_add",
      "statement": "Î± : Type u\nm n o : â„•\nm' : Type u_1\nn' : Type u_2\no' : Type u_3\ninstâœ : Add Î±\nx : Î±\nv : Fin n â†’ Î±\nw : Fin n.succ â†’ Î±\nâŠ¢ vecCons x v + w = vecCons (x + vecHead w) (v + vecTail w)"
    },
    {
      "name": "Matrix.cons_add_cons",
      "statement": "Î± : Type u\nm n o : â„•\nm' : Type u_1\nn' : Type u_2\no' : Type u_3\ninstâœ : Add Î±\nx : Î±\nv : Fin n â†’ Î±\ny : Î±\nw : Fin n â†’ Î±\nâŠ¢ vecCons x v + vecCons y w = vecCons (x + y) (v + w)"
    },
    {
      "name": "Matrix.cons_sub",
      "statement": "Î± : Type u\nm n o : â„•\nm' : Type u_1\nn' : Type u_2\no' : Type u_3\ninstâœ : Sub Î±\nx : Î±\nv : Fin n â†’ Î±\nw : Fin n.succ â†’ Î±\nâŠ¢ vecCons x v - w = vecCons (x - vecHead w) (v - vecTail w)"
    },
    {
      "name": "Matrix.cons_vecAlt0",
      "statement": "Î± : Type u\nm n o : â„•\nm' : Type u_1\nn' : Type u_2\no' : Type u_3\nh : m + 1 + 1 = n + 1 + (n + 1)\nx y : Î±\nu : Fin m â†’ Î±\nâŠ¢ m = n + n"
    },
    {
      "name": "Matrix.cons_vecMulVec",
      "statement": "Î± : Type u\no n m : â„•\nm' : Type uâ‚˜\nn' : Type uâ‚™\no' : Type uâ‚’\na b : â„•\ninstâœ : NonUnitalNonAssocSemiring Î±\nx : Î±\nv : Fin m â†’ Î±\nw : n' â†’ Î±\nâŠ¢ vecMulVec (vecCons x v) w = vecCons (x â€¢ w) (vecMulVec v w)"
    },
    {
      "name": "Matrix.det_diagonal",
      "statement": "m : Type u_1\nn : Type u_2\ninstâœâ´ : DecidableEq n\ninstâœÂ³ : Fintype n\ninstâœÂ² : DecidableEq m\ninstâœÂ¹ : Fintype m\nR : Type v\ninstâœ : CommRing R\nd : n â†’ R\nâŠ¢ (diagonal d).det = âˆ i : n, d i"
    },
    {
      "name": "Matrix.det_eq_of_eq_det_one_mul",
      "statement": "m : Type u_1\nn : Type u_2\ninstâœâ´ : DecidableEq n\ninstâœÂ³ : Fintype n\ninstâœÂ² : DecidableEq m\ninstâœÂ¹ : Fintype m\nR : Type v\ninstâœ : CommRing R\nA B C : Matrix n n R\nhC : C.det = 1\nhA : A = C * B\nâŠ¢ C.det * B.det = B.det"
    },
    {
      "name": "Matrix.det_isEmpty",
      "statement": "m : Type u_1\nn : Type u_2\ninstâœâµ : DecidableEq n\ninstâœâ´ : Fintype n\ninstâœÂ³ : DecidableEq m\ninstâœÂ² : Fintype m\nR : Type v\ninstâœÂ¹ : CommRing R\ninstâœ : IsEmpty n\nA : Matrix n n R\nâŠ¢ A.det = 1"
    },
    {
      "name": "Matrix.diagonal_smul",
      "statement": "l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nm' : o â†’ Type u_5\nn' : o â†’ Type u_6\nR : Type u_7\nS : Type u_8\nÎ± : Type v\nÎ² : Type w\nÎ³ : Type u_9\ninstâœÂ² : DecidableEq n\ninstâœÂ¹ : Zero Î±\ninstâœ : SMulZeroClass R Î±\nr : R\nd : n â†’ Î±\nâŠ¢ diagonal (r â€¢ d) = r â€¢ diagonal d"
    },
    {
      "name": "Matrix.frobenius_nnnorm_diagonal",
      "statement": "R : Type u_1\nl : Type u_2\nm : Type u_3\nn : Type u_4\nÎ± : Type u_5\nÎ² : Type u_6\nÎ¹ : Type u_7\ninstâœâ¶ : Fintype l\ninstâœâµ : Fintype m\ninstâœâ´ : Fintype n\ninstâœÂ³ : Unique Î¹\ninstâœÂ² : SeminormedAddCommGroup Î±\ninstâœÂ¹ : SeminormedAddCommGroup Î²\ninstâœ : DecidableEq n\nv : n â†’ Î±\nâŠ¢ â€–diagonal vâ€–â‚Š = â€–(WithLp.equiv 2 (n â†’ Î±)).symm vâ€–â‚Š"
    },
    {
      "name": "Matrix.isUnit_det_transpose",
      "statement": "l : Type u_1\nm : Type u\nn : Type u'\nÎ± : Type v\ninstâœÂ² : Fintype n\ninstâœÂ¹ : DecidableEq n\ninstâœ : CommRing Î±\nA B : Matrix n n Î±\nh : IsUnit A.det\nâŠ¢ IsUnit Aáµ€.det"
    },
    {
      "name": "Matrix.isUnit_fromBlocks_zeroâ‚â‚‚",
      "statement": "l : Type u_1\nm : Type u_2\nn : Type u_3\nÎ± : Type u_4\ninstâœâ¶ : Fintype l\ninstâœâµ : Fintype m\ninstâœâ´ : Fintype n\ninstâœÂ³ : DecidableEq l\ninstâœÂ² : DecidableEq m\ninstâœÂ¹ : DecidableEq n\ninstâœ : CommRing Î±\nA : Matrix m m Î±\nC : Matrix n m Î±\nD : Matrix n n Î±\nâŠ¢ IsUnit (fromBlocks A 0 C D) â†” IsUnit A âˆ§ IsUnit D"
    },
    {
      "name": "Matrix.mul_nonsing_inv",
      "statement": "l : Type u_1\nm : Type u\nn : Type u'\nÎ± : Type v\ninstâœÂ² : Fintype n\ninstâœÂ¹ : DecidableEq n\ninstâœ : CommRing Î±\nA B : Matrix n n Î±\nh : IsUnit A.det\nâŠ¢ A * Aâ»Â¹ = 1"
    },
    {
      "name": "Matrix.rank_le_card_width",
      "statement": "l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nR : Type u_5\ninstâœÂ³ : Fintype n\ninstâœÂ² : Fintype o\ninstâœÂ¹ : CommRing R\ninstâœ : StrongRankCondition R\nA : Matrix m n R\nâŠ¢ A.rank â‰¤ Fintype.card n"
    },
    {
      "name": "Matrix.toBlocksâ‚‚â‚‚_diagonal",
      "statement": "l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\np : Type u_5\nq : Type u_6\nm' : o â†’ Type u_7\nn' : o â†’ Type u_8\np' : o â†’ Type u_9\nR : Type u_10\nS : Type u_11\nÎ± : Type u_12\nÎ² : Type u_13\ninstâœÂ² : DecidableEq l\ninstâœÂ¹ : DecidableEq m\ninstâœ : Zero Î±\nv : l âŠ• m â†’ Î±\nâŠ¢ (diagonal v).toBlocksâ‚‚â‚‚ = diagonal fun i => v (Sum.inr i)"
    },
    {
      "name": "Matrix.transvection_mul_apply_same",
      "statement": "n : Type u_1\np : Type u_2\nR : Type uâ‚‚\nğ•œ : Type u_3\ninstâœâ´ : Field ğ•œ\ninstâœÂ³ : DecidableEq n\ninstâœÂ² : DecidableEq p\ninstâœÂ¹ : CommRing R\ni j : n\ninstâœ : Fintype n\nb : n\nc : R\nM : Matrix n n R\nâŠ¢ (transvection i j c * M) i b = M i b + c * M j b"
    },
    {
      "name": "Matrix.zpow_add",
      "statement": "n' : Type u_1\ninstâœÂ² : DecidableEq n'\ninstâœÂ¹ : Fintype n'\nR : Type u_2\ninstâœ : CommRing R\nA : M\nha : IsUnit A.det\nm n : â„¤\nâŠ¢ A ^ (m + n) = A ^ m * A ^ n"
    },
    {
      "name": "Matroid.comap_dep_iff",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nE I s : Set Î±\nM : Matroid Î±\nN : Matroid Î²\nâŠ¢ (N.comap f).Dep I â†” N.Dep (f '' I) âˆ¨ N.Indep (f '' I) âˆ§ Â¬InjOn f I"
    },
    {
      "name": "Matroid.emptyOn_dual_eq",
      "statement": "Î± : Type u_1\nM : Matroid Î±\nE B I X R J : Set Î±\nâŠ¢ (emptyOn Î±)âœ¶ = emptyOn Î±"
    },
    {
      "name": "Matroid.indep_or_dep",
      "statement": "Î± : Type u_1\nM : Matroid Î±\nX : Set Î±\nhX : autoParam (X âŠ† M.E) _autoâœ\nâŠ¢ M.Indep X âˆ¨ M.Dep X"
    },
    {
      "name": "Matroid.loopyOn_indep_iff",
      "statement": "Î± : Type u_1\nM : Matroid Î±\nE B I X R J : Set Î±\nâŠ¢ (loopyOn E).Indep I â†” I = âˆ…"
    },
    {
      "name": "Matroid.not_dep_iff",
      "statement": "Î± : Type u_1\nM : Matroid Î±\nX : Set Î±\nhX : autoParam (X âŠ† M.E) _autoâœ\nâŠ¢ Â¬M.Dep X â†” M.Indep X"
    },
    {
      "name": "Matroid.restrict_ground_eq_self",
      "statement": "Î± : Type u_1\nMâœ : Matroid Î±\nR I J X Y : Set Î±\nM : Matroid Î±\nâŠ¢ M â†¾ M.E = M"
    },
    {
      "name": "Measurable.stronglyMeasurable",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ¹ : Type u_4\ninstâœâµ : Countable Î¹\nf g : Î± â†’ Î²\nmÎ± : MeasurableSpace Î±\ninstâœâ´ : MeasurableSpace Î²\ninstâœÂ³ : TopologicalSpace Î²\ninstâœÂ² : PseudoMetrizableSpace Î²\ninstâœÂ¹ : SecondCountableTopology Î²\ninstâœ : OpensMeasurableSpace Î²\nhf : Measurable f\nâŠ¢ StronglyMeasurable f"
    },
    {
      "name": "MeasurableEquiv.coe_piCongrLeft",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\nÎ´' : Type u_5\nÎ¹ : Sort uÎ¹\ns t u : Set Î±\ninstâœâµ : MeasurableSpace Î±\ninstâœâ´ : MeasurableSpace Î²\ninstâœÂ³ : MeasurableSpace Î³\ninstâœÂ² : MeasurableSpace Î´\nÏ€ : Î´' â†’ Type u_6\nÏ€' : Î´' â†’ Type u_7\ninstâœÂ¹ : (x : Î´') â†’ MeasurableSpace (Ï€ x)\ninstâœ : (x : Î´') â†’ MeasurableSpace (Ï€' x)\nf : Î´ â‰ƒ Î´'\nâŠ¢ â‡‘(piCongrLeft Ï€ f) = â‡‘(Equiv.piCongrLeft Ï€ f)"
    },
    {
      "name": "MeasurableEquiv.coe_sumPiEquivProdPi_symm",
      "statement": "Î±âœ : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\nÎ´' : Type u_5\nÎ¹ : Sort uÎ¹\ns t u : Set Î±âœ\ninstâœâ¶ : MeasurableSpace Î±âœ\ninstâœâµ : MeasurableSpace Î²\ninstâœâ´ : MeasurableSpace Î³\ninstâœÂ³ : MeasurableSpace Î´\nÏ€ : Î´' â†’ Type u_6\nÏ€' : Î´' â†’ Type u_7\ninstâœÂ² : (x : Î´') â†’ MeasurableSpace (Ï€ x)\ninstâœÂ¹ : (x : Î´') â†’ MeasurableSpace (Ï€' x)\nÎ± : Î´ âŠ• Î´' â†’ Type u_8\ninstâœ : (i : Î´ âŠ• Î´') â†’ MeasurableSpace (Î± i)\nâŠ¢ â‡‘(sumPiEquivProdPi Î±).symm = â‡‘(Equiv.sumPiEquivProdPi Î±).symm"
    },
    {
      "name": "MeasurableSet.cond",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\nÎ´' : Type u_5\nÎ¹ : Sort u_6\ns t u : Set Î±\nm : MeasurableSpace Î±\nsâ‚ sâ‚‚ : Set Î±\nhâ‚ : MeasurableSet sâ‚\nhâ‚‚ : MeasurableSet sâ‚‚\ni : Bool\nâŠ¢ MeasurableSet (bif i then sâ‚ else sâ‚‚)"
    },
    {
      "name": "MeasureTheory.AEDisjoint.iUnion_left_iff",
      "statement": "Î¹ : Type u_1\nÎ± : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : Measure Î±\nsâœ t u v : Set Î±\ninstâœ : Countable Î¹\ns : Î¹ â†’ Set Î±\nâŠ¢ AEDisjoint Î¼ (â‹ƒ i, s i) t â†” âˆ€ (i : Î¹), AEDisjoint Î¼ (s i) t"
    },
    {
      "name": "MeasureTheory.AEEqFun.mk_coeFn",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\ninstâœÂ³ : MeasurableSpace Î±\nÎ¼ Î½ : Measure Î±\ninstâœÂ² : TopologicalSpace Î²\ninstâœÂ¹ : TopologicalSpace Î³\ninstâœ : TopologicalSpace Î´\nf : Î± â†’â‚˜[Î¼] Î²\nâŠ¢ mk â†‘f â‹¯ = f"
    },
    {
      "name": "MeasureTheory.AEStronglyMeasurable.sum_measure",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ¹ : Type u_4\ninstâœÂ³ : Countable Î¹\nmâœ : MeasurableSpace Î±\nÎ¼âœ Î½ : Measure Î±\ninstâœÂ² : TopologicalSpace Î²\ninstâœÂ¹ : TopologicalSpace Î³\nf g : Î± â†’ Î²\ninstâœ : PseudoMetrizableSpace Î²\nm : MeasurableSpace Î±\nÎ¼ : Î¹ â†’ Measure Î±\nh : âˆ€ (i : Î¹), AEStronglyMeasurable f (Î¼ i)\nâŠ¢ AEStronglyMeasurable f (sum Î¼)"
    },
    {
      "name": "MeasureTheory.FiniteMeasure.mass_prod",
      "statement": "Î± : Type u_1\ninstâœÂ¹ : MeasurableSpace Î±\nÎ² : Type u_2\ninstâœ : MeasurableSpace Î²\nÎ¼ : FiniteMeasure Î±\nÎ½ : FiniteMeasure Î²\nâŠ¢ (Î¼.prod Î½).mass = Î¼.mass * Î½.mass"
    },
    {
      "name": "MeasureTheory.FiniteMeasure.prod_zero",
      "statement": "Î± : Type u_1\ninstâœÂ¹ : MeasurableSpace Î±\nÎ² : Type u_2\ninstâœ : MeasurableSpace Î²\nÎ¼ : FiniteMeasure Î±\nÎ½ : FiniteMeasure Î²\nâŠ¢ Î¼.prod 0 = 0"
    },
    {
      "name": "MeasureTheory.FiniteMeasure.testAgainstNN_lipschitz",
      "statement": "Î© : Type u_1\ninstâœâ¶ : MeasurableSpace Î©\nR : Type u_2\ninstâœâµ : SMul R â„â‰¥0\ninstâœâ´ : SMul R â„â‰¥0âˆ\ninstâœÂ³ : IsScalarTower R â„â‰¥0 â„â‰¥0âˆ\ninstâœÂ² : IsScalarTower R â„â‰¥0âˆ â„â‰¥0âˆ\ninstâœÂ¹ : TopologicalSpace Î©\ninstâœ : OpensMeasurableSpace Î©\nÎ¼ : FiniteMeasure Î©\nâŠ¢ LipschitzWith Î¼.mass fun f => Î¼.testAgainstNN f"
    },
    {
      "name": "MeasureTheory.FiniteMeasure.zero_prod",
      "statement": "Î± : Type u_1\ninstâœÂ¹ : MeasurableSpace Î±\nÎ² : Type u_2\ninstâœ : MeasurableSpace Î²\nÎ¼ : FiniteMeasure Î±\nÎ½ : FiniteMeasure Î²\nâŠ¢ prod 0 Î½ = 0"
    },
    {
      "name": "MeasureTheory.Integrable.add_measure",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\nm : MeasurableSpace Î±\nÎ¼ Î½ : Measure Î±\ninstâœÂ² : MeasurableSpace Î´\ninstâœÂ¹ : NormedAddCommGroup Î²\ninstâœ : NormedAddCommGroup Î³\nf : Î± â†’ Î²\nhÎ¼ : Integrable f Î¼\nhÎ½ : Integrable f Î½\nâŠ¢ Integrable f (Î¼ + Î½)"
    },
    {
      "name": "MeasureTheory.IsStoppingTime.measurableSpace_const",
      "statement": "Î© : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœ : Preorder Î¹\nfâœ : Filtration Î¹ m\nÏ„ Ï€ : Î© â†’ Î¹\nf : Filtration Î¹ m\ni : Î¹\nâŠ¢ â‹¯.measurableSpace = â†‘f i"
    },
    {
      "name": "MeasureTheory.Martingale.setIntegral_eq",
      "statement": "Î© : Type u_1\nE : Type u_2\nÎ¹ : Type u_3\ninstâœâ´ : Preorder Î¹\nm0 : MeasurableSpace Î©\nÎ¼ : Measure Î©\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace â„ E\ninstâœÂ¹ : CompleteSpace E\nf g : Î¹ â†’ Î© â†’ E\nâ„± : Filtration Î¹ m0\ninstâœ : SigmaFiniteFiltration Î¼ â„±\nhf : Martingale f â„± Î¼\ni j : Î¹\nhij : i â‰¤ j\ns : Set Î©\nhs : MeasurableSet s\nâŠ¢ âˆ« (Ï‰ : Î©) in s, f i Ï‰ âˆ‚Î¼ = âˆ« (Ï‰ : Î©) in s, f j Ï‰ âˆ‚Î¼"
    },
    {
      "name": "MeasureTheory.Measure.IicSnd_le_fst",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nmÎ± : MeasurableSpace Î±\nÏ : Measure (Î± Ã— â„)\nr : â„\nâŠ¢ Ï.IicSnd r â‰¤ Ï.fst"
    },
    {
      "name": "MeasureTheory.Measure.InnerRegularWRT.smul",
      "statement": "Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : Measure Î±\np q : Set Î± â†’ Prop\nU : Set Î±\nÎµ : â„â‰¥0âˆ\nH : Î¼.InnerRegularWRT p q\nc : â„â‰¥0âˆ\nâŠ¢ (c â€¢ Î¼).InnerRegularWRT p q"
    },
    {
      "name": "MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set",
      "statement": "G : Type u_1\ninstâœÂ¹â´ : Group G\ninstâœÂ¹Â³ : MeasurableSpace G\ninstâœÂ¹Â² : TopologicalSpace G\ninstâœÂ¹Â¹ : TopologicalGroup G\ninstâœÂ¹â° : BorelSpace G\ninstâœâ¹ : PolishSpace G\nÎ“ : Subgroup G\ninstâœâ¸ : Countable â†¥Î“\ninstâœâ· : Î“.Normal\ninstâœâ¶ : T2Space (G â§¸ Î“)\ninstâœâµ : SecondCountableTopology (G â§¸ Î“)\nÎ¼ : Measure (G â§¸ Î“)\nÎ½ : Measure G\ninstâœâ´ : Î½.IsMulLeftInvariant\ninstâœÂ³ : Î½.IsMulRightInvariant\ninstâœÂ² : SigmaFinite Î½\ninstâœÂ¹ : Î¼.IsMulLeftInvariant\ninstâœ : SigmaFinite Î¼\ns : Set G\nfund_dom_s : IsFundamentalDomain (â†¥Î“.op) s Î½\nV : Set (G â§¸ Î“)\nmeas_V : MeasurableSet V\nneZeroV : Î¼ V â‰  0\nhV : Î¼ V = Î½ (QuotientGroup.mk â»Â¹' V âˆ© s)\nneTopV : Î¼ V â‰  âŠ¤\nâŠ¢ QuotientMeasureEqMeasurePreimage Î½ Î¼"
    },
    {
      "name": "MeasureTheory.Measure.LinearMap.quasiMeasurePreserving",
      "statement": "E : Type u_1\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace â„ E\ninstâœâ¶ : MeasurableSpace E\ninstâœâµ : BorelSpace E\ninstâœâ´ : FiniteDimensional â„ E\nÎ¼ : Measure E\ninstâœÂ³ : Î¼.IsAddHaarMeasure\nF : Type u_2\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace â„ F\ninstâœ : CompleteSpace F\nf : E â†’â‚—[â„] E\nhf : LinearMap.det f â‰  0\nâŠ¢ QuasiMeasurePreserving (â‡‘f) Î¼ Î¼"
    },
    {
      "name": "MeasureTheory.Measure.MutuallySingular.mk",
      "statement": "Î± : Type u_1\nm0 : MeasurableSpace Î±\nÎ¼ Î¼â‚ Î¼â‚‚ Î½ Î½â‚ Î½â‚‚ : Measure Î±\ns t : Set Î±\nhs : Î¼ s = 0\nht : Î½ t = 0\nhst : univ âŠ† s âˆª t\nâŠ¢ Î¼ âŸ‚â‚˜ Î½"
    },
    {
      "name": "MeasureTheory.Measure.addHaar_image_homothety",
      "statement": "E : Type u_1\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace â„ E\ninstâœâ¶ : MeasurableSpace E\ninstâœâµ : BorelSpace E\ninstâœâ´ : FiniteDimensional â„ E\nÎ¼ : Measure E\ninstâœÂ³ : Î¼.IsAddHaarMeasure\nF : Type u_2\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace â„ F\ninstâœ : CompleteSpace F\nsâœ : Set E\nx : E\nr : â„\ns : Set E\nâŠ¢ Î¼ (â‡‘(AffineMap.homothety x r) '' s) = Î¼ ((fun y => y + x) '' (r â€¢ (fun y => y + -x) '' s))"
    },
    {
      "name": "MeasureTheory.Measure.addHaar_image_linearMap",
      "statement": "E : Type u_1\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace â„ E\ninstâœâ¶ : MeasurableSpace E\ninstâœâµ : BorelSpace E\ninstâœâ´ : FiniteDimensional â„ E\nÎ¼ : Measure E\ninstâœÂ³ : Î¼.IsAddHaarMeasure\nF : Type u_2\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace â„ F\ninstâœ : CompleteSpace F\nf : E â†’â‚—[â„] E\ns : Set E\nâŠ¢ Î¼ (â‡‘f '' s) = ENNReal.ofReal |LinearMap.det f| * Î¼ s"
    },
    {
      "name": "MeasureTheory.Measure.addHaar_smul",
      "statement": "E : Type u_1\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace â„ E\ninstâœâ¶ : MeasurableSpace E\ninstâœâµ : BorelSpace E\ninstâœâ´ : FiniteDimensional â„ E\nÎ¼ : Measure E\ninstâœÂ³ : Î¼.IsAddHaarMeasure\nF : Type u_2\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace â„ F\ninstâœ : CompleteSpace F\nr : â„\ns : Set E\nâŠ¢ Î¼ (r â€¢ s) = ENNReal.ofReal |r ^ finrank â„ E| * Î¼ s"
    },
    {
      "name": "MeasureTheory.Measure.dirac_apply",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ´ : Type u_3\ninstâœÂ² : MeasurableSpace Î±\ninstâœÂ¹ : MeasurableSpace Î²\nsâœ : Set Î±\naâœ : Î±\ninstâœ : MeasurableSingletonClass Î±\na : Î±\ns : Set Î±\nâŠ¢ (dirac a) s = s.indicator 1 a"
    },
    {
      "name": "MeasureTheory.Measure.dirac_apply_of_mem",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ´ : Type u_3\ninstâœÂ¹ : MeasurableSpace Î±\ninstâœ : MeasurableSpace Î²\ns : Set Î±\naâœ a : Î±\nh : a âˆˆ s\nâŠ¢ (dirac a) s = 1"
    },
    {
      "name": "MeasureTheory.Measure.dirac_one_mconv",
      "statement": "M : Type u_1\ninstâœÂ³ : Monoid M\ninstâœÂ² : MeasurableSpace M\ninstâœÂ¹ : MeasurableMulâ‚‚ M\nÎ¼ : Measure M\ninstâœ : SFinite Î¼\nâŠ¢ dirac 1 âˆ— Î¼ = Î¼"
    },
    {
      "name": "MeasureTheory.Measure.haarScalarFactor_self",
      "statement": "G : Type u_1\ninstâœâµ : TopologicalSpace G\ninstâœâ´ : Group G\ninstâœÂ³ : TopologicalGroup G\ninstâœÂ² : MeasurableSpace G\ninstâœÂ¹ : BorelSpace G\nÎ¼ : Measure G\ninstâœ : Î¼.IsHaarMeasure\nâŠ¢ Î¼.haarScalarFactor Î¼ = 1"
    },
    {
      "name": "MeasureTheory.Measure.haarScalarFactor_smul",
      "statement": "G : Type u_1\ninstâœâ¸ : TopologicalSpace G\ninstâœâ· : Group G\ninstâœâ¶ : TopologicalGroup G\ninstâœâµ : MeasurableSpace G\ninstâœâ´ : BorelSpace G\ninstâœÂ³ : LocallyCompactSpace G\nÎ¼' Î¼ : Measure G\ninstâœÂ² : Î¼.IsHaarMeasure\ninstâœÂ¹ : IsFiniteMeasureOnCompacts Î¼'\ninstâœ : Î¼'.IsMulLeftInvariant\nc : â„â‰¥0\nâŠ¢ (c â€¢ Î¼').haarScalarFactor Î¼ = c â€¢ Î¼'.haarScalarFactor Î¼"
    },
    {
      "name": "MeasureTheory.Measure.map_add",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\nÎ¹ : Type u_5\nR : Type u_6\nR' : Type u_7\nm0 : MeasurableSpace Î±\ninstâœÂ¹ : MeasurableSpace Î²\ninstâœ : MeasurableSpace Î³\nÎ¼âœ Î¼â‚ Î¼â‚‚ Î¼â‚ƒ Î½âœ Î½' Î½â‚ Î½â‚‚ : Measure Î±\ns s' t : Set Î±\nÎ¼ Î½ : Measure Î±\nf : Î± â†’ Î²\nhf : Measurable f\nâŠ¢ map f (Î¼ + Î½) = map f Î¼ + map f Î½"
    },
    {
      "name": "MeasureTheory.Measure.map_const",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ´ : Type u_3\ninstâœÂ¹ : MeasurableSpace Î±\ninstâœ : MeasurableSpace Î²\ns : Set Î±\na : Î±\nÎ¼ : Measure Î±\nc : Î²\nâŠ¢ map (fun x => c) Î¼ = Î¼ univ â€¢ dirac c"
    },
    {
      "name": "MeasureTheory.Measure.mconv_dirac_one",
      "statement": "M : Type u_1\ninstâœÂ³ : Monoid M\ninstâœÂ² : MeasurableSpace M\ninstâœÂ¹ : MeasurableMulâ‚‚ M\nÎ¼ : Measure M\ninstâœ : SFinite Î¼\nâŠ¢ Î¼ âˆ— dirac 1 = Î¼"
    },
    {
      "name": "MeasureTheory.Measure.pi_pi",
      "statement": "Î¹ : Type u_1\nÎ¹' : Type u_2\nÎ± : Î¹ â†’ Type u_3\ninstâœÂ² : Fintype Î¹\nm : (i : Î¹) â†’ OuterMeasure (Î± i)\ninstâœÂ¹ : (i : Î¹) â†’ MeasurableSpace (Î± i)\nÎ¼ : (i : Î¹) â†’ Measure (Î± i)\ninstâœ : âˆ€ (i : Î¹), SigmaFinite (Î¼ i)\ns : (i : Î¹) â†’ Set (Î± i)\nâŠ¢ (Measure.pi Î¼) (univ.pi s) = âˆ i : Î¹, (Î¼ i) (s i)"
    },
    {
      "name": "MeasureTheory.Measure.restrict_toMeasurable_of_sFinite",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ´ : Type u_3\nÎ¹ : Type u_4\nm0 : MeasurableSpace Î±\ninstâœÂ¹ : MeasurableSpace Î²\nÎ¼ Î½ Î½â‚ Î½â‚‚ : Measure Î±\nsâœ tâœ : Set Î±\ninstâœ : SFinite Î¼\ns t : Set Î±\nht : MeasurableSet t\nâŠ¢ (Î¼.restrict (toMeasurable Î¼ s)) t = (Î¼.restrict s) t"
    },
    {
      "name": "MeasureTheory.Measure.snd_map_swap",
      "statement": "Î± : Type u_1\nÎ±' : Type u_2\nÎ² : Type u_3\nÎ²' : Type u_4\nÎ³ : Type u_5\nE : Type u_6\ninstâœâ¶ : MeasurableSpace Î±\ninstâœâµ : MeasurableSpace Î±'\ninstâœâ´ : MeasurableSpace Î²\ninstâœÂ³ : MeasurableSpace Î²'\ninstâœÂ² : MeasurableSpace Î³\nÎ¼ Î¼' : Measure Î±\nÎ½ Î½' : Measure Î²\nÏ„ : Measure Î³\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : SFinite Î½\nÏ : Measure (Î± Ã— Î²)\nâŠ¢ (map Prod.swap Ï).snd = Ï.fst"
    },
    {
      "name": "MeasureTheory.Measure.snd_prod",
      "statement": "Î± : Type u_1\nÎ±' : Type u_2\nÎ² : Type u_3\nÎ²' : Type u_4\nÎ³ : Type u_5\nE : Type u_6\ninstâœâ· : MeasurableSpace Î±\ninstâœâ¶ : MeasurableSpace Î±'\ninstâœâµ : MeasurableSpace Î²\ninstâœâ´ : MeasurableSpace Î²'\ninstâœÂ³ : MeasurableSpace Î³\nÎ¼ Î¼' : Measure Î±\nÎ½ Î½' : Measure Î²\nÏ„ : Measure Î³\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : SFinite Î½\nÏ : Measure (Î± Ã— Î²)\ninstâœ : IsProbabilityMeasure Î¼\nâŠ¢ (Î¼.prod Î½).snd = Î½"
    },
    {
      "name": "MeasureTheory.Measure.zero_prod",
      "statement": "Î± : Type u_1\nÎ±' : Type u_2\nÎ² : Type u_3\nÎ²' : Type u_4\nÎ³ : Type u_5\nE : Type u_6\ninstâœâ· : MeasurableSpace Î±\ninstâœâ¶ : MeasurableSpace Î±'\ninstâœâµ : MeasurableSpace Î²\ninstâœâ´ : MeasurableSpace Î²'\ninstâœÂ³ : MeasurableSpace Î³\nÎ¼ Î¼' : Measure Î±\nÎ½âœ Î½' : Measure Î²\nÏ„ : Measure Î³\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : SFinite Î½âœ\ninstâœ : SFinite Î¼\nÎ½ : Measure Î²\nâŠ¢ Measure.prod 0 Î½ = 0"
    },
    {
      "name": "MeasureTheory.OuterMeasure.boundedBy_top",
      "statement": "Î± : Type u_1\nm : Set Î± â†’ â„â‰¥0âˆ\nâŠ¢ boundedBy âŠ¤ = âŠ¤"
    },
    {
      "name": "MeasureTheory.OuterMeasure.comap_top",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nm : OuterMeasure Î±\nf : Î± â†’ Î²\ns : Set Î±\nhs : s.Nonempty\nâŠ¢ ((comap f) âŠ¤) s = âŠ¤ s"
    },
    {
      "name": "MeasureTheory.OuterMeasure.isCaratheodory_empty",
      "statement": "Î± : Type u\nm : OuterMeasure Î±\ns sâ‚ sâ‚‚ : Set Î±\nâŠ¢ m.IsCaratheodory âˆ…"
    },
    {
      "name": "MeasureTheory.OuterMeasure.restrict_apply",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nmâœ : OuterMeasure Î±\ns t : Set Î±\nm : OuterMeasure Î±\nâŠ¢ ((restrict s) m) t = m (t âˆ© s)"
    },
    {
      "name": "MeasureTheory.OuterMeasure.sup_apply",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nm mâ‚ mâ‚‚ : OuterMeasure Î±\ns : Set Î±\nâŠ¢ (mâ‚ âŠ” mâ‚‚) s = mâ‚ s âŠ” mâ‚‚ s"
    },
    {
      "name": "MeasureTheory.SignedMeasure.toSignedMeasure_toJordanDecomposition",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : MeasurableSpace Î±\nsâœ : SignedMeasure Î±\nÎ¼ Î½ : Measure Î±\ninstâœÂ¹ : IsFiniteMeasure Î¼\ninstâœ : IsFiniteMeasure Î½\ns : SignedMeasure Î±\nâŠ¢ s.toJordanDecomposition.toSignedMeasure = s"
    },
    {
      "name": "MeasureTheory.SimpleFunc.coe_restrict",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\ninstâœÂ¹ : MeasurableSpace Î±\nK : Type u_5\ninstâœ : Zero Î²\nf : Î± â†’â‚› Î²\ns : Set Î±\nhs : MeasurableSet s\nâŠ¢ â†‘(f.restrict s) = s.indicator â†‘f"
    },
    {
      "name": "MeasureTheory.SimpleFunc.forall_mem_range",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\ninstâœ : MeasurableSpace Î±\nf : Î± â†’â‚› Î²\np : Î² â†’ Prop\nâŠ¢ (âˆ€ y âˆˆ f.range, p y) â†” âˆ€ (x : Î±), p (â†‘f x)"
    },
    {
      "name": "MeasureTheory.SimpleFunc.piecewise_compl",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\ninstâœ : MeasurableSpace Î±\ns : Set Î±\nhs : MeasurableSet sá¶œ\nf g : Î± â†’â‚› Î²\nâŠ¢ â†‘(piecewise sá¶œ hs f g) = â†‘(piecewise s â‹¯ g f)"
    },
    {
      "name": "MeasureTheory.SimpleFunc.piecewise_empty",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\ninstâœ : MeasurableSpace Î±\nf g : Î± â†’â‚› Î²\nâŠ¢ â†‘(piecewise âˆ… â‹¯ f g) = â†‘g"
    },
    {
      "name": "MeasureTheory.SimpleFunc.piecewise_univ",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\ninstâœ : MeasurableSpace Î±\nf g : Î± â†’â‚› Î²\nâŠ¢ â†‘(piecewise univ â‹¯ f g) = â†‘f"
    },
    {
      "name": "MeasureTheory.SimpleFunc.range_eq_empty_of_isEmpty",
      "statement": "Î± : Type u_1\nÎ²âœ : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\ninstâœ : MeasurableSpace Î±\nÎ² : Type u_5\nhÎ± : IsEmpty Î±\nf : Î± â†’â‚› Î²\nâŠ¢ f.range = âˆ…"
    },
    {
      "name": "MeasureTheory.StronglyMeasurable.isSeparable_range",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ¹ : Type u_4\ninstâœÂ¹ : Countable Î¹\nf g : Î± â†’ Î²\nm : MeasurableSpace Î±\ninstâœ : TopologicalSpace Î²\nhf : StronglyMeasurable f\nâŠ¢ IsSeparable (range f)"
    },
    {
      "name": "MeasureTheory.VectorMeasure.mapRange_add",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nm instâœâ· : MeasurableSpace Î±\ninstâœâ¶ : MeasurableSpace Î²\nM : Type u_3\ninstâœâµ : AddCommMonoid M\ninstâœâ´ : TopologicalSpace M\nvâœ : VectorMeasure Î± M\nN : Type u_4\ninstâœÂ³ : AddCommMonoid N\ninstâœÂ² : TopologicalSpace N\ninstâœÂ¹ : ContinuousAdd M\ninstâœ : ContinuousAdd N\nv w : VectorMeasure Î± M\nf : M â†’+ N\nhf : Continuous â‡‘f\nâŠ¢ (v + w).mapRange f hf = v.mapRange f hf + w.mapRange f hf"
    },
    {
      "name": "MeasureTheory.ae_restrict_biUnion_finset_iff",
      "statement": "R : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nÎ´ : Type u_4\nÎ³ : Type u_5\nÎ¹ : Type u_6\nm0 : MeasurableSpace Î±\ninstâœÂ¹ : MeasurableSpace Î²\ninstâœ : MeasurableSpace Î³\nÎ¼ Î¼â‚ Î¼â‚‚ Î¼â‚ƒ Î½ Î½' Î½â‚ Î½â‚‚ : Measure Î±\nsâœ s' tâœ : Set Î±\ns : Î¹ â†’ Set Î±\nt : Finset Î¹\np : Î± â†’ Prop\nâŠ¢ (âˆ€áµ (x : Î±) âˆ‚Î¼.restrict (â‹ƒ i âˆˆ t, s i), p x) â†” âˆ€ i âˆˆ t, âˆ€áµ (x : Î±) âˆ‚Î¼.restrict (s i), p x"
    },
    {
      "name": "MeasureTheory.ae_restrict_eq",
      "statement": "R : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nÎ´ : Type u_4\nÎ³ : Type u_5\nÎ¹ : Type u_6\nm0 : MeasurableSpace Î±\ninstâœÂ¹ : MeasurableSpace Î²\ninstâœ : MeasurableSpace Î³\nÎ¼ Î¼â‚ Î¼â‚‚ Î¼â‚ƒ Î½ Î½' Î½â‚ Î½â‚‚ : Measure Î±\ns s' t : Set Î±\nhs : MeasurableSet s\nâŠ¢ ae (Î¼.restrict s) = ae Î¼ âŠ“ ğ“Ÿ s"
    },
    {
      "name": "MeasureTheory.ae_restrict_union_iff",
      "statement": "R : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nÎ´ : Type u_4\nÎ³ : Type u_5\nÎ¹ : Type u_6\nm0 : MeasurableSpace Î±\ninstâœÂ¹ : MeasurableSpace Î²\ninstâœ : MeasurableSpace Î³\nÎ¼ Î¼â‚ Î¼â‚‚ Î¼â‚ƒ Î½ Î½' Î½â‚ Î½â‚‚ : Measure Î±\nsâœ s' tâœ s t : Set Î±\np : Î± â†’ Prop\nâŠ¢ (âˆ€áµ (x : Î±) âˆ‚Î¼.restrict (s âˆª t), p x) â†” (âˆ€áµ (x : Î±) âˆ‚Î¼.restrict s, p x) âˆ§ âˆ€áµ (x : Î±) âˆ‚Î¼.restrict t, p x"
    },
    {
      "name": "MeasureTheory.aestronglyMeasurable_zero_measure",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ¹ : Type u_4\ninstâœÂ² : Countable Î¹\ninstâœÂ¹ : MeasurableSpace Î±\ninstâœ : TopologicalSpace Î²\nf : Î± â†’ Î²\nâŠ¢ AEStronglyMeasurable f 0"
    },
    {
      "name": "MeasureTheory.cylinder_eq_empty_iff",
      "statement": "Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u_2\nh_nonempty : Nonempty ((i : Î¹) â†’ Î± i)\ns : Finset Î¹\nS : Set ((i : { x // x âˆˆ s }) â†’ Î± â†‘i)\nâŠ¢ cylinder s S = âˆ… â†” S = âˆ…"
    },
    {
      "name": "MeasureTheory.extend_mono'",
      "statement": "Î± : Type u_1\nP : Set Î± â†’ Prop\nm : (s : Set Î±) â†’ P s â†’ â„â‰¥0âˆ\nP0 : P âˆ…\nm0 : m âˆ… P0 = 0\nPU : âˆ€ â¦ƒf : â„• â†’ Set Î±â¦„, (âˆ€ (i : â„•), P (f i)) â†’ P (â‹ƒ i, f i)\nmU : âˆ€ â¦ƒf : â„• â†’ Set Î±â¦„ (hm : âˆ€ (i : â„•), P (f i)), Pairwise (Disjoint on f) â†’ m (â‹ƒ i, f i) â‹¯ = âˆ‘' (i : â„•), m (f i) â‹¯\nmsU : âˆ€ â¦ƒf : â„• â†’ Set Î±â¦„ (hm : âˆ€ (i : â„•), P (f i)), m (â‹ƒ i, f i) â‹¯ â‰¤ âˆ‘' (i : â„•), m (f i) â‹¯\nm_mono : âˆ€ â¦ƒsâ‚ sâ‚‚ : Set Î±â¦„ (hsâ‚ : P sâ‚) (hsâ‚‚ : P sâ‚‚), sâ‚ âŠ† sâ‚‚ â†’ m sâ‚ hsâ‚ â‰¤ m sâ‚‚ hsâ‚‚\nsâ‚ sâ‚‚ : Set Î±\nhâ‚ : P sâ‚\nhs : sâ‚ âŠ† sâ‚‚\nâŠ¢ extend m sâ‚ â‰¤ extend m sâ‚‚"
    },
    {
      "name": "MeasureTheory.indicatorConstLp_univ",
      "statement": "Î± : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\nm m0 : MeasurableSpace Î±\np : â„â‰¥0âˆ\nq : â„\nÎ¼ Î½ : Measure Î±\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : IsFiniteMeasure Î¼\nc : E\nâŠ¢ indicatorConstLp p â‹¯ â‹¯ c = (Lp.const p Î¼) c"
    },
    {
      "name": "MeasureTheory.integrable_add_iff_integrable_left",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\nm : MeasurableSpace Î±\nÎ¼ Î½ : Measure Î±\ninstâœÂ² : MeasurableSpace Î´\ninstâœÂ¹ : NormedAddCommGroup Î²\ninstâœ : NormedAddCommGroup Î³\nf g : Î± â†’ Î²\nhf : Integrable f Î¼\nâŠ¢ Integrable (g + f) Î¼ â†” Integrable g Î¼"
    },
    {
      "name": "MeasureTheory.integral_dirac'",
      "statement": "Î± : Type u_1\nE : Type u_2\nF : Type u_3\nğ•œ : Type u_4\ninstâœÂ¹Â² : NormedAddCommGroup E\ninstâœÂ¹Â¹ : NormedSpace â„ E\nhE : CompleteSpace E\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\ninstâœâ¹ : NormedSpace ğ•œ E\ninstâœâ¸ : SMulCommClass â„ ğ•œ E\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedSpace â„ F\ninstâœâµ : CompleteSpace F\nG : Type u_5\ninstâœâ´ : NormedAddCommGroup G\ninstâœÂ³ : NormedSpace â„ G\nfâœ g : Î± â†’ E\nm : MeasurableSpace Î±\nÎ¼ : Measure Î±\nX : Type u_6\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : FirstCountableTopology X\nÎ½ : Measure Î±\ninstâœ : MeasurableSpace Î±\nf : Î± â†’ E\na : Î±\nhfm : StronglyMeasurable f\nâŠ¢ âˆ« (x : Î±), f x âˆ‚Measure.dirac a = f a"
    },
    {
      "name": "MeasureTheory.integral_smul_measure",
      "statement": "Î± : Type u_1\nE : Type u_2\nF : Type u_3\nğ•œ : Type u_4\ninstâœÂ¹Â¹ : NormedAddCommGroup E\ninstâœÂ¹â° : NormedSpace â„ E\nhE : CompleteSpace E\ninstâœâ¹ : NontriviallyNormedField ğ•œ\ninstâœâ¸ : NormedSpace ğ•œ E\ninstâœâ· : SMulCommClass â„ ğ•œ E\ninstâœâ¶ : NormedAddCommGroup F\ninstâœâµ : NormedSpace â„ F\ninstâœâ´ : CompleteSpace F\nG : Type u_5\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace â„ G\nfâœ g : Î± â†’ E\nm : MeasurableSpace Î±\nÎ¼ : Measure Î±\nX : Type u_6\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : FirstCountableTopology X\nÎ½ : Measure Î±\nf : Î± â†’ G\nc : â„â‰¥0âˆ\nâŠ¢ âˆ« (x : Î±), f x âˆ‚c â€¢ Î¼ = c.toReal â€¢ âˆ« (x : Î±), f x âˆ‚Î¼"
    },
    {
      "name": "MeasureTheory.integral_zero",
      "statement": "Î± : Type u_1\nE : Type u_2\nF : Type u_3\nğ•œ : Type u_4\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace â„ E\nhE : CompleteSpace E\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : NormedSpace ğ•œ E\ninstâœâµ : SMulCommClass â„ ğ•œ E\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace â„ F\ninstâœÂ² : CompleteSpace F\nG : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace â„ G\nf g : Î± â†’ E\nm : MeasurableSpace Î±\nÎ¼ : Measure Î±\nâŠ¢ âˆ« (x : Î±), 0 âˆ‚Î¼ = 0"
    },
    {
      "name": "MeasureTheory.laverage_lt_top",
      "statement": "Î± : Type u_1\nE : Type u_2\nF : Type u_3\nm0 : MeasurableSpace Î±\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace â„ E\ninstâœÂ³ : CompleteSpace E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace â„ F\ninstâœ : CompleteSpace F\nÎ¼ Î½ : Measure Î±\ns t : Set Î±\nf g : Î± â†’ â„â‰¥0âˆ\nhf : âˆ«â» (x : Î±), f x âˆ‚Î¼ â‰  âŠ¤\nâŠ¢ â¨â» (x : Î±), f x âˆ‚Î¼ < âŠ¤"
    },
    {
      "name": "MeasureTheory.levyProkhorovEDist_le_of_forall_add_pos_le",
      "statement": "Î¹ : Type u_1\nÎ© : Type u_2\ninstâœÂ¹ : MeasurableSpace Î©\ninstâœ : PseudoEMetricSpace Î©\nÎ¼ Î½ : Measure Î©\nÎ´ : â„â‰¥0âˆ\nh :\n  âˆ€ (Îµ : â„â‰¥0âˆ) (B : Set Î©),\n    0 < Îµ â†’\n      Îµ < âŠ¤ â†’\n        MeasurableSet B â†’ Î¼ B â‰¤ Î½ (thickening (Î´ + Îµ).toReal B) + Î´ + Îµ âˆ§ Î½ B â‰¤ Î¼ (thickening (Î´ + Îµ).toReal B) + Î´ + Îµ\nâŠ¢ levyProkhorovEDist Î¼ Î½ â‰¤ Î´"
    },
    {
      "name": "MeasureTheory.lintegral_laverage",
      "statement": "Î± : Type u_1\nE : Type u_2\nF : Type u_3\nm0 : MeasurableSpace Î±\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace â„ E\ninstâœâ´ : CompleteSpace E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace â„ F\ninstâœÂ¹ : CompleteSpace F\nÎ¼âœ Î½ : Measure Î±\ns t : Set Î±\nfâœ g : Î± â†’ â„â‰¥0âˆ\nÎ¼ : Measure Î±\ninstâœ : IsFiniteMeasure Î¼\nf : Î± â†’ â„â‰¥0âˆ\nâŠ¢ âˆ«â» (_x : Î±), â¨â» (a : Î±), f a âˆ‚Î¼ âˆ‚Î¼ = âˆ«â» (x : Î±), f x âˆ‚Î¼"
    },
    {
      "name": "MeasureTheory.lintegral_norm_eq_lintegral_edist",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\nm : MeasurableSpace Î±\nÎ¼ Î½ : Measure Î±\ninstâœÂ² : MeasurableSpace Î´\ninstâœÂ¹ : NormedAddCommGroup Î²\ninstâœ : NormedAddCommGroup Î³\nf : Î± â†’ Î²\nâŠ¢ âˆ«â» (a : Î±), ENNReal.ofReal â€–f aâ€– âˆ‚Î¼ = âˆ«â» (a : Î±), edist (f a) 0 âˆ‚Î¼"
    },
    {
      "name": "MeasureTheory.lintegral_sum_measure",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\nmâœ : MeasurableSpace Î±\nÎ¼âœ Î½ : Measure Î±\nm : MeasurableSpace Î±\nÎ¹ : Type u_5\nf : Î± â†’ â„â‰¥0âˆ\nÎ¼ : Î¹ â†’ Measure Î±\nâŠ¢ âˆ«â» (a : Î±), f a âˆ‚Measure.sum Î¼ = âˆ‘' (i : Î¹), âˆ«â» (a : Î±), f a âˆ‚Î¼ i"
    },
    {
      "name": "MeasureTheory.lintegral_zero",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\nm : MeasurableSpace Î±\nÎ¼ Î½ : Measure Î±\nâŠ¢ âˆ«â» (x : Î±), 0 âˆ‚Î¼ = 0"
    },
    {
      "name": "MeasureTheory.lmarginal_univ",
      "statement": "Î´ : Type u_1\nÎ´' : Type u_2\nÏ€ : Î´ â†’ Type u_3\ninstâœÂ³ : (x : Î´) â†’ MeasurableSpace (Ï€ x)\nÎ¼ : (i : Î´) â†’ Measure (Ï€ i)\ninstâœÂ² : âˆ€ (i : Î´), SigmaFinite (Î¼ i)\ninstâœÂ¹ : DecidableEq Î´\ns t : Finset Î´\nfâœ g : ((i : Î´) â†’ Ï€ i) â†’ â„â‰¥0âˆ\nx y : (i : Î´) â†’ Ï€ i\ni : Î´\ninstâœ : Fintype Î´\nf : ((i : Î´) â†’ Ï€ i) â†’ â„â‰¥0âˆ\nâŠ¢ âˆ«â‹¯âˆ«â»_Finset.univ, f âˆ‚Î¼ = fun x => âˆ«â» (x : (i : Î´) â†’ Ï€ i), f x âˆ‚Measure.pi Î¼"
    },
    {
      "name": "MeasureTheory.measurableSet_toMeasurable",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\nÎ¹ : Sort u_5\ninstâœ : MeasurableSpace Î±\nÎ¼âœ Î¼â‚ Î¼â‚‚ : Measure Î±\nsâœ sâ‚ sâ‚‚ t : Set Î±\nÎ¼ : Measure Î±\ns : Set Î±\nâŠ¢ MeasurableSet (toMeasurable Î¼ s)"
    },
    {
      "name": "MeasureTheory.measure_inv_null",
      "statement": "G : Type u_1\ninstâœâ¶ : MeasurableSpace G\ninstâœâµ : Group G\ninstâœâ´ : MeasurableMulâ‚‚ G\nÎ¼ Î½ : Measure G\ninstâœÂ³ : SigmaFinite Î½\ninstâœÂ² : SigmaFinite Î¼\ns : Set G\ninstâœÂ¹ : MeasurableInv G\ninstâœ : Î¼.IsMulLeftInvariant\nâŠ¢ Î¼ sâ»Â¹ = 0 â†” Î¼ s = 0"
    },
    {
      "name": "MeasureTheory.measure_union_lt_top_iff",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\nÎ¹ : Sort u_5\ninstâœ : MeasurableSpace Î±\nÎ¼ Î¼â‚ Î¼â‚‚ : Measure Î±\ns sâ‚ sâ‚‚ t : Set Î±\nâŠ¢ Î¼ (s âˆª t) < âŠ¤ â†” Î¼ s < âŠ¤ âˆ§ Î¼ t < âŠ¤"
    },
    {
      "name": "MeasureTheory.measure_univ_of_isMulLeftInvariant",
      "statement": "ğ•œ : Type u_1\nG : Type u_2\nH : Type u_3\ninstâœÂ¹â° : MeasurableSpace G\ninstâœâ¹ : MeasurableSpace H\ninstâœâ¸ : TopologicalSpace G\ninstâœâ· : BorelSpace G\nÎ¼âœ : Measure G\ninstâœâ¶ : Group G\ninstâœâµ : TopologicalGroup G\ninstâœâ´ : Î¼âœ.IsMulLeftInvariant\ninstâœÂ³ : WeaklyLocallyCompactSpace G\ninstâœÂ² : NoncompactSpace G\nÎ¼ : Measure G\ninstâœÂ¹ : Î¼.IsOpenPosMeasure\ninstâœ : Î¼.IsMulLeftInvariant\nâŠ¢ Î¼ univ = âŠ¤"
    },
    {
      "name": "MeasureTheory.mem_fundamentalInterior",
      "statement": "G : Type u_1\nH : Type u_2\nÎ± : Type u_3\nÎ² : Type u_4\nE : Type u_5\ninstâœÂ¹ : Group G\ninstâœ : MulAction G Î±\ns : Set Î±\nx : Î±\nâŠ¢ x âˆˆ fundamentalInterior G s â†” x âˆˆ s âˆ§ âˆ€ (g : G), g â‰  1 â†’ x âˆ‰ g â€¢ s"
    },
    {
      "name": "MeasureTheory.predictablePart_zero",
      "statement": "Î© : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Î©\nÎ¼ : Measure Î©\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace â„ E\ninstâœ : CompleteSpace E\nf : â„• â†’ Î© â†’ E\nâ„± : Filtration â„• m0\nn : â„•\nâŠ¢ predictablePart f â„± Î¼ 0 = 0"
    },
    {
      "name": "MeasureTheory.subset_toMeasurable",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\nÎ¹ : Sort u_5\ninstâœ : MeasurableSpace Î±\nÎ¼âœ Î¼â‚ Î¼â‚‚ : Measure Î±\nsâœ sâ‚ sâ‚‚ t : Set Î±\nÎ¼ : Measure Î±\ns : Set Î±\nâŠ¢ s âŠ† toMeasurable Î¼ s"
    },
    {
      "name": "MeasureTheory.tilted_const'",
      "statement": "case inl\nÎ± : Type u_1\nmÎ± : MeasurableSpace Î±\nÎ¼âœ : Measure Î±\nf : Î± â†’ â„\nÎ¼ : Measure Î±\nc : â„\nh : Î¼ = 0\nâŠ¢ (Î¼.tilted fun x => c) = (Î¼ Set.univ)â»Â¹ â€¢ Î¼"
    },
    {
      "name": "MeasureTheory.withDensity_congr_ae",
      "statement": "Î± : Type u_1\nm0 : MeasurableSpace Î±\nÎ¼ : Measure Î±\nf g : Î± â†’ â„â‰¥0âˆ\nh : f =á¶ [ae Î¼] g\nâŠ¢ Î¼.withDensity f = Î¼.withDensity g"
    },
    {
      "name": "MeasureTheory.withDensityáµ¥_add",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ Î½ : Measure Î±\nE : Type u_3\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace â„ E\ninstâœ : CompleteSpace E\nf g : Î± â†’ E\nhf : Integrable f Î¼\nhg : Integrable g Î¼\nâŠ¢ Î¼.withDensityáµ¥ (f + g) = Î¼.withDensityáµ¥ f + Î¼.withDensityáµ¥ g"
    },
    {
      "name": "MeasureTheory.zero_convolution",
      "statement": "ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nE'' : Type uE''\nF : Type uF\nF' : Type uF'\nF'' : Type uF''\nP : Type uP\ninstâœÂ¹Â¹ : NormedAddCommGroup E\ninstâœÂ¹â° : NormedAddCommGroup E'\ninstâœâ¹ : NormedAddCommGroup E''\ninstâœâ¸ : NormedAddCommGroup F\nf f' : G â†’ E\ng g' : G â†’ E'\nx x' : G\ny y' : E\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : NormedSpace ğ•œ E\ninstâœâµ : NormedSpace ğ•œ E'\ninstâœâ´ : NormedSpace ğ•œ E''\ninstâœÂ³ : NormedSpace ğ•œ F\nL : E â†’L[ğ•œ] E' â†’L[ğ•œ] F\ninstâœÂ² : MeasurableSpace G\nÎ¼ Î½ : Measure G\ninstâœÂ¹ : NormedSpace â„ F\ninstâœ : AddGroup G\nâŠ¢ 0 â‹†[L, Î¼] g = 0"
    },
    {
      "name": "Metric.cthickening_closure",
      "statement": "Î¹ : Sort u_1\nÎ± : Type u\nÎ² : Type v\ninstâœ : PseudoEMetricSpace Î±\nÎ´ Îµ : â„\ns t : Set Î±\nx : Î±\nâŠ¢ cthickening Î´ (closure s) = cthickening Î´ s"
    },
    {
      "name": "Metric.mem_ball_comm",
      "statement": "Î± : Type u\nÎ² : Type v\nX : Type u_1\nÎ¹ : Type u_2\ninstâœ : PseudoMetricSpace Î±\nx y z : Î±\nÎ´ Îµ Îµâ‚ Îµâ‚‚ : â„\ns : Set Î±\nâŠ¢ x âˆˆ ball y Îµ â†” y âˆˆ ball x Îµ"
    },
    {
      "name": "Metric.thickening_closure",
      "statement": "Î¹ : Sort u_1\nÎ± : Type u\nÎ² : Type v\ninstâœ : PseudoEMetricSpace Î±\nÎ´ Îµ : â„\ns t : Set Î±\nx : Î±\nâŠ¢ thickening Î´ (closure s) = thickening Î´ s"
    },
    {
      "name": "Module.DualBases.coeffs_lc",
      "statement": "R : Type u_1\nM : Type u_2\nÎ¹ : Type u_3\ninstâœÂ³ : CommRing R\ninstâœÂ² : AddCommGroup M\ninstâœÂ¹ : Module R M\ne : Î¹ â†’ M\nÎµ : Î¹ â†’ Dual R M\ninstâœ : DecidableEq Î¹\nh : DualBases e Îµ\nl : Î¹ â†’â‚€ R\nâŠ¢ h.coeffs (lc e l) = l"
    },
    {
      "name": "Module.End.hasGenEigenvalue_of_hasEigenvalue",
      "statement": "K R : Type v\nV M : Type w\ninstâœâµ : CommRing R\ninstâœâ´ : AddCommGroup M\ninstâœÂ³ : Module R M\ninstâœÂ² : Field K\ninstâœÂ¹ : AddCommGroup V\ninstâœ : Module K V\nf : End R M\nÎ¼ : R\nk : â„•\nhk : 0 < k\nhÎ¼ : f.HasEigenvalue Î¼\nâŠ¢ f.HasGenEigenvalue Î¼ k"
    },
    {
      "name": "Module.equiv_directSum_of_isTorsion",
      "statement": "R : Type u\ninstâœâ¶ : CommRing R\ninstâœâµ : IsDomain R\ninstâœâ´ : IsPrincipalIdealRing R\nM : Type v\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\nN : Type (max u v)\ninstâœÂ¹ : AddCommGroup N\ninstâœ : Module R N\nh' : Finite R N\nhN : IsTorsion R N\nâŠ¢ âˆƒ Î¹ x p, âˆƒ (_ : âˆ€ (i : Î¹), Irreducible (p i)), âˆƒ e, Nonempty (N â‰ƒâ‚—[R] â¨ (i : Î¹), R â§¸ span R {p i ^ e i})"
    },
    {
      "name": "Module.finite_of_rank_eq_zero",
      "statement": "R : Type u\nM Mâ‚ : Type v\nM' : Type v'\nÎ¹ : Type w\ninstâœâ· : Ring R\ninstâœâ¶ : AddCommGroup M\ninstâœâµ : AddCommGroup M'\ninstâœâ´ : AddCommGroup Mâ‚\ninstâœÂ³ : Module R M\ninstâœÂ² : Module R M'\ninstâœÂ¹ : Module R Mâ‚\ninstâœ : NoZeroSMulDivisors R M\nh : Module.rank R M = 0\nâŠ¢ Finite R M"
    },
    {
      "name": "Monoid.CoprodI.NeWord.replaceHead_head",
      "statement": "Î¹ : Type u_1\nM : Î¹ â†’ Type u_2\ninstâœÂ¹ : (i : Î¹) â†’ Monoid (M i)\nN : Type u_3\ninstâœ : Monoid N\ni j : Î¹\nx : M i\nhnotone : x â‰  1\nw : NeWord M i j\nâŠ¢ (replaceHead x hnotone w).head = x"
    },
    {
      "name": "Monoid.CoprodI.Word.prod_rcons",
      "statement": "Î¹ : Type u_1\nM : Î¹ â†’ Type u_2\ninstâœÂ² : (i : Î¹) â†’ Monoid (M i)\nN : Type u_3\ninstâœÂ¹ : Monoid N\ninstâœ : (i : Î¹) â†’ DecidableEq (M i)\ni : Î¹\np : Pair M i\nhm : p.head = 1\nâŠ¢ (rcons p).prod = of p.head * p.tail.prod"
    },
    {
      "name": "Monoid.PushoutI.NormalWord.summand_smul_def",
      "statement": "Î¹ : Type u_1\nG : Î¹ â†’ Type u_2\nH : Type u_3\nK : Type u_4\ninstâœâ´ : Monoid K\ninstâœÂ³ : (i : Î¹) â†’ Group (G i)\ninstâœÂ² : Group H\nÏ† : (i : Î¹) â†’ H â†’* G i\nd : Transversal Ï†\ninstâœÂ¹ : DecidableEq Î¹\ninstâœ : (i : Î¹) â†’ DecidableEq (G i)\ni : Î¹\ng : G i\nw : NormalWord d\nâŠ¢ (of i) g â€¢ w =\n    (equivPair i).symm\n      (let __src := (equivPair i) w;\n      { head := g * ((equivPair i) w).head, tail := __src.tail, fstIdx_ne := â‹¯, normalized := â‹¯ })"
    },
    {
      "name": "Monoid.fg_iff_submonoid_fg",
      "statement": "M : Type u_1\nNâœ : Type u_2\ninstâœÂ¹ : Monoid M\ninstâœ : AddMonoid Nâœ\nN : Submonoid M\nâŠ¢ FG â†¥N â†” N.FG"
    },
    {
      "name": "MonoidHom.coprod_comp_inr",
      "statement": "A : Type u_1\nB : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\nN : Type u_6\nP : Type u_7\ninstâœÂ² : MulOneClass M\ninstâœÂ¹ : MulOneClass N\ninstâœ : CommMonoid P\nf : M â†’* P\ng : N â†’* P\nx : N\nâŠ¢ ((f.coprod g).comp (inr M N)) x = g x"
    },
    {
      "name": "MulAction.stabilizer_finset_univ",
      "statement": "G : Type u_1\nH : Type u_2\nÎ± : Type u_3\ninstâœâ´ : Group G\ninstâœÂ³ : Group H\ninstâœÂ² : MulAction G Î±\na : G\ninstâœÂ¹ : DecidableEq Î±\ninstâœ : Fintype Î±\nâŠ¢ stabilizer G Finset.univ = âŠ¤"
    },
    {
      "name": "MulAction.stabilizer_mul_self",
      "statement": "G : Type u_1\nH : Type u_2\nÎ± : Type u_3\ninstâœÂ² : Group G\ninstâœÂ¹ : Group H\ninstâœ : MulAction G Î±\na : G\ns : Set G\nâŠ¢ â†‘(stabilizer G s) * s = s"
    },
    {
      "name": "MulOneClass.ext",
      "statement": "G : Type u_1\nM : Type u\nâŠ¢ âˆ€ â¦ƒmâ‚ mâ‚‚ : MulOneClass Mâ¦„, Mul.mul = Mul.mul â†’ mâ‚ = mâ‚‚"
    },
    {
      "name": "MulSemiringActionHom.id_comp",
      "statement": "M : Type u_1\ninstâœÂ²â´ : Monoid M\nN : Type u_2\ninstâœÂ²Â³ : Monoid N\nP : Type u_3\ninstâœÂ²Â² : Monoid P\nÏ† : M â†’* N\nÏ†' : N â†’* M\nÏˆ : N â†’* P\nÏ‡ : M â†’* P\nA : Type u_4\ninstâœÂ²Â¹ : AddMonoid A\ninstâœÂ²â° : DistribMulAction M A\nB : Type u_5\ninstâœÂ¹â¹ : AddMonoid B\ninstâœÂ¹â¸ : DistribMulAction N B\nBâ‚ : Type u_6\ninstâœÂ¹â· : AddMonoid Bâ‚\ninstâœÂ¹â¶ : DistribMulAction M Bâ‚\nC : Type u_7\ninstâœÂ¹âµ : AddMonoid C\ninstâœÂ¹â´ : DistribMulAction P C\nA' : Type u_8\ninstâœÂ¹Â³ : AddGroup A'\ninstâœÂ¹Â² : DistribMulAction M A'\nB' : Type u_9\ninstâœÂ¹Â¹ : AddGroup B'\ninstâœÂ¹â° : DistribMulAction N B'\nR : Type u_10\ninstâœâ¹ : Semiring R\ninstâœâ¸ : MulSemiringAction M R\nR' : Type u_11\ninstâœâ· : Ring R'\ninstâœâ¶ : MulSemiringAction M R'\nS : Type u_12\ninstâœâµ : Semiring S\ninstâœâ´ : MulSemiringAction N S\nS' : Type u_13\ninstâœÂ³ : Ring S'\ninstâœÂ² : MulSemiringAction N S'\nT : Type u_14\ninstâœÂ¹ : Semiring T\ninstâœ : MulSemiringAction P T\nf : R â†’â‚‘+*[Ï†] S\nx : R\nâŠ¢ ((MulSemiringActionHom.id N).comp f) x = f x"
    },
    {
      "name": "MultilinearMap.curry_uncurryRight",
      "statement": "R : Type uR\nS : Type uS\nÎ¹ : Type uÎ¹\nn : â„•\nM : Fin n.succ â†’ Type v\nMâ‚ : Î¹ â†’ Type vâ‚\nMâ‚‚ : Type vâ‚‚\nMâ‚ƒ : Type vâ‚ƒ\nM' : Type v'\ninstâœâ¶ : CommSemiring R\ninstâœâµ : (i : Fin n.succ) â†’ AddCommMonoid (M i)\ninstâœâ´ : AddCommMonoid M'\ninstâœÂ³ : AddCommMonoid Mâ‚‚\ninstâœÂ² : (i : Fin n.succ) â†’ Module R (M i)\ninstâœÂ¹ : Module R M'\ninstâœ : Module R Mâ‚‚\nf : MultilinearMap R (fun i => M i.castSucc) (M (last n) â†’â‚—[R] Mâ‚‚)\nâŠ¢ f.uncurryRight.curryRight = f"
    },
    {
      "name": "MultilinearMap.map_zero",
      "statement": "R : Type uR\nS : Type uS\nÎ¹ : Type uÎ¹\nn : â„•\nM : Fin n.succ â†’ Type v\nMâ‚ : Î¹ â†’ Type vâ‚\nMâ‚‚ : Type vâ‚‚\nMâ‚ƒ : Type vâ‚ƒ\nM' : Type v'\ninstâœÂ¹Â¹ : Semiring R\ninstâœÂ¹â° : (i : Fin n.succ) â†’ AddCommMonoid (M i)\ninstâœâ¹ : (i : Î¹) â†’ AddCommMonoid (Mâ‚ i)\ninstâœâ¸ : AddCommMonoid Mâ‚‚\ninstâœâ· : AddCommMonoid Mâ‚ƒ\ninstâœâ¶ : AddCommMonoid M'\ninstâœâµ : (i : Fin n.succ) â†’ Module R (M i)\ninstâœâ´ : (i : Î¹) â†’ Module R (Mâ‚ i)\ninstâœÂ³ : Module R Mâ‚‚\ninstâœÂ² : Module R Mâ‚ƒ\ninstâœÂ¹ : Module R M'\nf f' : MultilinearMap R Mâ‚ Mâ‚‚\ninstâœ : Nonempty Î¹\nâŠ¢ f 0 = 0"
    },
    {
      "name": "Multiset.Icc_eq_zero_iff",
      "statement": "Î± : Type u_1\ninstâœÂ¹ : Preorder Î±\ninstâœ : LocallyFiniteOrder Î±\na b c : Î±\nâŠ¢ Icc a b = 0 â†” Â¬a â‰¤ b"
    },
    {
      "name": "Multiset.Icc_self",
      "statement": "Î± : Type u_1\ninstâœÂ¹ : PartialOrder Î±\ninstâœ : LocallyFiniteOrder Î±\naâœ b a : Î±\nâŠ¢ Icc a a = {a}"
    },
    {
      "name": "Multiset.Nat.mem_antidiagonal",
      "statement": "n : â„•\nx : â„• Ã— â„•\nâŠ¢ x âˆˆ antidiagonal n â†” x.1 + x.2 = n"
    },
    {
      "name": "Multiset.card_disjSum",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\ns : Multiset Î±\nt : Multiset Î²\nâŠ¢ card (s.disjSum t) = card s + card t"
    },
    {
      "name": "Multiset.card_join",
      "statement": "Î± : Type u_1\nÎ² : Type v\nÎ³ : Type u_2\nÎ´ : Type u_3\nS : Multiset (Multiset Î±)\nâŠ¢ card (join 0) = (map (â‡‘card) 0).sum"
    },
    {
      "name": "Multiset.coe_sigma",
      "statement": "Î± : Type u_1\nÎ² : Type v\nÎ³ : Type u_2\nÎ´ : Type u_3\nÏƒ : Î± â†’ Type u_4\na : Î±\ns : Multiset Î±\nt : (a : Î±) â†’ Multiset (Ïƒ a)\nlâ‚ : List Î±\nlâ‚‚ : (a : Î±) â†’ List (Ïƒ a)\nâŠ¢ ((â†‘lâ‚).sigma fun a => â†‘(lâ‚‚ a)) = â†‘(lâ‚.sigma lâ‚‚)"
    },
    {
      "name": "Multiset.countP_nsmul",
      "statement": "Î± : Type u_1\nÎ² : Type v\nÎ³ : Type u_2\np : Î± â†’ Prop\ninstâœ : DecidablePred p\ns : Multiset Î±\nn : â„•\nâŠ¢ countP p (n â€¢ s) = n * countP p s"
    },
    {
      "name": "Multiset.count_sub",
      "statement": "Î± : Type u_1\nÎ² : Type v\nÎ³ : Type u_2\ninstâœ : DecidableEq Î±\nsâœ : Multiset Î±\na : Î±\ns t : Multiset Î±\nâŠ¢ count a (s - t) = count a s - count a t"
    },
    {
      "name": "Multiset.dedup_nsmul",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\ninstâœ : DecidableEq Î±\ns : Multiset Î±\nn : â„•\nh0 : n â‰  0\nâŠ¢ (n â€¢ s).dedup = s.dedup"
    },
    {
      "name": "Multiset.disjoint_toFinset",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœ : DecidableEq Î±\nm1 m2 : Multiset Î±\nâŠ¢ _root_.Disjoint m1.toFinset m2.toFinset â†” m1.Disjoint m2"
    },
    {
      "name": "Multiset.eq_union_right",
      "statement": "Î± : Type u_1\nÎ² : Type v\nÎ³ : Type u_2\ninstâœ : DecidableEq Î±\ns t u : Multiset Î±\na b : Î±\nh : s â‰¤ t\nâŠ¢ s âˆª t = t"
    },
    {
      "name": "Multiset.gcd_union",
      "statement": "Î± : Type u_1\ninstâœÂ² : CancelCommMonoidWithZero Î±\ninstâœÂ¹ : NormalizedGCDMonoid Î±\ninstâœ : DecidableEq Î±\nsâ‚ sâ‚‚ : Multiset Î±\nâŠ¢ (sâ‚ âˆª sâ‚‚).gcd = GCDMonoid.gcd sâ‚.gcd sâ‚‚.gcd"
    },
    {
      "name": "Multiset.inf_union",
      "statement": "Î± : Type u_1\ninstâœÂ² : SemilatticeInf Î±\ninstâœÂ¹ : OrderTop Î±\ninstâœ : DecidableEq Î±\nsâ‚ sâ‚‚ : Multiset Î±\nâŠ¢ (sâ‚ âˆª sâ‚‚).inf = sâ‚.inf âŠ“ sâ‚‚.inf"
    },
    {
      "name": "Multiset.le_inter",
      "statement": "Î± : Type u_1\nÎ² : Type v\nÎ³ : Type u_2\ninstâœ : DecidableEq Î±\ns t u : Multiset Î±\na b : Î±\nhâ‚ : s â‰¤ t\nhâ‚‚ : s â‰¤ u\nâŠ¢ s â‰¤ t âˆ© u"
    },
    {
      "name": "Multiset.map_congr",
      "statement": "Î± : Type u_1\nÎ² : Type v\nÎ³ : Type u_2\nf g : Î± â†’ Î²\ns t : Multiset Î±\nâŠ¢ s = t â†’ (âˆ€ x âˆˆ t, f x = g x) â†’ map f s = map g t"
    },
    {
      "name": "Multiset.map_le_map_iff",
      "statement": "Î± : Type u_1\nÎ² : Type v\nÎ³ : Type u_2\nf : Î± â†’ Î²\nhf : Injective f\ns t : Multiset Î±\nâŠ¢ map f s â‰¤ map f t â†” s â‰¤ t"
    },
    {
      "name": "Multiset.mem_nsmul",
      "statement": "Î± : Type u_1\nÎ² : Type v\nÎ³ : Type u_2\na : Î±\ns : Multiset Î±\nn : â„•\nh0 : n â‰  0\nâŠ¢ a âˆˆ n â€¢ s â†” a âˆˆ s"
    },
    {
      "name": "Multiset.mem_product",
      "statement": "Î± : Type u_1\nÎ² : Type v\nÎ³ : Type u_2\nÎ´ : Type u_3\naâœ : Î±\nbâœ : Î²\ns : Multiset Î±\nt : Multiset Î²\na : Î±\nb : Î²\nâŠ¢ (a, b) âˆˆ s.product t â†” (a, b).1 âˆˆ s âˆ§ (a, b).2 âˆˆ t"
    },
    {
      "name": "Multiset.nodup_bind",
      "statement": "Î± : Type u_1\nÎ² : Type v\nÎ³ : Type u_2\nÎ´ : Type u_3\na : Î±\ns t : Multiset Î±\nf g : Î± â†’ Multiset Î²\nâŠ¢ (s.bind f).Nodup â†” (âˆ€ a âˆˆ s, (f a).Nodup) âˆ§ Pairwise (fun a b => (f a).Disjoint (f b)) s"
    },
    {
      "name": "Multiset.noncommFold_coe",
      "statement": "F : Type u_1\nÎ¹ : Type u_2\nÎ± : Type u_3\nÎ² : Type u_4\nÎ³ : Type u_5\nf : Î± â†’ Î² â†’ Î²\nop : Î± â†’ Î± â†’ Î±\nassoc : Std.Associative op\nl : List Î±\ncomm : {x | x âˆˆ â†‘l}.Pairwise fun x y => op x y = op y x\na : Î±\nâŠ¢ noncommFold op (â†‘l) comm a = List.foldr op a l"
    },
    {
      "name": "Multiset.noncommProd_coe",
      "statement": "F : Type u_1\nÎ¹ : Type u_2\nÎ± : Type u_3\nÎ² : Type u_4\nÎ³ : Type u_5\nf : Î± â†’ Î² â†’ Î²\nop : Î± â†’ Î± â†’ Î±\ninstâœÂ¹ : Monoid Î±\ninstâœ : Monoid Î²\nl : List Î±\ncomm : {x | x âˆˆ â†‘l}.Pairwise Commute\nâŠ¢ (â†‘l).noncommProd comm = l.prod"
    },
    {
      "name": "Multiset.powerset_cons",
      "statement": "Î± : Type u_1\na : Î±\ns : Multiset Î±\nl : List Î±\nâŠ¢ (a ::â‚˜ âŸ¦lâŸ§).powerset = powerset âŸ¦lâŸ§ + map (cons a) (powerset âŸ¦lâŸ§)"
    },
    {
      "name": "Multiset.prod_join",
      "statement": "Î± : Type u_1\nÎ² : Type v\nÎ³ : Type u_2\nÎ´ : Type u_3\ninstâœ : CommMonoid Î±\nS : Multiset (Multiset Î±)\nâŠ¢ S.join.prod = (map prod S).prod"
    },
    {
      "name": "Multiset.prod_replicate",
      "statement": "F : Type u_1\nÎ¹ : Type u_2\nÎ± : Type u_3\nÎ² : Type u_4\nÎ³ : Type u_5\ninstâœÂ¹ : CommMonoid Î±\ninstâœ : CommMonoid Î²\ns t : Multiset Î±\naâœ : Î±\nm : Multiset Î¹\nf g : Î¹ â†’ Î±\nn : â„•\na : Î±\nâŠ¢ (replicate n a).prod = a ^ n"
    },
    {
      "name": "Multiset.product_cons",
      "statement": "Î± : Type u_1\nÎ² : Type v\nÎ³ : Type u_2\nÎ´ : Type u_3\na : Î±\nb : Î²\ns : Multiset Î±\nt : Multiset Î²\nâŠ¢ s Ã—Ë¢ (b ::â‚˜ t) = map (fun a => (a, b)) s + s Ã—Ë¢ t"
    },
    {
      "name": "Multiset.sub_filter_eq_filter_not",
      "statement": "Î± : Type u_1\nÎ² : Type v\nÎ³ : Type u_2\ninstâœÂ² : DecidableEq Î±\nsâœ : Multiset Î±\ninstâœÂ¹ : DecidableEq Î±\np : Î± â†’ Prop\ninstâœ : DecidablePred p\ns : Multiset Î±\nâŠ¢ s - filter p s = filter (fun a => Â¬p a) s"
    },
    {
      "name": "Multiset.sub_le_iff_le_add",
      "statement": "Î± : Type u_1\nÎ² : Type v\nÎ³ : Type u_2\ninstâœ : DecidableEq Î±\ns t u : Multiset Î±\na b : Î±\nâŠ¢ s - t â‰¤ u â†” s â‰¤ u + t"
    },
    {
      "name": "MvPFunctor.wRec_eq",
      "statement": "n : â„•\nP : MvPFunctor.{u} (n + 1)\nÎ± : TypeVec.{u} n\nC : Type u_1\ng : (a : P.A) â†’ P.drop.B a âŸ¹ Î± â†’ (P.last.B a â†’ P.W Î±) â†’ (P.last.B a â†’ C) â†’ C\na : P.A\nf' : P.drop.B a âŸ¹ Î±\nf : P.last.B a â†’ P.W Î±\nâŠ¢ P.wRec g (P.wMk a f' f) = g a f' f fun i => P.wRec g (f i)"
    },
    {
      "name": "MvPolynomial.IsSymmetric.map",
      "statement": "Ïƒ : Type u_1\nR : Type u_2\nÏ„ : Type u_3\nS : Type u_4\ninstâœÂ¹ : CommSemiring R\ninstâœ : CommSemiring S\nÏ† Ïˆ : MvPolynomial Ïƒ R\nhÏ† : Ï†.IsSymmetric\nf : R â†’+* S\ne : Perm Ïƒ\nâŠ¢ (rename â‡‘e) ((MvPolynomial.map f) Ï†) = (MvPolynomial.map f) Ï†"
    },
    {
      "name": "MvPolynomial.aevalTower_ofId",
      "statement": "R : Type u\nSâ‚ : Type v\nSâ‚‚ : Type w\nSâ‚ƒ : Type x\nÏƒ : Type u_1\na a' aâ‚ aâ‚‚ : R\ne : â„•\nn m : Ïƒ\ns : Ïƒ â†’â‚€ â„•\ninstâœâ· : CommSemiring R\ninstâœâ¶ : CommSemiring Sâ‚\np q : MvPolynomial Ïƒ R\nS : Type u_2\nA : Type u_3\nB : Type u_4\ninstâœâµ : CommSemiring S\ninstâœâ´ : CommSemiring A\ninstâœÂ³ : CommSemiring B\ninstâœÂ² : Algebra S R\ninstâœÂ¹ : Algebra S A\ninstâœ : Algebra S B\ng : R â†’â‚[S] A\ny : Ïƒ â†’ A\nâŠ¢ aevalTower (Algebra.ofId S A) = aeval"
    },
    {
      "name": "MvPolynomial.algebraTensorAlgEquiv_symm_X",
      "statement": "R : Type u\nM : Type v\nN : Type w\ninstâœâ¹ : CommSemiring R\ninstâœâ¸ : AddCommMonoid M\ninstâœâ· : Module R M\nÏƒ : Type u_1\ninstâœâ¶ : DecidableEq Ïƒ\nS : Type u_2\ninstâœâµ : CommSemiring S\ninstâœâ´ : Algebra R S\ninstâœÂ³ : CommSemiring N\ninstâœÂ² : Algebra R N\nA : Type u_3\ninstâœÂ¹ : CommSemiring A\ninstâœ : Algebra R A\ns : Ïƒ\nâŠ¢ (algebraTensorAlgEquiv R A).symm (X s) = 1 âŠ—â‚œ[R] X s"
    },
    {
      "name": "MvPolynomial.algebraTensorAlgEquiv_tmul",
      "statement": "R : Type u\nM : Type v\nN : Type w\ninstâœâ¹ : CommSemiring R\ninstâœâ¸ : AddCommMonoid M\ninstâœâ· : Module R M\nÏƒ : Type u_1\ninstâœâ¶ : DecidableEq Ïƒ\nS : Type u_2\ninstâœâµ : CommSemiring S\ninstâœâ´ : Algebra R S\ninstâœÂ³ : CommSemiring N\ninstâœÂ² : Algebra R N\nA : Type u_3\ninstâœÂ¹ : CommSemiring A\ninstâœ : Algebra R A\na : A\np : MvPolynomial Ïƒ R\nâŠ¢ (algebraTensorAlgEquiv R A) (a âŠ—â‚œ[R] p) = a â€¢ (map (algebraMap R A)) p"
    },
    {
      "name": "MvPolynomial.coe_monomial",
      "statement": "Ïƒ : Type u_1\nR : Type u_2\ninstâœ : CommSemiring R\nÏ† Ïˆ : MvPolynomial Ïƒ R\nn : Ïƒ â†’â‚€ â„•\na : R\nm : Ïƒ â†’â‚€ â„•\nâŠ¢ (MvPowerSeries.coeff R m) â†‘((monomial n) a) = (MvPowerSeries.coeff R m) ((MvPowerSeries.monomial R n) a)"
    },
    {
      "name": "MvPolynomial.coeff_rename_mapDomain",
      "statement": "Ïƒ : Type u_1\nÏ„ : Type u_2\nÎ± : Type u_3\nR : Type u_4\nS : Type u_5\ninstâœÂ¹ : CommSemiring R\ninstâœ : CommSemiring S\nf : Ïƒ â†’ Ï„\nhf : Injective f\nÏ† : MvPolynomial Ïƒ R\nd : Ïƒ â†’â‚€ â„•\nâŠ¢ coeff (Finsupp.mapDomain f d) ((rename f) Ï†) = coeff d Ï†"
    },
    {
      "name": "MvPolynomial.comp_evalâ‚‚Hom",
      "statement": "R : Type u\nSâ‚ : Type v\nSâ‚‚ : Type w\nSâ‚ƒ : Type x\nÏƒ : Type u_1\na a' aâ‚ aâ‚‚ : R\ne : â„•\nn m : Ïƒ\ns : Ïƒ â†’â‚€ â„•\ninstâœÂ² : CommSemiring R\ninstâœÂ¹ : CommSemiring Sâ‚\np q : MvPolynomial Ïƒ R\nfâœ : R â†’+* Sâ‚\ngâœ : Ïƒ â†’ Sâ‚\ninstâœ : CommSemiring Sâ‚‚\nf : R â†’+* Sâ‚\ng : Ïƒ â†’ Sâ‚\nÏ† : Sâ‚ â†’+* Sâ‚‚\nâŠ¢ Ï†.comp (evalâ‚‚Hom f g) = evalâ‚‚Hom (Ï†.comp f) fun i => Ï† (g i)"
    },
    {
      "name": "MvPolynomial.derivation_C_mul",
      "statement": "Ïƒ : Type u_1\nR : Type u_2\nA : Type u_3\ninstâœÂ³ : CommSemiring R\ninstâœÂ² : AddCommMonoid A\ninstâœÂ¹ : Module R A\ninstâœ : Module (MvPolynomial Ïƒ R) A\nD : Derivation R (MvPolynomial Ïƒ R) A\na : R\nf : MvPolynomial Ïƒ R\nâŠ¢ C a â€¢ D f = a â€¢ D f"
    },
    {
      "name": "MvPolynomial.evalâ‚‚_add",
      "statement": "R : Type u\nSâ‚ : Type v\nSâ‚‚ : Type w\nSâ‚ƒ : Type x\nÏƒ : Type u_1\na a' aâ‚ aâ‚‚ : R\ne : â„•\nn m : Ïƒ\ns : Ïƒ â†’â‚€ â„•\ninstâœÂ¹ : CommSemiring R\ninstâœ : CommSemiring Sâ‚\np q : MvPolynomial Ïƒ R\nf : R â†’+* Sâ‚\ng : Ïƒ â†’ Sâ‚\nâŠ¢ evalâ‚‚ f g (p + q) = evalâ‚‚ f g p + evalâ‚‚ f g q"
    },
    {
      "name": "MvPolynomial.evalâ‚‚_eq_eval_map",
      "statement": "R : Type u\nSâ‚ : Type v\nSâ‚‚ : Type w\nSâ‚ƒ : Type x\nÏƒ : Type u_1\na a' aâ‚ aâ‚‚ : R\ne : â„•\nn m : Ïƒ\ns : Ïƒ â†’â‚€ â„•\ninstâœÂ¹ : CommSemiring R\ninstâœ : CommSemiring Sâ‚\npâœ q : MvPolynomial Ïƒ R\nf : R â†’+* Sâ‚\ng : Ïƒ â†’ Sâ‚\np : MvPolynomial Ïƒ R\nâŠ¢ evalâ‚‚ f g p = (eval g) ((map f) p)"
    },
    {
      "name": "MvPolynomial.evalâ‚‚_eta",
      "statement": "R : Type u\nSâ‚ : Type v\nSâ‚‚ : Type w\nSâ‚ƒ : Type x\nÏƒ : Type u_1\na a' aâ‚ aâ‚‚ : R\ne : â„•\nn m : Ïƒ\ns : Ïƒ â†’â‚€ â„•\ninstâœÂ¹ : CommSemiring R\ninstâœ : CommSemiring Sâ‚\npâœ q : MvPolynomial Ïƒ R\nf : R â†’+* Sâ‚\ng : Ïƒ â†’ Sâ‚\np : MvPolynomial Ïƒ R\nâŠ¢ evalâ‚‚ C X p = p"
    },
    {
      "name": "MvPolynomial.pderiv_monomial_single",
      "statement": "R : Type u\nÏƒ : Type v\na a' aâ‚ aâ‚‚ : R\ns : Ïƒ â†’â‚€ â„•\ninstâœ : CommSemiring R\ni : Ïƒ\nn : â„•\nâŠ¢ (pderiv i) ((monomial (single i n)) a) = (monomial (single i (n - 1))) (a * â†‘n)"
    },
    {
      "name": "MvPolynomial.psum_zero",
      "statement": "Ïƒ : Type u_1\nR : Type u_2\nÏ„ : Type u_3\nS : Type u_4\ninstâœÂ² : CommSemiring R\ninstâœÂ¹ : Fintype Ïƒ\ninstâœ : Fintype Ï„\nâŠ¢ psum Ïƒ R 0 = â†‘(Fintype.card Ïƒ)"
    },
    {
      "name": "MvPolynomial.sum_def",
      "statement": "R : Type u\nSâ‚ : Type v\nSâ‚‚ : Type w\nSâ‚ƒ : Type x\nÏƒ : Type u_1\na a' aâ‚ aâ‚‚ : R\ne : â„•\nn m : Ïƒ\ns : Ïƒ â†’â‚€ â„•\ninstâœÂ² : CommSemiring R\ninstâœÂ¹ : CommSemiring Sâ‚\npâœ q : MvPolynomial Ïƒ R\nA : Type u_2\ninstâœ : AddCommMonoid A\np : MvPolynomial Ïƒ R\nb : (Ïƒ â†’â‚€ â„•) â†’ R â†’ A\nâŠ¢ sum p b = âˆ‘ m âˆˆ p.support, b m (coeff m p)"
    },
    {
      "name": "MvPolynomial.vanishingIdeal_pointToPoint",
      "statement": "k : Type u_1\ninstâœ : Field k\nÏƒ : Type u_2\nV : Set (Ïƒ â†’ k)\np : MvPolynomial Ïƒ k\nhp : p âˆˆ PrimeSpectrum.vanishingIdeal (pointToPoint '' V)\nx : Ïƒ â†’ k\nhx : x âˆˆ V\nâŠ¢ (vanishingIdeal {x}).IsPrime"
    },
    {
      "name": "MvPowerSeries.C_inv",
      "statement": "Ïƒ : Type u_1\nR : Type u_2\nk : Type u_3\ninstâœ : Field k\nr : k\nâŠ¢ ((C Ïƒ k) r)â»Â¹ = (C Ïƒ k) râ»Â¹"
    },
    {
      "name": "MvPowerSeries.coeff_C_mul",
      "statement": "Ïƒ : Type u_1\nR : Type u_2\ninstâœ : Semiring R\nn : Ïƒ â†’â‚€ â„•\nÏ† : MvPowerSeries Ïƒ R\na : R\nâŠ¢ (coeff R n) ((C Ïƒ R) a * Ï†) = a * (coeff R n) Ï†"
    },
    {
      "name": "MvPowerSeries.coeff_zero_X",
      "statement": "Ïƒ : Type u_1\nR : Type u_2\ninstâœ : Semiring R\ns : Ïƒ\nâŠ¢ (coeff R 0) (X s) = 0"
    },
    {
      "name": "MvPowerSeries.coeff_zero_mul_X",
      "statement": "Ïƒ : Type u_1\nR : Type u_2\ninstâœ : Semiring R\nÏ† : MvPowerSeries Ïƒ R\ns : Ïƒ\nâŠ¢ (coeff R 0) (Ï† * X s) = 0"
    },
    {
      "name": "MvPowerSeries.invOfUnit_eq'",
      "statement": "Ïƒ : Type u_1\nR : Type u_2\nk : Type u_3\ninstâœ : Field k\nÏ† : MvPowerSeries Ïƒ k\nu : kË£\nh : (constantCoeff Ïƒ k) Ï† = â†‘u\nâŠ¢ Ï†.invOfUnit u = Ï†â»Â¹"
    },
    {
      "name": "MvPowerSeries.monomial_mul_monomial",
      "statement": "Ïƒ : Type u_1\nR : Type u_2\ninstâœ : Semiring R\nm n : Ïƒ â†’â‚€ â„•\na b : R\nâŠ¢ (monomial R m) a * (monomial R n) b = (monomial R (m + n)) (a * b)"
    },
    {
      "name": "MvPowerSeries.mul_inv_rev",
      "statement": "Ïƒ : Type u_1\nR : Type u_2\nk : Type u_3\ninstâœ : Field k\nÏ† Ïˆ : MvPowerSeries Ïƒ k\nâŠ¢ (Ï† * Ïˆ)â»Â¹ = Ïˆâ»Â¹ * Ï†â»Â¹"
    },
    {
      "name": "NFA.toDFA_correct",
      "statement": "Î± : Type u\nÏƒ Ïƒ' : Type v\nM : NFA Î± Ïƒ\nâŠ¢ M.toDFA.accepts = M.accepts"
    },
    {
      "name": "NNRat.addSubmonoid_closure_range_pow",
      "statement": "n : â„•\nhnâ‚€ : n â‰  0\nâŠ¢ closure (range fun x => x ^ n) = âŠ¤"
    },
    {
      "name": "NNRat.mul_den_eq_num",
      "statement": "p qâœ : â„šâ‰¥0\nnâ‚ nâ‚‚ dâ‚ dâ‚‚ d : â„•\nq : â„šâ‰¥0\nâŠ¢ q * â†‘q.den = â†‘q.num"
    },
    {
      "name": "NNReal.coe_sInf",
      "statement": "r râ‚ râ‚‚ : â„â‰¥0\nx y : â„\ns : Set â„â‰¥0\nâŠ¢ â†‘(sInf s) = sInf (toReal '' s)"
    },
    {
      "name": "NNReal.le_inv_iff_mul_le",
      "statement": "r p : â„â‰¥0\nh : p â‰  0\nâŠ¢ r â‰¤ pâ»Â¹ â†” r * p â‰¤ 1"
    },
    {
      "name": "NNReal.one_le_coe",
      "statement": "r râ‚ râ‚‚ : â„â‰¥0\nx y : â„\nâŠ¢ 1 â‰¤ â†‘r â†” 1 â‰¤ r"
    },
    {
      "name": "NNReal.sSup_of_not_bddAbove",
      "statement": "Î¹ : Sort u_1\nf : Î¹ â†’ â„â‰¥0\ns : Set â„â‰¥0\nhs : Â¬BddAbove s\nâŠ¢ sSup s = 0"
    },
    {
      "name": "NNReal.sqrt_eq_rpow",
      "statement": "w xâœ y z : â„\nx : â„â‰¥0\nâŠ¢ sqrt x = x ^ (1 / 2)"
    },
    {
      "name": "NNReal.sqrt_one",
      "statement": "x y : â„â‰¥0\nâŠ¢ sqrt 1 = 1"
    },
    {
      "name": "NNReal.tendsto_pow_atTop_nhds_zero_iff",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nr : â„â‰¥0\nh : Tendsto (fun n => r ^ n) atTop (ğ“ 0)\nâŠ¢ r < 1"
    },
    {
      "name": "Nat.ModEq.add_left_cancel",
      "statement": "m n a b c d : â„•\nhâ‚ : a â‰¡ b [MOD n]\nhâ‚‚ : a + c â‰¡ b + d [MOD n]\nâŠ¢ c â‰¡ d [MOD n]"
    },
    {
      "name": "Nat.Partrec'.of_part",
      "statement": "this : âˆ€ (f : â„• â†’. â„•), Partrec f â†’ Partrec' fun v => f v.head\nn : â„•\nf : Vector â„• n â†’. â„•\nhf : _root_.Partrec f\nâŠ¢ Partrec' f"
    },
    {
      "name": "Nat.WithBot.coe_nonneg",
      "statement": "n : â„•\nâŠ¢ 0 â‰¤ â†‘n"
    },
    {
      "name": "Nat.add_eq_two_iff",
      "statement": "a b c d m n k : â„•\np q : â„• â†’ Prop\nâŠ¢ m + n = 2 â†” m = 0 âˆ§ n = 2 âˆ¨ m = 1 âˆ§ n = 1 âˆ¨ m = 2 âˆ§ n = 0"
    },
    {
      "name": "Nat.add_modEq_right",
      "statement": "m n a b c d : â„•\nâŠ¢ a + n â‰¡ a [MOD n]"
    },
    {
      "name": "Nat.add_pos_iff_pos_or_pos",
      "statement": "a b c d m n k : â„•\np q : â„• â†’ Prop\nâŠ¢ 0 < m + n â†” 0 < m âˆ¨ 0 < n"
    },
    {
      "name": "Nat.binCast_eq",
      "statement": "R : Type u_1\ninstâœ : AddMonoidWithOne R\nn : â„•\nâŠ¢ n.binCast = â†‘n"
    },
    {
      "name": "Nat.bit_cases_on_injective",
      "statement": "m n : â„•\nC : â„• â†’ Sort u\nâŠ¢ Function.Injective fun H n => n.bitCasesOn H"
    },
    {
      "name": "Nat.bit_ne_zero_iff",
      "statement": "n : â„•\nb : Bool\nâŠ¢ bit b n â‰  0 â†” n = 0 â†’ b = true"
    },
    {
      "name": "Nat.bit_val",
      "statement": "m nâœ : â„•\nb : Bool\nn : â„•\nâŠ¢ bit b n = 2 * n + bif b then 1 else 0"
    },
    {
      "name": "Nat.bitwise_zero_right",
      "statement": "f : Bool â†’ Bool â†’ Bool\nn : â„•\nâŠ¢ bitwise f n 0 = if f true false = true then n else 0"
    },
    {
      "name": "Nat.bodd_add",
      "statement": "mâœ nâœ m n : â„•\nâŠ¢ (m + n).bodd = bxor m.bodd n.bodd"
    },
    {
      "name": "Nat.bodd_mul",
      "statement": "mâœ nâœ m n : â„•\nâŠ¢ (m * n).bodd = (m.bodd && n.bodd)"
    },
    {
      "name": "Nat.card_uIcc",
      "statement": "a b c : â„•\nâŠ¢ a âŠ” b + 1 - a âŠ“ b = (â†‘b - â†‘a).natAbs + 1"
    },
    {
      "name": "Nat.cast_add",
      "statement": "R : Type u_1\ninstâœ : AddMonoidWithOne R\nm n : â„•\nâŠ¢ â†‘(m + n) = â†‘m + â†‘n"
    },
    {
      "name": "Nat.cast_div",
      "statement": "Î± : Type u_1\ninstâœ : DivisionSemiring Î±\nm n : â„•\nn_dvd : n âˆ£ m\nhn : â†‘n â‰  0\nâŠ¢ â†‘(m / n) = â†‘m / â†‘n"
    },
    {
      "name": "Nat.cast_natAbs",
      "statement": "Î± : Type u_1\ninstâœ : AddGroupWithOne Î±\nn : â„¤\nâŠ¢ â†‘n.natAbs = â†‘|n|"
    },
    {
      "name": "Nat.cast_pos'",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\ninstâœâ´ : AddMonoidWithOne Î±\ninstâœÂ³ : PartialOrder Î±\ninstâœÂ² : CovariantClass Î± Î± (fun x x_1 => x + x_1) fun x x_1 => x â‰¤ x_1\ninstâœÂ¹ : ZeroLEOneClass Î±\ninstâœ : NeZero 1\nn : â„•\nâŠ¢ 0 < â†‘n â†” 0 < n"
    },
    {
      "name": "Nat.cast_tsub",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : CanonicallyOrderedCommSemiring Î±\ninstâœÂ² : Sub Î±\ninstâœÂ¹ : OrderedSub Î±\ninstâœ : ContravariantClass Î± Î± (fun x x_1 => x + x_1) fun x x_1 => x â‰¤ x_1\nm n : â„•\nâŠ¢ â†‘(m - n) = â†‘m - â†‘n"
    },
    {
      "name": "Nat.ceilRoot_one_right",
      "statement": "a b n : â„•\nhn : n â‰  0\nâŠ¢ n.ceilRoot 1 = 1"
    },
    {
      "name": "Nat.ceil_eq_zero",
      "statement": "F : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : LinearOrderedSemiring Î±\ninstâœ : FloorSemiring Î±\na : Î±\nn : â„•\nâŠ¢ âŒˆaâŒ‰â‚Š = 0 â†” a â‰¤ 0"
    },
    {
      "name": "Nat.coprime_self_add_left",
      "statement": "m n : â„•\nâŠ¢ (m + n).Coprime m â†” n.Coprime m"
    },
    {
      "name": "Nat.digits_of_lt",
      "statement": "n b x : â„•\nhx : x â‰  0\nhxb : x < b\nâŠ¢ b.digits x = [x]"
    },
    {
      "name": "Nat.dist_cast_rat",
      "statement": "x y : â„•\nâŠ¢ dist â†‘x â†‘y = dist x y"
    },
    {
      "name": "Nat.factorization_div",
      "statement": "a b m nâœ p d n : â„•\nh : d âˆ£ n\nâŠ¢ (n / d).factorization = n.factorization - d.factorization"
    },
    {
      "name": "Nat.fib_pos",
      "statement": "n : â„•\nâŠ¢ 0 < fib n â†” 0 < n"
    },
    {
      "name": "Nat.floorRoot_zero_right",
      "statement": "a b nâœ n : â„•\nâŠ¢ n.floorRoot 0 = 0"
    },
    {
      "name": "Nat.gcd_add_mul_right_right",
      "statement": "m n k : â„•\nâŠ¢ m.gcd (n + k * m) = m.gcd n"
    },
    {
      "name": "Nat.gcd_add_self_left",
      "statement": "m n : â„•\nâŠ¢ (m + n).gcd n = m.gcd n"
    },
    {
      "name": "Nat.gcd_mul_left_add_left",
      "statement": "m n k : â„•\nâŠ¢ (n * k + m).gcd n = m.gcd n"
    },
    {
      "name": "Nat.gcd_mul_right_add_right",
      "statement": "m n k : â„•\nâŠ¢ m.gcd (k * m + n) = m.gcd n"
    },
    {
      "name": "Nat.gcd_self_add_right",
      "statement": "m n : â„•\nâŠ¢ m.gcd (m + n) = m.gcd n"
    },
    {
      "name": "Nat.gcd_sub_self_left",
      "statement": "m n : â„•\nh : m â‰¤ n\nâŠ¢ (n - m).gcd m = n.gcd m"
    },
    {
      "name": "Nat.gcd_sub_self_right",
      "statement": "m n : â„•\nh : m â‰¤ n\nâŠ¢ m.gcd (n - m) = m.gcd n"
    },
    {
      "name": "Nat.greatestFib_eq_zero",
      "statement": "l : List â„•\na m n : â„•\nh : n.greatestFib = 0\nâŠ¢ n = 0"
    },
    {
      "name": "Nat.greatestFib_pos",
      "statement": "l : List â„•\na m n : â„•\nâŠ¢ 0 < n.greatestFib â†” 0 < n"
    },
    {
      "name": "Nat.half_le_of_sub_le_half",
      "statement": "a b c d m n k : â„•\np q : â„• â†’ Prop\nh : a - b â‰¤ a / 2\nâŠ¢ a / 2 â‰¤ b"
    },
    {
      "name": "Nat.isCoprime_iff_coprime",
      "statement": "R : Type u\nI : Type v\ninstâœ : CommSemiring R\nx y z : R\ns : I â†’ R\nt : Finset I\nm n : â„•\nâŠ¢ IsCoprime â†‘m â†‘n â†” m.Coprime n"
    },
    {
      "name": "Nat.le_and_le_add_one_iff",
      "statement": "a b c d m n k : â„•\np q : â„• â†’ Prop\nâŠ¢ n â‰¤ m âˆ§ m â‰¤ n + 1 â†” m = n âˆ¨ m = n + 1"
    },
    {
      "name": "Nat.log_div_mul_self",
      "statement": "b n : â„•\nâŠ¢ log b (n / b * b) = log b n"
    },
    {
      "name": "Nat.log_le_clog",
      "statement": "b n : â„•\nâŠ¢ log b n â‰¤ clog b n"
    },
    {
      "name": "Nat.minFac_eq_two_iff",
      "statement": "nâœ n : â„•\nâŠ¢ n.minFac = 2 â†” 2 âˆ£ n"
    },
    {
      "name": "Nat.mul_add_mod'",
      "statement": "aâœ bâœ câœ d m n k : â„•\np q : â„• â†’ Prop\na b c : â„•\nâŠ¢ (a * b + c) % b = c % b"
    },
    {
      "name": "Nat.multichoose_one",
      "statement": "k : â„•\nâŠ¢ multichoose 1 k = 1"
    },
    {
      "name": "Nat.multichoose_zero_right",
      "statement": "n : â„•\nâŠ¢ n.multichoose 0 = 1"
    },
    {
      "name": "Nat.odd_mod_four_iff",
      "statement": "m nâœ a b c d n : â„•\nâŠ¢ âˆ€ m < 4, m % 2 = 1 â†’ m = 1 âˆ¨ m = 3"
    },
    {
      "name": "Nat.odd_of_mod_four_eq_three",
      "statement": "m nâœ a b c d n : â„•\nâŠ¢ n % 4 = 3 â†’ n % 2 = 1"
    },
    {
      "name": "Nat.one_add_le_iff",
      "statement": "a b c d m n k : â„•\np q : â„• â†’ Prop\nâŠ¢ 1 + m â‰¤ n â†” m < n"
    },
    {
      "name": "Nat.pair_unpair",
      "statement": "n : â„•\nâŠ¢ pair (unpair n).1 (unpair n).2 = n"
    },
    {
      "name": "Nat.perfect_iff_sum_divisors_eq_two_mul",
      "statement": "n : â„•\nh : 0 < n\nâŠ¢ n.Perfect â†” âˆ‘ i âˆˆ n.divisors, i = 2 * n"
    },
    {
      "name": "Nat.pow_eq_zero",
      "statement": "aâœ b c d m n k : â„•\np q : â„• â†’ Prop\na : â„•\nâŠ¢ a ^ 0 = 0 â†” a = 0 âˆ§ 0 â‰  0"
    },
    {
      "name": "Nat.pred_le_iff",
      "statement": "a b c d m n k : â„•\np q : â„• â†’ Prop\nâŠ¢ m â‰¤ n.succ â†’ m.pred â‰¤ n"
    },
    {
      "name": "Nat.primeFactors_eq_empty",
      "statement": "a b k m n p : â„•\nâŠ¢ n.primeFactors = âˆ… â†” n = 0 âˆ¨ n = 1"
    },
    {
      "name": "Nat.prime_three",
      "statement": "n : â„•\nâŠ¢ Prime 3"
    },
    {
      "name": "Nat.prime_two",
      "statement": "n : â„•\nâŠ¢ Prime 2"
    },
    {
      "name": "Nat.sInf_eq_zero",
      "statement": "s : Set â„•\nâŠ¢ sInf s = 0 â†” 0 âˆˆ s âˆ¨ s = âˆ…"
    },
    {
      "name": "Nat.sum_zeckendorf_fib",
      "statement": "l : List â„•\na m nâœ n : â„•\nâŠ¢ (map fib n.zeckendorf).sum = n"
    },
    {
      "name": "Nat.swap_mem_divisorsAntidiagonal",
      "statement": "n : â„•\nx : â„• Ã— â„•\nâŠ¢ x.swap âˆˆ n.divisorsAntidiagonal â†” x âˆˆ n.divisorsAntidiagonal"
    },
    {
      "name": "Nat.zero_eq_mul",
      "statement": "a b c d m n k : â„•\np q : â„• â†’ Prop\nâŠ¢ 0 = m * n â†” m = 0 âˆ¨ n = 0"
    },
    {
      "name": "NonUnitalAlgHom.coe_distribMulActionHom_mk",
      "statement": "R : Type u\nS : Type uâ‚\nT : Type u_1\ninstâœâ¸ : Monoid R\ninstâœâ· : Monoid S\ninstâœâ¶ : Monoid T\nÏ† : R â†’* S\nA : Type v\nB : Type w\nC : Type wâ‚\ninstâœâµ : NonUnitalNonAssocSemiring A\ninstâœâ´ : DistribMulAction R A\ninstâœÂ³ : NonUnitalNonAssocSemiring B\ninstâœÂ² : DistribMulAction S B\ninstâœÂ¹ : NonUnitalNonAssocSemiring C\ninstâœ : DistribMulAction T C\nf : A â†’â‚›â‚™â‚[Ï†] B\nhâ‚ : âˆ€ (m : R) (x : A), f (m â€¢ x) = Ï† m â€¢ f x\nhâ‚‚ : { toFun := â‡‘f, map_smul' := hâ‚ }.toFun 0 = 0\nhâ‚ƒ :\n  âˆ€ (x y : A),\n    { toFun := â‡‘f, map_smul' := hâ‚ }.toFun (x + y) =\n      { toFun := â‡‘f, map_smul' := hâ‚ }.toFun x + { toFun := â‡‘f, map_smul' := hâ‚ }.toFun y\nhâ‚„ :\n  âˆ€ (x y : A),\n    { toFun := â‡‘f, map_smul' := hâ‚, map_zero' := hâ‚‚, map_add' := hâ‚ƒ }.toFun (x * y) =\n      { toFun := â‡‘f, map_smul' := hâ‚, map_zero' := hâ‚‚, map_add' := hâ‚ƒ }.toFun x *\n        { toFun := â‡‘f, map_smul' := hâ‚, map_zero' := hâ‚‚, map_add' := hâ‚ƒ }.toFun y\nâŠ¢ â†‘{ toFun := â‡‘f, map_smul' := hâ‚, map_zero' := hâ‚‚, map_add' := hâ‚ƒ, map_mul' := hâ‚„ } =\n    { toFun := â‡‘f, map_smul' := hâ‚, map_zero' := hâ‚‚, map_add' := hâ‚ƒ }"
    },
    {
      "name": "NonUnitalAlgHom.fst_prod",
      "statement": "R : Type u\nS : Type uâ‚\nT : Type u_1\ninstâœÂ¹Â² : Monoid R\ninstâœÂ¹Â¹ : Monoid S\ninstâœÂ¹â° : Monoid T\nÏ† : R â†’* S\nA : Type v\nB : Type w\nC : Type wâ‚\ninstâœâ¹ : NonUnitalNonAssocSemiring A\ninstâœâ¸ : DistribMulAction R A\ninstâœâ· : NonUnitalNonAssocSemiring B\ninstâœâ¶ : DistribMulAction S B\ninstâœâµ : NonUnitalNonAssocSemiring C\ninstâœâ´ : DistribMulAction T C\nÏ†' : S â†’* R\nÏˆ : S â†’* T\nÏ‡ : R â†’* T\nBâ‚ : Type u_2\ninstâœÂ³ : NonUnitalNonAssocSemiring Bâ‚\ninstâœÂ² : DistribMulAction R Bâ‚\ninstâœÂ¹ : DistribMulAction R B\ninstâœ : DistribMulAction R C\nf : A â†’â‚™â‚[R] B\ng : A â†’â‚™â‚[R] C\nâŠ¢ (fst R B C).comp (f.prod g) = f"
    },
    {
      "name": "NonUnitalAlgHom.mk_coe",
      "statement": "R : Type u\nS : Type uâ‚\nT : Type u_1\ninstâœâ¸ : Monoid R\ninstâœâ· : Monoid S\ninstâœâ¶ : Monoid T\nÏ† : R â†’* S\nA : Type v\nB : Type w\nC : Type wâ‚\ninstâœâµ : NonUnitalNonAssocSemiring A\ninstâœâ´ : DistribMulAction R A\ninstâœÂ³ : NonUnitalNonAssocSemiring B\ninstâœÂ² : DistribMulAction S B\ninstâœÂ¹ : NonUnitalNonAssocSemiring C\ninstâœ : DistribMulAction T C\nf : A â†’â‚›â‚™â‚[Ï†] B\nhâ‚ : âˆ€ (m : R) (x : A), f (m â€¢ x) = Ï† m â€¢ f x\nhâ‚‚ : { toFun := â‡‘f, map_smul' := hâ‚ }.toFun 0 = 0\nhâ‚ƒ :\n  âˆ€ (x y : A),\n    { toFun := â‡‘f, map_smul' := hâ‚ }.toFun (x + y) =\n      { toFun := â‡‘f, map_smul' := hâ‚ }.toFun x + { toFun := â‡‘f, map_smul' := hâ‚ }.toFun y\nhâ‚„ :\n  âˆ€ (x y : A),\n    { toFun := â‡‘f, map_smul' := hâ‚, map_zero' := hâ‚‚, map_add' := hâ‚ƒ }.toFun (x * y) =\n      { toFun := â‡‘f, map_smul' := hâ‚, map_zero' := hâ‚‚, map_add' := hâ‚ƒ }.toFun x *\n        { toFun := â‡‘f, map_smul' := hâ‚, map_zero' := hâ‚‚, map_add' := hâ‚ƒ }.toFun y\nâŠ¢ { toFun := â‡‘f, map_smul' := hâ‚, map_zero' := hâ‚‚, map_add' := hâ‚ƒ, map_mul' := hâ‚„ } = f"
    },
    {
      "name": "NonUnitalRingHom.cancel_left",
      "statement": "F : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\ninstâœÂ² : NonUnitalNonAssocSemiring Î±\ninstâœÂ¹ : NonUnitalNonAssocSemiring Î²\ninstâœ : NonUnitalNonAssocSemiring Î³\ngâœ : Î² â†’â‚™+* Î³\nf : Î± â†’â‚™+* Î²\ng : Î² â†’â‚™+* Î³\nfâ‚ fâ‚‚ : Î± â†’â‚™+* Î²\nhg : Injective â‡‘g\nh : g.comp fâ‚ = g.comp fâ‚‚\nx : Î±\nâŠ¢ g (fâ‚ x) = g (fâ‚‚ x)"
    },
    {
      "name": "NonUnitalStarAlgHom.mk_coe",
      "statement": "R : Type u_1\nA : Type u_2\nB : Type u_3\nC : Type u_4\nD : Type u_5\ninstâœÂ¹Â² : Monoid R\ninstâœÂ¹Â¹ : NonUnitalNonAssocSemiring A\ninstâœÂ¹â° : DistribMulAction R A\ninstâœâ¹ : Star A\ninstâœâ¸ : NonUnitalNonAssocSemiring B\ninstâœâ· : DistribMulAction R B\ninstâœâ¶ : Star B\ninstâœâµ : NonUnitalNonAssocSemiring C\ninstâœâ´ : DistribMulAction R C\ninstâœÂ³ : Star C\ninstâœÂ² : NonUnitalNonAssocSemiring D\ninstâœÂ¹ : DistribMulAction R D\ninstâœ : Star D\nf : A â†’â‹†â‚™â‚[R] B\nhâ‚ : âˆ€ (m : R) (x : A), f (m â€¢ x) = (MonoidHom.id R) m â€¢ f x\nhâ‚‚ : { toFun := â‡‘f, map_smul' := hâ‚ }.toFun 0 = 0\nhâ‚ƒ :\n  âˆ€ (x y : A),\n    { toFun := â‡‘f, map_smul' := hâ‚ }.toFun (x + y) =\n      { toFun := â‡‘f, map_smul' := hâ‚ }.toFun x + { toFun := â‡‘f, map_smul' := hâ‚ }.toFun y\nhâ‚„ :\n  âˆ€ (x y : A),\n    { toFun := â‡‘f, map_smul' := hâ‚, map_zero' := hâ‚‚, map_add' := hâ‚ƒ }.toFun (x * y) =\n      { toFun := â‡‘f, map_smul' := hâ‚, map_zero' := hâ‚‚, map_add' := hâ‚ƒ }.toFun x *\n        { toFun := â‡‘f, map_smul' := hâ‚, map_zero' := hâ‚‚, map_add' := hâ‚ƒ }.toFun y\nhâ‚… :\n  âˆ€ (a : A),\n    { toFun := â‡‘f, map_smul' := hâ‚, map_zero' := hâ‚‚, map_add' := hâ‚ƒ, map_mul' := hâ‚„ }.toFun (star a) =\n      star ({ toFun := â‡‘f, map_smul' := hâ‚, map_zero' := hâ‚‚, map_add' := hâ‚ƒ, map_mul' := hâ‚„ }.toFun a)\nâŠ¢ { toFun := â‡‘f, map_smul' := hâ‚, map_zero' := hâ‚‚, map_add' := hâ‚ƒ, map_mul' := hâ‚„, map_star' := hâ‚… } = f"
    },
    {
      "name": "NonUnitalStarAlgHom.realContinuousMapZeroOfNNReal_apply_comp_toReal",
      "statement": "X : Type u_1\ninstâœâ¸ : TopologicalSpace X\ninstâœâ· : Zero X\nA : Type u_2\ninstâœâ¶ : TopologicalSpace A\ninstâœâµ : NonUnitalRing A\ninstâœâ´ : StarRing A\ninstâœÂ³ : Module â„ A\ninstâœÂ² : IsScalarTower â„ A A\ninstâœÂ¹ : SMulCommClass â„ A A\ninstâœ : TopologicalRing A\nÏ† : C(X, â„â‰¥0)â‚€ â†’â‹†â‚™â‚[â„â‰¥0] A\nf : C(X, â„â‰¥0)â‚€\nâŠ¢ Ï†.realContinuousMapZeroOfNNReal ({ toFun := toReal, continuous_toFun := continuous_coe, map_zero' := â‹¯ }.comp f) = Ï† f"
    },
    {
      "name": "NonUnitalStarSubalgebra.iSupLift_mk",
      "statement": "F : Type v'\nR' : Type u'\nR : Type u\nA : Type v\nB : Type w\nC : Type w'\ninstâœÂ¹â· : CommSemiring R\ninstâœÂ¹â¶ : StarRing R\ninstâœÂ¹âµ : NonUnitalSemiring A\ninstâœÂ¹â´ : StarRing A\ninstâœÂ¹Â³ : Module R A\ninstâœÂ¹Â² : IsScalarTower R A A\ninstâœÂ¹Â¹ : SMulCommClass R A A\ninstâœÂ¹â° : StarModule R A\ninstâœâ¹ : NonUnitalSemiring B\ninstâœâ¸ : StarRing B\ninstâœâ· : Module R B\ninstâœâ¶ : IsScalarTower R B B\ninstâœâµ : SMulCommClass R B B\ninstâœâ´ : StarModule R B\ninstâœÂ³ : FunLike F A B\ninstâœÂ² : NonUnitalAlgHomClass F R A B\ninstâœÂ¹ : NonUnitalStarAlgHomClass F R A B\nS : NonUnitalStarSubalgebra R A\nÎ¹ : Type u_1\ninstâœ : Nonempty Î¹\nK : Î¹ â†’ NonUnitalStarSubalgebra R A\ndir : Directed (fun x x_1 => x â‰¤ x_1) K\nf : (i : Î¹) â†’ â†¥(K i) â†’â‹†â‚™â‚[R] B\nhf : âˆ€ (i j : Î¹) (h : K i â‰¤ K j), f i = (f j).comp (inclusion h)\nT : NonUnitalStarSubalgebra R A\nhT : T = iSup K\ni : Î¹\nx : â†¥(K i)\nhx : â†‘x âˆˆ T\nâŠ¢ (iSupLift K dir f hf T hT) âŸ¨â†‘x, hxâŸ© = (f i) x"
    },
    {
      "name": "NonUnitalSubalgebra.iSupLift_inclusion",
      "statement": "R : Type u\nA : Type v\nB : Type w\ninstâœâ¹ : CommSemiring R\ninstâœâ¸ : NonUnitalNonAssocSemiring A\ninstâœâ· : Module R A\ninstâœâ¶ : IsScalarTower R A A\ninstâœâµ : SMulCommClass R A A\ninstâœâ´ : NonUnitalNonAssocSemiring B\ninstâœÂ³ : Module R B\ninstâœÂ² : IsScalarTower R B B\ninstâœÂ¹ : SMulCommClass R B B\nS : NonUnitalSubalgebra R A\nÎ¹ : Type u_1\ninstâœ : Nonempty Î¹\nK : Î¹ â†’ NonUnitalSubalgebra R A\ndir : Directed (fun x x_1 => x â‰¤ x_1) K\nf : (i : Î¹) â†’ â†¥(K i) â†’â‚™â‚[R] B\nhf : âˆ€ (i j : Î¹) (h : K i â‰¤ K j), f i = (f j).comp (inclusion h)\nT : NonUnitalSubalgebra R A\nhT : T = iSup K\ni : Î¹\nx : â†¥(K i)\nh : K i â‰¤ T\nâŠ¢ (iSupLift K dir f hf T hT) ((inclusion h) x) = (f i) x"
    },
    {
      "name": "NonUnitalSubalgebra.iSupLift_mk",
      "statement": "R : Type u\nA : Type v\nB : Type w\ninstâœâ¹ : CommSemiring R\ninstâœâ¸ : NonUnitalNonAssocSemiring A\ninstâœâ· : Module R A\ninstâœâ¶ : IsScalarTower R A A\ninstâœâµ : SMulCommClass R A A\ninstâœâ´ : NonUnitalNonAssocSemiring B\ninstâœÂ³ : Module R B\ninstâœÂ² : IsScalarTower R B B\ninstâœÂ¹ : SMulCommClass R B B\nS : NonUnitalSubalgebra R A\nÎ¹ : Type u_1\ninstâœ : Nonempty Î¹\nK : Î¹ â†’ NonUnitalSubalgebra R A\ndir : Directed (fun x x_1 => x â‰¤ x_1) K\nf : (i : Î¹) â†’ â†¥(K i) â†’â‚™â‚[R] B\nhf : âˆ€ (i j : Î¹) (h : K i â‰¤ K j), f i = (f j).comp (inclusion h)\nT : NonUnitalSubalgebra R A\nhT : T = iSup K\ni : Î¹\nx : â†¥(K i)\nhx : â†‘x âˆˆ T\nâŠ¢ (iSupLift K dir f hf T hT) âŸ¨â†‘x, hxâŸ© = (f i) x"
    },
    {
      "name": "NonUnitalSubring.mem_closure_iff",
      "statement": "F : Type w\nR : Type u\nS : Type v\nT : Type u_1\ninstâœâ´ : NonUnitalNonAssocRing R\ninstâœÂ³ : NonUnitalNonAssocRing S\ninstâœÂ² : NonUnitalNonAssocRing T\ninstâœÂ¹ : FunLike F R S\ninstâœ : NonUnitalRingHomClass F R S\ng : S â†’â‚™+* T\nf : R â†’â‚™+* S\ns : Set R\nxâœ : R\nh : xâœ âˆˆ closure s\nx y : R\nhx : x âˆˆ AddSubgroup.closure â†‘(Subsemigroup.closure s)\nhy : y âˆˆ AddSubgroup.closure â†‘(Subsemigroup.closure s)\nq : R\nhq : q âˆˆ â†‘(Subsemigroup.closure s)\nâŠ¢ 0 * q âˆˆ AddSubgroup.closure â†‘(Subsemigroup.closure s)"
    },
    {
      "name": "NonUnitalSubsemiring.closure_addSubmonoid_closure",
      "statement": "R : Type u\nS : Type v\nT : Type w\ninstâœÂ² : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninstâœÂ¹ : NonUnitalNonAssocSemiring S\ninstâœ : NonUnitalNonAssocSemiring T\ns : Set R\nâŠ¢ closure â†‘(AddSubmonoid.closure s) = closure s"
    },
    {
      "name": "Nonneg.toNonneg_le",
      "statement": "Î± : Type u_1\ninstâœÂ¹ : Zero Î±\ninstâœ : LinearOrder Î±\na : Î±\nb : { x // 0 â‰¤ x }\nâŠ¢ toNonneg a â‰¤ b â†” a â‰¤ â†‘b"
    },
    {
      "name": "NormedAddGroupHom.NormNoninc.neg_iff",
      "statement": "V : Type u_1\nW : Type u_2\nVâ‚ : Type u_3\nVâ‚‚ : Type u_4\nVâ‚ƒ : Type u_5\ninstâœâ´ : SeminormedAddCommGroup V\ninstâœÂ³ : SeminormedAddCommGroup W\ninstâœÂ² : SeminormedAddCommGroup Vâ‚\ninstâœÂ¹ : SeminormedAddCommGroup Vâ‚‚\ninstâœ : SeminormedAddCommGroup Vâ‚ƒ\nfâœ : NormedAddGroupHom V W\nf : NormedAddGroupHom Vâ‚ Vâ‚‚\nh : (-f).NormNoninc\nx : Vâ‚\nâŠ¢ â€–f xâ€– â‰¤ â€–xâ€–"
    },
    {
      "name": "NormedAddGroupHom.coe_inj",
      "statement": "V : Type u_1\nVâ‚ : Type u_2\nVâ‚‚ : Type u_3\nVâ‚ƒ : Type u_4\ninstâœÂ³ : SeminormedAddCommGroup V\ninstâœÂ² : SeminormedAddCommGroup Vâ‚\ninstâœÂ¹ : SeminormedAddCommGroup Vâ‚‚\ninstâœ : SeminormedAddCommGroup Vâ‚ƒ\nf g : NormedAddGroupHom Vâ‚ Vâ‚‚\nH : â‡‘f = â‡‘g\nâŠ¢ f = g"
    },
    {
      "name": "NormedAddGroupHom.norm_completion",
      "statement": "G : Type u_1\ninstâœÂ² : SeminormedAddCommGroup G\nH : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup H\nK : Type u_3\ninstâœ : SeminormedAddCommGroup K\nf : NormedAddGroupHom G H\nx : G\nâŠ¢ â€–f xâ€– â‰¤ â€–f.completionâ€– * â€–xâ€–"
    },
    {
      "name": "NormedAddGroupHom.zero_comp",
      "statement": "V : Type u_1\nVâ‚ : Type u_2\nVâ‚‚ : Type u_3\nVâ‚ƒ : Type u_4\ninstâœÂ³ : SeminormedAddCommGroup V\ninstâœÂ² : SeminormedAddCommGroup Vâ‚\ninstâœÂ¹ : SeminormedAddCommGroup Vâ‚‚\ninstâœ : SeminormedAddCommGroup Vâ‚ƒ\nfâœ g f : NormedAddGroupHom Vâ‚ Vâ‚‚\nâŠ¢ NormedAddGroupHom.comp 0 f = 0"
    },
    {
      "name": "Num.castNum_or",
      "statement": "Î± : Type u_1\nâŠ¢ âˆ€ (m n : Num), â†‘(m ||| n) = â†‘m ||| â†‘n"
    },
    {
      "name": "Num.castNum_xor",
      "statement": "Î± : Type u_1\nâŠ¢ âˆ€ (m n : Num), â†‘(m ^^^ n) = â†‘m ^^^ â†‘n"
    },
    {
      "name": "Num.cast_lt",
      "statement": "Î± : Type u_1\ninstâœ : LinearOrderedSemiring Î±\nm n : Num\nâŠ¢ â†‘m < â†‘n â†” m < n"
    },
    {
      "name": "Num.div_zero",
      "statement": "n : Num\nâŠ¢ n.div 0 = 0"
    },
    {
      "name": "Num.gcd_to_nat",
      "statement": "âŠ¢ âˆ€ (a b : Num), â†‘(a.gcd b) = (â†‘a).gcd â†‘b"
    },
    {
      "name": "Num.ofZNum_toNat",
      "statement": "Î± : Type u_1\np : PosNum\nâŠ¢ â†‘(ofZNum (ZNum.pos p)) = (â†‘p).toNat"
    },
    {
      "name": "Num.pred_succ",
      "statement": "Î± : Type u_1\np : PosNum\nâŠ¢ (pos p).succ'.pred'.toZNumNeg = ZNum.neg p"
    },
    {
      "name": "Num.to_of_nat",
      "statement": "âŠ¢ â†‘â†‘0 = 0"
    },
    {
      "name": "NumberField.InfinitePlace.isReal_of_mk_isReal",
      "statement": "k : Type u_1\ninstâœÂ² : Field k\nK : Type u_2\ninstâœÂ¹ : Field K\nF : Type u_3\ninstâœ : Field F\nÏ† : K â†’+* â„‚\nh : (mk Ï†).IsReal\nâŠ¢ ComplexEmbedding.IsReal Ï†"
    },
    {
      "name": "NumberField.RingOfIntegers.isIntegral",
      "statement": "K : Type u_1\nL : Type u_2\ninstâœÂ¹ : Field K\ninstâœ : Field L\nnf : NumberField K\nx : ğ“ K\nâŠ¢ IsIntegral â„¤ x"
    },
    {
      "name": "NumberField.mixedEmbedding.convexBodySum_compact",
      "statement": "K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nB : â„\nâŠ¢ IsCompact (convexBodySum K B)"
    },
    {
      "name": "NumberField.mixedEmbedding.convexBodySum_convex",
      "statement": "K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nB : â„\nâŠ¢ Convex â„ (convexBodySum K B)"
    },
    {
      "name": "NumberField.mixedEmbedding.latticeBasis_apply",
      "statement": "K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\ni : ChooseBasisIndex â„¤ (ğ“ K)\nâŠ¢ (latticeBasis K) i = (mixedEmbedding K) ((integralBasis K) i)"
    },
    {
      "name": "ONote.fastGrowing_two",
      "statement": "âŠ¢ fastGrowing 2 = fun n => 2 ^ n * n"
    },
    {
      "name": "ONote.mulNat_eq_mul",
      "statement": "n : â„•\no : ONote\nâŠ¢ o.mulNat n = o * â†‘n"
    },
    {
      "name": "Odd.neg",
      "statement": "F : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nR : Type u_4\ninstâœ : Ring Î±\na b : Î±\nn : â„•\nhp : Odd a\nâŠ¢ Odd (-a)"
    },
    {
      "name": "Opens.pretopology_ofGrothendieck",
      "statement": "T : Type u\ninstâœ : TopologicalSpace T\nâŠ¢ Pretopology.ofGrothendieck (Opens T) (grothendieckTopology T) = pretopology T"
    },
    {
      "name": "Option.mapâ‚‚_coe_right",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\nfâœ : Î± â†’ Î² â†’ Î³\naâœ : Option Î±\nbâœ : Option Î²\nc : Option Î³\nf : Î± â†’ Î² â†’ Î³\na : Option Î±\nb : Î²\nâŠ¢ mapâ‚‚ f a (some b) = Option.map (fun a => f a b) a"
    },
    {
      "name": "Option.mapâ‚‚_eq_none_iff",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\nf : Î± â†’ Î² â†’ Î³\na : Option Î±\nb : Option Î²\nc : Option Î³\nâŠ¢ mapâ‚‚ f a b = none â†” a = none âˆ¨ b = none"
    },
    {
      "name": "Option.mem_map_of_injective",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\nf : Î± â†’ Î²\nH : Function.Injective f\na : Î±\no : Option Î±\nâŠ¢ f a âˆˆ Option.map f o â†” a âˆˆ o"
    },
    {
      "name": "Option.mem_toFinset",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\na : Î±\no : Option Î±\nâŠ¢ a âˆˆ o.toFinset â†” a âˆˆ o"
    },
    {
      "name": "Option.pbind_map",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\np : Î± â†’ Prop\nfâœ : (a : Î±) â†’ p a â†’ Î²\nxâœ : Option Î±\nf : Î± â†’ Î²\nx : Option Î±\ng : (b : Î²) â†’ b âˆˆ Option.map f x â†’ Option Î³\nâŠ¢ (Option.map f x).pbind g = x.pbind fun a h => g (f a) â‹¯"
    },
    {
      "name": "Option.pmap_eq_some_iff",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\np : Î± â†’ Prop\nf : (a : Î±) â†’ p a â†’ Î²\nx : Option Î±\nhf : âˆ€ (a : Î±), a âˆˆ x â†’ p a\ny : Î²\nâŠ¢ pmap f x hf = some y â†” âˆƒ a H, f a â‹¯ = y"
    },
    {
      "name": "OptionT.run_map",
      "statement": "Î± Î² : Type u\nm : Type u â†’ Type v\nx : OptionT m Î±\ninstâœÂ¹ : Monad m\nf : Î± â†’ Î²\ninstâœ : LawfulMonad m\nâŠ¢ (f <$> x).run = Option.map f <$> x.run"
    },
    {
      "name": "Order.isIdeal_sUnion_of_directedOn",
      "statement": "P : Type u_1\ninstâœ : Preorder P\nC : Set (Set P)\nhidl : âˆ€ I âˆˆ C, IsIdeal I\nhD : DirectedOn (fun x x_1 => x âŠ† x_1) C\nhNe : C.Nonempty\nâŠ¢ IsIdeal (â‹ƒâ‚€ C)"
    },
    {
      "name": "Order.isMax_iterate_succ_of_eq_of_lt",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : Preorder Î±\ninstâœ : SuccOrder Î±\na b : Î±\nn m : â„•\nh_eq : succ^[n] a = succ^[m] a\nh_lt : n < m\nâŠ¢ IsMax (succ^[n] a)"
    },
    {
      "name": "Order.isPredLimit_toDual_iff",
      "statement": "Î± : Type u_1\ninstâœ : LT Î±\na : Î±\nâŠ¢ IsPredLimit (toDual a) â†” IsSuccLimit a"
    },
    {
      "name": "Order.pred_lt_pred_iff",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : Preorder Î±\ninstâœÂ¹ : PredOrder Î±\na b : Î±\ninstâœ : NoMinOrder Î±\nâŠ¢ pred a < pred b â†” a < b"
    },
    {
      "name": "Order.succ_le_succ",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : Preorder Î±\ninstâœ : SuccOrder Î±\na b : Î±\nh : a â‰¤ b\nâŠ¢ succ a â‰¤ succ b"
    },
    {
      "name": "OrderIso.isLUB_preimage'",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : Preorder Î±\ninstâœ : Preorder Î²\nf : Î± â‰ƒo Î²\ns : Set Î²\nx : Î²\nâŠ¢ IsLUB (â‡‘f â»Â¹' s) (f.symm x) â†” IsLUB s x"
    },
    {
      "name": "OrderIso.map_inf",
      "statement": "F : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\nÎ´ : Type u_5\ninstâœÂ¹ : SemilatticeInf Î±\ninstâœ : SemilatticeInf Î²\nf : Î± â‰ƒo Î²\nx y : Î±\nâŠ¢ f (x âŠ“ y) = f x âŠ“ f y"
    },
    {
      "name": "OrderIso.refl_trans",
      "statement": "F : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\nÎ´ : Type u_5\ninstâœÂ² : LE Î±\ninstâœÂ¹ : LE Î²\ninstâœ : LE Î³\ne : Î± â‰ƒo Î²\nâŠ¢ (refl Î±).trans e = e"
    },
    {
      "name": "OrderRingHom.cancel_left",
      "statement": "F : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\nÎ´ : Type u_5\ninstâœâ· : NonAssocSemiring Î±\ninstâœâ¶ : Preorder Î±\ninstâœâµ : NonAssocSemiring Î²\ninstâœâ´ : Preorder Î²\ninstâœÂ³ : NonAssocSemiring Î³\ninstâœÂ² : Preorder Î³\ninstâœÂ¹ : NonAssocSemiring Î´\ninstâœ : Preorder Î´\nf : Î² â†’+*o Î³\ngâ‚ gâ‚‚ : Î± â†’+*o Î²\nhf : Injective â‡‘f\nh : f.comp gâ‚ = f.comp gâ‚‚\na : Î±\nâŠ¢ f (gâ‚ a) = f (gâ‚‚ a)"
    },
    {
      "name": "Ordering.ite_eq_gt_distrib",
      "statement": "c : Prop\ninstâœ : Decidable c\na b : Ordering\nâŠ¢ ((if c then a else b) = gt) = if c then a = gt else b = gt"
    },
    {
      "name": "Ordinal.blsub_eq_zero_iff",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nr : Î± â†’ Î± â†’ Prop\ns : Î² â†’ Î² â†’ Prop\nt : Î³ â†’ Î³ â†’ Prop\no : Ordinal.{u_4}\nf : (a : Ordinal.{u_4}) â†’ a < o â†’ Ordinal.{max u_5 u_4}\nâŠ¢ o.blsub f = 0 â†” o = 0"
    },
    {
      "name": "Ordinal.bsup_eq_zero_iff",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nr : Î± â†’ Î± â†’ Prop\ns : Î² â†’ Î² â†’ Prop\nt : Î³ â†’ Î³ â†’ Prop\no : Ordinal.{u_4}\nf : (a : Ordinal.{u_4}) â†’ a < o â†’ Ordinal.{max u_5 u_4}\nâŠ¢ o.bsup f = 0 â†” âˆ€ (i : Ordinal.{u_4}) (hi : i < o), f i hi = 0"
    },
    {
      "name": "Ordinal.cof_cof",
      "statement": "Î± : Type u_1\nr : Î± â†’ Î± â†’ Prop\na : Ordinal.{u}\nâŠ¢ a.cof.ord.cof = a.cof"
    },
    {
      "name": "Ordinal.cof_zero",
      "statement": "Î± : Type u_1\nr : Î± â†’ Î± â†’ Prop\nâŠ¢ cof 0 = 0"
    },
    {
      "name": "Ordinal.lift_pred",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nr : Î± â†’ Î± â†’ Prop\ns : Î² â†’ Î² â†’ Prop\nt : Î³ â†’ Î³ â†’ Prop\no : Ordinal.{v}\nh : âˆƒ a, o = succ a\nâŠ¢ lift.{u, v} o.pred = (lift.{u, v} o).pred"
    },
    {
      "name": "Ordinal.nadd_le_nadd_right",
      "statement": "aâœ b c : Ordinal.{u}\nh : b â‰¤ c\na : Ordinal.{u}\nâŠ¢ b â™¯ a â‰¤ c â™¯ a"
    },
    {
      "name": "Ordinal.nadd_nat",
      "statement": "a b c : Ordinal.{u}\nn : â„•\nâŠ¢ a â™¯ â†‘n = a + â†‘n"
    },
    {
      "name": "Ordinal.nmul_one",
      "statement": "aâœ b c d : Ordinal.{u}\na : Ordinal.{u_1}\nâŠ¢ a â¨³ 1 = a"
    },
    {
      "name": "Ordinal.nmul_zero",
      "statement": "aâœ b c d : Ordinal.{u}\na : Ordinal.{u_1}\nâŠ¢ a â¨³ 0 = 0"
    },
    {
      "name": "Ordinal.range_familyOfBFamily'",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nrâœ : Î± â†’ Î± â†’ Prop\ns : Î² â†’ Î² â†’ Prop\nt : Î³ â†’ Î³ â†’ Prop\nÎ¹ : Type u\nr : Î¹ â†’ Î¹ â†’ Prop\ninstâœ : IsWellOrder Î¹ r\no : Ordinal.{u}\nho : type r = o\nf : (a : Ordinal.{u}) â†’ a < o â†’ Î±\nâŠ¢ range (familyOfBFamily' r ho f) = o.brange f"
    },
    {
      "name": "Ordinal.toPGame_lt_iff",
      "statement": "a b : Ordinal.{u_1}\nâŠ¢ a.toPGame < b.toPGame â†’ a < b"
    },
    {
      "name": "Ordnode.Valid'.rotateL_lemmaâ‚„",
      "statement": "Î± : Type u_1\ninstâœ : Preorder Î±\na b : â„•\nH3 : 2 * b â‰¤ 9 * a + 3\nâŠ¢ 3 * b â‰¤ 16 * a + 9"
    },
    {
      "name": "Ordnode.size_dual",
      "statement": "Î± : Type u_1\nt : Ordnode Î±\nâŠ¢ t.dual.size = t.size"
    },
    {
      "name": "OreLocalization.add_assoc",
      "statement": "R : Type u_1\ninstâœÂ³ : Monoid R\nS : Submonoid R\ninstâœÂ² : OreSet S\nX : Type u_2\ninstâœÂ¹ : AddMonoid X\ninstâœ : DistribMulAction R X\nx y z : OreLocalization S X\nâŠ¢ x + y + z = x + (y + z)"
    },
    {
      "name": "OreLocalization.mul_div_one",
      "statement": "R : Type u_1\ninstâœÂ² : Monoid R\nS : Submonoid R\ninstâœÂ¹ : OreSet S\nX : Type ?u.113376\ninstâœ : MulAction R X\np r : R\ns : â†¥S\nâŠ¢ p /â‚’ s * (r /â‚’ 1) = p * r /â‚’ s"
    },
    {
      "name": "OreLocalization.mul_inv",
      "statement": "R : Type u_1\ninstâœÂ² : Monoid R\nS : Submonoid R\ninstâœÂ¹ : OreSet S\nX : Type ?u.96987\ninstâœ : MulAction R X\ns s' : â†¥S\nâŠ¢ â†‘s /â‚’ s' * (â†‘s' /â‚’ s) = 1"
    },
    {
      "name": "OreLocalization.smul_cancel",
      "statement": "R : Type u_1\ninstâœÂ² : Monoid R\nS : Submonoid R\ninstâœÂ¹ : OreSet S\nX : Type u_2\ninstâœ : MulAction R X\nr : X\ns t : â†¥S\nâŠ¢ (â†‘s /â‚’ t) â€¢ (r /â‚’ s) = r /â‚’ t"
    },
    {
      "name": "Orientation.det_rotation",
      "statement": "V : Type u_1\nV' : Type u_2\ninstâœâµ : NormedAddCommGroup V\ninstâœâ´ : NormedAddCommGroup V'\ninstâœÂ³ : InnerProductSpace â„ V\ninstâœÂ² : InnerProductSpace â„ V'\ninstâœÂ¹ : Fact (finrank â„ V = 2)\ninstâœ : Fact (finrank â„ V' = 2)\no : Orientation â„ V (Fin 2)\nÎ¸ : Real.Angle\nâŠ¢ LinearMap.det â†‘(o.rotation Î¸).toLinearEquiv = 1"
    },
    {
      "name": "Orientation.inner_smul_rotation_pi_div_two_smul_right",
      "statement": "V : Type u_1\nV' : Type u_2\ninstâœâµ : NormedAddCommGroup V\ninstâœâ´ : NormedAddCommGroup V'\ninstâœÂ³ : InnerProductSpace â„ V\ninstâœÂ² : InnerProductSpace â„ V'\ninstâœÂ¹ : Fact (finrank â„ V = 2)\ninstâœ : Fact (finrank â„ V' = 2)\no : Orientation â„ V (Fin 2)\nx : V\nrâ‚ râ‚‚ : â„\nâŠ¢ âŸªrâ‚‚ â€¢ x, râ‚ â€¢ (o.rotation â†‘(Ï€ / 2)) xâŸ«_â„ = 0"
    },
    {
      "name": "Orientation.kahler_rightAngleRotation_left",
      "statement": "E : Type u_1\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace â„ E\ninstâœ : Fact (finrank â„ E = 2)\no : Orientation â„ E (Fin 2)\nx y : E\nâŠ¢ (o.kahler (o.rightAngleRotation x)) y = -Complex.I * (o.kahler x) y"
    },
    {
      "name": "Orientation.oangle_add",
      "statement": "V : Type u_1\nV' : Type u_2\ninstâœâµ : NormedAddCommGroup V\ninstâœâ´ : NormedAddCommGroup V'\ninstâœÂ³ : InnerProductSpace â„ V\ninstâœÂ² : InnerProductSpace â„ V'\ninstâœÂ¹ : Fact (finrank â„ V = 2)\ninstâœ : Fact (finrank â„ V' = 2)\no : Orientation â„ V (Fin 2)\nx y z : V\nhx : x â‰  0\nhy : y â‰  0\nhz : z â‰  0\nâŠ¢ o.oangle x y + o.oangle y z = o.oangle x z"
    },
    {
      "name": "Orientation.oangle_sign_smul_sub_right",
      "statement": "V : Type u_1\nV' : Type u_2\ninstâœâµ : NormedAddCommGroup V\ninstâœâ´ : NormedAddCommGroup V'\ninstâœÂ³ : InnerProductSpace â„ V\ninstâœÂ² : InnerProductSpace â„ V'\ninstâœÂ¹ : Fact (finrank â„ V = 2)\ninstâœ : Fact (finrank â„ V' = 2)\no : Orientation â„ V (Fin 2)\nx y : V\nr : â„\nâŠ¢ (o.oangle x (r â€¢ x - y)).sign = -(o.oangle x y).sign"
    },
    {
      "name": "Orientation.oangle_smul_left_self_of_nonneg",
      "statement": "V : Type u_1\nV' : Type u_2\ninstâœâµ : NormedAddCommGroup V\ninstâœâ´ : NormedAddCommGroup V'\ninstâœÂ³ : InnerProductSpace â„ V\ninstâœÂ² : InnerProductSpace â„ V'\ninstâœÂ¹ : Fact (finrank â„ V = 2)\ninstâœ : Fact (finrank â„ V' = 2)\no : Orientation â„ V (Fin 2)\nx : V\nr : â„\nhr : 0 â‰¤ r\nâŠ¢ o.oangle (r â€¢ x) x = 0"
    },
    {
      "name": "Orientation.oangle_zero_right",
      "statement": "V : Type u_1\nV' : Type u_2\ninstâœâµ : NormedAddCommGroup V\ninstâœâ´ : NormedAddCommGroup V'\ninstâœÂ³ : InnerProductSpace â„ V\ninstâœÂ² : InnerProductSpace â„ V'\ninstâœÂ¹ : Fact (finrank â„ V = 2)\ninstâœ : Fact (finrank â„ V' = 2)\no : Orientation â„ V (Fin 2)\nx : V\nâŠ¢ o.oangle x 0 = 0"
    },
    {
      "name": "Orientation.rightAngleRotationAuxâ‚_rightAngleRotationAuxâ‚",
      "statement": "E : Type u_1\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace â„ E\ninstâœ : Fact (finrank â„ E = 2)\no : Orientation â„ E (Fin 2)\nx : E\nâŠ¢ o.rightAngleRotationAuxâ‚ (o.rightAngleRotationAuxâ‚ x) = -x"
    },
    {
      "name": "Orientation.rightAngleRotation_neg_orientation",
      "statement": "E : Type u_1\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace â„ E\ninstâœ : Fact (finrank â„ E = 2)\no : Orientation â„ E (Fin 2)\nx : E\nâŠ¢ (-o).rightAngleRotation x = -o.rightAngleRotation x"
    },
    {
      "name": "Orientation.volumeForm_neg_orientation",
      "statement": "E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace â„ E\nn : â„•\n_i : Fact (finrank â„ E = n)\no : Orientation â„ E (Fin n)\nâŠ¢ (-o).volumeForm = -o.volumeForm"
    },
    {
      "name": "OrthogonalFamily.sum_projection_of_mem_iSup",
      "statement": "case mem\nğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ¶ : _root_.RCLike ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : InnerProductSpace ğ•œ E\ninstâœÂ² : InnerProductSpace â„ F\nK : Submodule ğ•œ E\nÎ¹ : Type u_4\ninstâœÂ¹ : Fintype Î¹\nV : Î¹ â†’ Submodule ğ•œ E\ninstâœ : âˆ€ (i : Î¹), CompleteSpace â†¥(V i)\nhV : OrthogonalFamily ğ•œ (fun i => â†¥(V i)) fun i => (V i).subtypeâ‚—áµ¢\nxâœ : E\ni : Î¹\nx : E\nhx : x âˆˆ V i\nâŠ¢ âˆ‘ i : Î¹, â†‘((orthogonalProjection (V i)) x) = x"
    },
    {
      "name": "OrthonormalBasis.coe_ofRepr",
      "statement": "Î¹ : Type u_1\nÎ¹' : Type u_2\nğ•œ : Type u_3\ninstâœÂ¹â° : _root_.RCLike ğ•œ\nE : Type u_4\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : InnerProductSpace ğ•œ E\nE' : Type u_5\ninstâœâ· : NormedAddCommGroup E'\ninstâœâ¶ : InnerProductSpace ğ•œ E'\nF : Type u_6\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : InnerProductSpace â„ F\nF' : Type u_7\ninstâœÂ³ : NormedAddCommGroup F'\ninstâœÂ² : InnerProductSpace â„ F'\ninstâœÂ¹ : Fintype Î¹\ninstâœ : DecidableEq Î¹\ne : E â‰ƒâ‚—áµ¢[ğ•œ] EuclideanSpace ğ•œ Î¹\nâŠ¢ â‡‘{ repr := e } = fun i => e.symm (EuclideanSpace.single i 1)"
    },
    {
      "name": "OrthonormalBasis.coe_toBasis",
      "statement": "Î¹ : Type u_1\nÎ¹' : Type u_2\nğ•œ : Type u_3\ninstâœâ¹ : _root_.RCLike ğ•œ\nE : Type u_4\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : InnerProductSpace ğ•œ E\nE' : Type u_5\ninstâœâ¶ : NormedAddCommGroup E'\ninstâœâµ : InnerProductSpace ğ•œ E'\nF : Type u_6\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : InnerProductSpace â„ F\nF' : Type u_7\ninstâœÂ² : NormedAddCommGroup F'\ninstâœÂ¹ : InnerProductSpace â„ F'\ninstâœ : Fintype Î¹\nb : OrthonormalBasis Î¹ ğ•œ E\nâŠ¢ â‡‘b.toBasis = â‡‘b"
    },
    {
      "name": "OrthonormalBasis.det_to_matrix_orthonormalBasis",
      "statement": "Î¹ : Type u_1\nÎ¹' : Type u_2\nğ•œ : Type u_3\ninstâœÂ¹â° : _root_.RCLike ğ•œ\nE : Type u_4\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : InnerProductSpace ğ•œ E\nE' : Type u_5\ninstâœâ· : NormedAddCommGroup E'\ninstâœâ¶ : InnerProductSpace ğ•œ E'\nF : Type u_6\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : InnerProductSpace â„ F\nF' : Type u_7\ninstâœÂ³ : NormedAddCommGroup F'\ninstâœÂ² : InnerProductSpace â„ F'\ninstâœÂ¹ : Fintype Î¹\ninstâœ : DecidableEq Î¹\na b : OrthonormalBasis Î¹ ğ•œ E\nâŠ¢ â€–a.toBasis.det â‡‘bâ€– = 1"
    },
    {
      "name": "PEquiv.mem_ofSet_iff",
      "statement": "Î± : Type u\nÎ² : Type v\nÎ³ : Type w\nÎ´ : Type x\nsâœ : Set Î±\ninstâœÂ¹ : DecidablePred fun x => x âˆˆ sâœ\ns : Set Î±\ninstâœ : DecidablePred fun x => x âˆˆ s\na b : Î±\nâŠ¢ a âˆˆ (ofSet s) b â†” a = b âˆ§ a âˆˆ s"
    },
    {
      "name": "PEquiv.single_subsingleton_eq_refl",
      "statement": "Î± : Type u\nÎ² : Type v\nÎ³ : Type w\nÎ´ : Type x\ninstâœÂ³ : DecidableEq Î±\ninstâœÂ² : DecidableEq Î²\ninstâœÂ¹ : DecidableEq Î³\ninstâœ : Subsingleton Î±\na b : Î±\nâŠ¢ single a b = PEquiv.refl Î±"
    },
    {
      "name": "PEquiv.trans_refl",
      "statement": "Î± : Type u\nÎ² : Type v\nÎ³ : Type w\nÎ´ : Type x\nf : Î± â‰ƒ. Î²\nâŠ¢ f.trans (PEquiv.refl Î²) = f"
    },
    {
      "name": "PFun.Part.bind_comp",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\nÎµ : Type u_5\nÎ¹ : Type u_6\nfâœ : Î± â†’. Î²\nf : Î² â†’. Î³\ng : Î± â†’. Î²\na : Part Î±\nâŠ¢ a.bind (f.comp g) = (a.bind g).bind f"
    },
    {
      "name": "PFunctor.M.agree'_refl",
      "statement": "F : PFunctor.{u}\nX : Type u_1\nf : X â†’ â†‘F X\nn : â„•\nx : F.M\nâŠ¢ Agree' n x x"
    },
    {
      "name": "PFunctor.M.ichildren_mk",
      "statement": "F : PFunctor.{u}\nX : Type u_1\nf : X â†’ â†‘F X\ninstâœÂ¹ : DecidableEq F.A\ninstâœ : Inhabited F.M\nx : â†‘F F.M\ni : F.Idx\nâŠ¢ ichildren i (M.mk x) = x.iget i"
    },
    {
      "name": "PFunctor.M.mk_dest",
      "statement": "F : PFunctor.{u}\nX : Type u_1\nf : X â†’ â†‘F X\nx : F.M\nâŠ¢ M.mk x.dest = x"
    },
    {
      "name": "PFunctor.iget_map",
      "statement": "P : PFunctor.{u}\nÎ± : Type vâ‚\nÎ² : Type vâ‚‚\nÎ³ : Type vâ‚ƒ\ninstâœÂ² : DecidableEq P.A\ninstâœÂ¹ : Inhabited Î±\ninstâœ : Inhabited Î²\nx : â†‘P Î±\nf : Î± â†’ Î²\ni : P.Idx\nh : i.fst = x.fst\nâŠ¢ (P.map f x).iget i = f (x.iget i)"
    },
    {
      "name": "PMF.bindOnSupport_eq_bind",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\npâœ : PMF Î±\nfâœ : (a : Î±) â†’ a âˆˆ pâœ.support â†’ PMF Î²\np : PMF Î±\nf : Î± â†’ PMF Î²\nâŠ¢ (p.bindOnSupport fun a x => f a) = p.bind f"
    },
    {
      "name": "PMF.binomial_apply_self",
      "statement": "p : â„â‰¥0âˆ\nh : p â‰¤ 1\nn : â„•\nâŠ¢ (binomial p h n) â†‘n = p ^ n"
    },
    {
      "name": "PMF.map_apply",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nf : Î± â†’ Î²\np : PMF Î±\nb : Î²\nâŠ¢ (map f p) b = âˆ‘' (a : Î±), if b = f a then p a else 0"
    },
    {
      "name": "PMF.pure_bind",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\np : PMF Î±\nfâœ : Î± â†’ PMF Î²\ng : Î² â†’ PMF Î³\na : Î±\nf : Î± â†’ PMF Î²\nâŠ¢ (pure a).bind f = f a"
    },
    {
      "name": "PMF.pure_bindOnSupport",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\np : PMF Î±\nfâœ : (a : Î±) â†’ a âˆˆ p.support â†’ PMF Î²\na : Î±\nf : (a' : Î±) â†’ a' âˆˆ (pure a).support â†’ PMF Î²\nâŠ¢ (pure a).bindOnSupport f = f a â‹¯"
    },
    {
      "name": "PMF.restrict_toMeasure_support",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ¹ : MeasurableSpace Î±\npâœ : PMF Î±\ns t : Set Î±\ninstâœ : MeasurableSingletonClass Î±\np : PMF Î±\nâŠ¢ p.toMeasure.restrict p.support = p.toMeasure"
    },
    {
      "name": "PMF.support_bernoulli",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\np : â„â‰¥0âˆ\nh : p â‰¤ 1\nb : Bool\nâŠ¢ (bernoulli p h).support = {b | bif b then p â‰  0 else p â‰  1}"
    },
    {
      "name": "PMF.support_uniformOfFintype",
      "statement": "Î±âœ : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ³ : Fintype Î±âœ\ninstâœÂ² : Nonempty Î±âœ\nÎ± : Type u_4\ninstâœÂ¹ : Fintype Î±\ninstâœ : Nonempty Î±\nx : Î±\nâŠ¢ x âˆˆ (uniformOfFintype Î±).support â†” x âˆˆ âŠ¤"
    },
    {
      "name": "PMF.toOuterMeasure_bind_apply",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\np : PMF Î±\nf : Î± â†’ PMF Î²\ng : Î² â†’ PMF Î³\ns : Set Î²\nâŠ¢ (p.bind f).toOuterMeasure s = âˆ‘' (b : Î²), if b âˆˆ s then âˆ‘' (a : Î±), p a * (f a) b else 0"
    },
    {
      "name": "PMF.toOuterMeasure_ofMultiset_apply",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ns : Multiset Î±\nhs : s â‰  0\nt : Set Î±\nâŠ¢ (ofMultiset s hs).toOuterMeasure t =\n    (âˆ‘' (x : Î±), â†‘(Multiset.count x (Multiset.filter (fun x => x âˆˆ t) s))) / â†‘(Multiset.card s)"
    },
    {
      "name": "PMF.uniformOfFinset_apply_of_not_mem",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ns : Finset Î±\nhs : s.Nonempty\na : Î±\nha : a âˆ‰ s\nâŠ¢ (uniformOfFinset s hs) a = 0"
    },
    {
      "name": "PNat.card_fintype_Ioo",
      "statement": "a b : â„•+\nâŠ¢ Fintype.card â†‘(Set.Ioo a b) = â†‘b - â†‘a - 1"
    },
    {
      "name": "PNat.coprime_coe",
      "statement": "m n : â„•+\nâŠ¢ (â†‘m).Coprime â†‘n â†” m.Coprime n"
    },
    {
      "name": "PNat.factorMultiset_le_iff",
      "statement": "m n : â„•+\nâŠ¢ m.factorMultiset â‰¤ n.factorMultiset â†” m âˆ£ n"
    },
    {
      "name": "PNat.mul_div_exact",
      "statement": "m k : â„•+\nh : k âˆ£ m\nâŠ¢ k * m.divExact k = m"
    },
    {
      "name": "PNat.recOn_succ",
      "statement": "n : â„•+\np : â„•+ â†’ Sort u_1\np1 : p 1\nhp : (n : â„•+) â†’ p n â†’ p (n + 1)\nâŠ¢ (n + 1).recOn p1 hp = hp n (n.recOn p1 hp)"
    },
    {
      "name": "PSet.mem_sUnion",
      "statement": "Î± : Type u\nA : Î± â†’ PSet\ny : PSet\nxâœ : y âˆˆ â‹ƒâ‚€ mk Î± A\na : (mk Î± A).Type\nc : ((mk Î± A).Func a).Type\ne : y.Equiv ((A a).Func c)\nthis : (A a).Func c âˆˆ mk (A a).Type (A a).Func\nâŠ¢ (A a).Func c âˆˆ A (?m.17636 Î± A y xâœ a c e this)"
    },
    {
      "name": "PSet.not_nonempty_empty",
      "statement": "âŠ¢ Â¬âˆ….Nonempty"
    },
    {
      "name": "Padic.valuation_one",
      "statement": "p : â„•\nhp : Fact (Nat.Prime p)\nâŠ¢ valuation 1 = 0"
    },
    {
      "name": "PadicInt.lift_self",
      "statement": "p : â„•\nhp_prime : Fact (Nat.Prime p)\nR : Type u_1\ninstâœ : NonAssocSemiring R\nf : (k : â„•) â†’ R â†’+* ZMod (p ^ k)\nf_compat : âˆ€ (k1 k2 : â„•) (hk : k1 â‰¤ k2), (ZMod.castHom â‹¯ (ZMod (p ^ k1))).comp (f k2) = f k1\nz : â„¤_[p]\nâŠ¢ (lift â‹¯) z = z"
    },
    {
      "name": "Part.inter_get_eq",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœ : Inter Î±\na b : Part Î±\nhab : (a âˆ© b).Dom\nâŠ¢ (a âˆ© b).get hab = a.get â‹¯ âˆ© b.get â‹¯"
    },
    {
      "name": "Part.mem_restrict",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\np : Prop\no : Part Î±\nh : p â†’ o.Dom\na : Î±\nâŠ¢ a âˆˆ restrict p o h â†” p âˆ§ a âˆˆ o"
    },
    {
      "name": "Part.ofOption_dom",
      "statement": "Î±âœ : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ± : Type u_4\nâŠ¢ (â†‘Option.none).Dom â†” Option.none.isSome = true"
    },
    {
      "name": "Part.some_ne_none",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nx : Î±\nâŠ¢ some x â‰  none"
    },
    {
      "name": "PartENat.get_le_get",
      "statement": "x y : PartENat\nhx : x.Dom\nhy : y.Dom\nâŠ¢ x.get hx â‰¤ y.get hy â†” x â‰¤ y"
    },
    {
      "name": "PartENat.ofENat_lt",
      "statement": "x y : â„•âˆ\nâŠ¢ â†‘x < â†‘y â†” x < y"
    },
    {
      "name": "PartENat.toWithTop_top'",
      "statement": "h : Decidable âŠ¤.Dom\nâŠ¢ âŠ¤.toWithTop = âŠ¤"
    },
    {
      "name": "Partrecâ‚‚.unpaired",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\nÏƒ : Type u_5\ninstâœâ´ : Primcodable Î±\ninstâœÂ³ : Primcodable Î²\ninstâœÂ² : Primcodable Î³\ninstâœÂ¹ : Primcodable Î´\ninstâœ : Primcodable Ïƒ\nf : â„• â†’ â„• â†’. Î±\nh : Partrec (Nat.unpaired f)\nâŠ¢ Partrecâ‚‚ f"
    },
    {
      "name": "Path.Homotopic.pi_proj",
      "statement": "Î¹ : Type u_1\nX : Î¹ â†’ Type u_2\ninstâœ : (i : Î¹) â†’ TopologicalSpace (X i)\nas bs cs : (i : Î¹) â†’ X i\np : Homotopic.Quotient as bs\nâŠ¢ (pi fun i => proj i p) = p"
    },
    {
      "name": "Path.Homotopic.prod_projLeft_projRight",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalSpace Î²\naâ‚ aâ‚‚ aâ‚ƒ : Î±\nbâ‚ bâ‚‚ bâ‚ƒ : Î²\npâ‚ pâ‚' : Path aâ‚ aâ‚‚\npâ‚‚ pâ‚‚' : Path bâ‚ bâ‚‚\nqâ‚ : Homotopic.Quotient aâ‚ aâ‚‚\nqâ‚‚ : Homotopic.Quotient bâ‚ bâ‚‚\nrâ‚ : Homotopic.Quotient aâ‚‚ aâ‚ƒ\nrâ‚‚ : Homotopic.Quotient bâ‚‚ bâ‚ƒ\ncâ‚ câ‚‚ : Î± Ã— Î²\np : Homotopic.Quotient (aâ‚, bâ‚) (aâ‚‚, bâ‚‚)\nâŠ¢ prod (projLeft p) (projRight p) = p"
    },
    {
      "name": "Path.Homotopic.proj_pi",
      "statement": "Î¹ : Type u_1\nX : Î¹ â†’ Type u_2\ninstâœ : (i : Î¹) â†’ TopologicalSpace (X i)\nas bs cs : (i : Î¹) â†’ X i\ni : Î¹\npaths : (i : Î¹) â†’ Homotopic.Quotient (as i) (bs i)\nâŠ¢ proj i (pi paths) = paths i"
    },
    {
      "name": "Path.map_trans",
      "statement": "X : Type u_1\nY : Type u_2\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nx y z : X\nÎ¹ : Type u_3\nÎ³âœ Î³ : Path x y\nÎ³' : Path y z\nf : X â†’ Y\nh : Continuous f\nâŠ¢ (Î³.trans Î³').map h = (Î³.map h).trans (Î³'.map h)"
    },
    {
      "name": "Path.truncate_self",
      "statement": "X : Type u_1\nY : Type u_2\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nx y z : X\nÎ¹ : Type u_3\nÎ³âœ : Path x y\na b : X\nÎ³ : Path a b\nt : â„\nâŠ¢ Î³.extend (min t t) = Î³.extend t"
    },
    {
      "name": "Pell.pell_eq",
      "statement": "a : â„•\na1 : 1 < a\nn : â„•\npn : xz a1 n * xz a1 n - â†‘(Pell.d a1) * yz a1 n * yz a1 n = 1 := pell_eqz a1 n\nâŠ¢ â†‘(xn a1 n * xn a1 n) - â†‘(Pell.d a1 * yn a1 n * yn a1 n) = 1"
    },
    {
      "name": "PerfectClosure.mk_pow",
      "statement": "K : Type u\ninstâœÂ² : CommRing K\np : â„•\ninstâœÂ¹ : Fact (Nat.Prime p)\ninstâœ : CharP K p\nx : â„• Ã— K\nn : â„•\nâŠ¢ mk K p x ^ n = mk K p (x.1, x.2 ^ n)"
    },
    {
      "name": "PerfectRing.lift_comp_apply",
      "statement": "K : Type u_1\nL : Type u_2\nM : Type u_3\nN : Type u_4\ninstâœâ¹ : CommRing K\ninstâœâ¸ : CommRing L\ninstâœâ· : CommRing M\ninstâœâ¶ : CommRing N\ni : K â†’+* L\nj : K â†’+* M\nk : K â†’+* N\nf : L â†’+* M\ng : L â†’+* N\np : â„•\ninstâœâµ : ExpChar K p\ninstâœâ´ : ExpChar L p\ninstâœÂ³ : ExpChar M p\ninstâœÂ² : ExpChar N p\ninstâœÂ¹ : PerfectRing M p\ninstâœ : IsPRadical i p\nx : K\nâŠ¢ (lift i j p) (i x) = j x"
    },
    {
      "name": "Pi.basisFun_repr",
      "statement": "R : Type u_1\nÎ· : Type u_2\nÎ¹s : Î· â†’ Type u_3\nMs : Î· â†’ Type u_4\ninstâœÂ³ : Semiring R\ninstâœÂ² : (i : Î·) â†’ AddCommMonoid (Ms i)\ninstâœÂ¹ : (i : Î·) â†’ Module R (Ms i)\ninstâœ : Finite Î·\nx : Î· â†’ R\ni : Î·\nâŠ¢ ((basisFun R Î·).repr x) i = x i"
    },
    {
      "name": "PiLp.edist_comm",
      "statement": "p : â„â‰¥0âˆ\nğ•œ : Type u_1\nÎ¹ : Type u_2\nÎ± : Î¹ â†’ Type u_3\nÎ² : Î¹ â†’ Type u_4\ninstâœÂ¹ : Fintype Î¹\ninstâœ : (i : Î¹) â†’ PseudoEMetricSpace (Î² i)\nf g : PiLp p Î²\nâŠ¢ edist f g = edist g f"
    },
    {
      "name": "PiTensorProduct.liftIsometry_symm_apply",
      "statement": "Î¹ : Type uÎ¹\ninstâœâµ : Fintype Î¹\nğ•œ : Type uğ•œ\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Î¹ â†’ Type uE\ninstâœÂ³ : (i : Î¹) â†’ SeminormedAddCommGroup (E i)\ninstâœÂ² : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\nF : Type uF\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nl : (â¨‚[ğ•œ] (i : Î¹), E i) â†’L[ğ•œ] F\nâŠ¢ (liftIsometry ğ•œ E F).symm l = l.compContinuousMultilinearMap (tprodL ğ•œ)"
    },
    {
      "name": "PiTensorProduct.map_range_eq_span_tprod",
      "statement": "Î¹ : Type u_1\nÎ¹â‚‚ : Type u_2\nÎ¹â‚ƒ : Type u_3\nR : Type u_4\ninstâœÂ¹Â¹ : CommSemiring R\nRâ‚ : Type u_5\nRâ‚‚ : Type u_6\ns : Î¹ â†’ Type u_7\ninstâœÂ¹â° : (i : Î¹) â†’ AddCommMonoid (s i)\ninstâœâ¹ : (i : Î¹) â†’ Module R (s i)\nM : Type u_8\ninstâœâ¸ : AddCommMonoid M\ninstâœâ· : Module R M\nE : Type u_9\ninstâœâ¶ : AddCommMonoid E\ninstâœâµ : Module R E\nF : Type u_10\ninstâœâ´ : AddCommMonoid F\nt : Î¹ â†’ Type u_11\nt' : Î¹ â†’ Type u_12\ninstâœÂ³ : (i : Î¹) â†’ AddCommMonoid (t i)\ninstâœÂ² : (i : Î¹) â†’ Module R (t i)\ninstâœÂ¹ : (i : Î¹) â†’ AddCommMonoid (t' i)\ninstâœ : (i : Î¹) â†’ Module R (t' i)\ng : (i : Î¹) â†’ t i â†’â‚—[R] t' i\nf : (i : Î¹) â†’ s i â†’â‚—[R] t i\nâŠ¢ LinearMap.range (map f) = Submodule.span R {t_1 | âˆƒ m, (â¨‚â‚œ[R] (i : Î¹), (f i) (m i)) = t_1}"
    },
    {
      "name": "PiTensorProduct.piTensorHomMapFunâ‚‚_smul",
      "statement": "Î¹ : Type u_1\nÎ¹â‚‚ : Type u_2\nÎ¹â‚ƒ : Type u_3\nR : Type u_4\ninstâœÂ¹Â¹ : CommSemiring R\nRâ‚ : Type u_5\nRâ‚‚ : Type u_6\ns : Î¹ â†’ Type u_7\ninstâœÂ¹â° : (i : Î¹) â†’ AddCommMonoid (s i)\ninstâœâ¹ : (i : Î¹) â†’ Module R (s i)\nM : Type u_8\ninstâœâ¸ : AddCommMonoid M\ninstâœâ· : Module R M\nE : Type u_9\ninstâœâ¶ : AddCommMonoid E\ninstâœâµ : Module R E\nF : Type u_10\ninstâœâ´ : AddCommMonoid F\nt : Î¹ â†’ Type u_11\nt' : Î¹ â†’ Type u_12\ninstâœÂ³ : (i : Î¹) â†’ AddCommMonoid (t i)\ninstâœÂ² : (i : Î¹) â†’ Module R (t i)\ninstâœÂ¹ : (i : Î¹) â†’ AddCommMonoid (t' i)\ninstâœ : (i : Î¹) â†’ Module R (t' i)\ng : (i : Î¹) â†’ t i â†’â‚—[R] t' i\nf : (i : Î¹) â†’ s i â†’â‚—[R] t i\nr : R\nÏ† : â¨‚[R] (i : Î¹), s i â†’â‚—[R] t i â†’â‚—[R] t' i\nâŠ¢ (r â€¢ Ï†).piTensorHomMapFunâ‚‚ = r â€¢ Ï†.piTensorHomMapFunâ‚‚"
    },
    {
      "name": "PiTensorProduct.reindex_refl",
      "statement": "Î¹ : Type u_1\nÎ¹â‚‚ : Type u_2\nÎ¹â‚ƒ : Type u_3\nR : Type u_4\ninstâœâ· : CommSemiring R\nRâ‚ : Type u_5\nRâ‚‚ : Type u_6\ns : Î¹ â†’ Type u_7\ninstâœâ¶ : (i : Î¹) â†’ AddCommMonoid (s i)\ninstâœâµ : (i : Î¹) â†’ Module R (s i)\nM : Type u_8\ninstâœâ´ : AddCommMonoid M\ninstâœÂ³ : Module R M\nE : Type u_9\ninstâœÂ² : AddCommMonoid E\ninstâœÂ¹ : Module R E\nF : Type u_10\ninstâœ : AddCommMonoid F\nâŠ¢ reindex R s (Equiv.refl Î¹) = LinearEquiv.refl R (â¨‚[R] (i : Î¹), s i)"
    },
    {
      "name": "PiToModule.fromEnd_apply_single_one",
      "statement": "Î¹ : Type u_1\ninstâœâ´ : Fintype Î¹\nM : Type u_2\ninstâœÂ³ : AddCommGroup M\nR : Type u_3\ninstâœÂ² : CommRing R\ninstâœÂ¹ : Module R M\nI : Ideal R\nb : Î¹ â†’ M\nhb : Submodule.span R (Set.range b) = âŠ¤\ninstâœ : DecidableEq Î¹\nf : Module.End R M\ni : Î¹\nâŠ¢ ((fromEnd R b) f) (Pi.single i 1) = f (b i)"
    },
    {
      "name": "Polynomial.Chebyshev.T_eq_X_mul_T_sub_pol_U",
      "statement": "R : Type u_1\nS : Type u_2\ninstâœÂ¹ : CommRing R\ninstâœ : CommRing S\nn : â„¤\nâŠ¢ T R (n + 2) = X * T R (n + 1) - (1 - X ^ 2) * U R n"
    },
    {
      "name": "Polynomial.Chebyshev.T_neg_one",
      "statement": "R : Type u_1\nS : Type u_2\ninstâœÂ¹ : CommRing R\ninstâœ : CommRing S\nâŠ¢ 2 * X * 1 - X = X"
    },
    {
      "name": "Polynomial.Chebyshev.U_neg_two",
      "statement": "R : Type u_1\nS : Type u_2\ninstâœÂ¹ : CommRing R\ninstâœ : CommRing S\nâŠ¢ U R (-2) = -1"
    },
    {
      "name": "Polynomial.Chebyshev.map_T",
      "statement": "R : Type u_1\nS : Type u_2\ninstâœÂ¹ : CommRing R\ninstâœ : CommRing S\nf : R â†’+* S\nn : â„¤\nâŠ¢ map f (T R n) = T S n"
    },
    {
      "name": "Polynomial.Chebyshev.map_U",
      "statement": "R : Type u_1\nS : Type u_2\ninstâœÂ¹ : CommRing R\ninstâœ : CommRing S\nf : R â†’+* S\nn : â„¤\nâŠ¢ map f (U R n) = U S n"
    },
    {
      "name": "Polynomial.Monic.degree_mul_comm",
      "statement": "R : Type u\nS : Type v\na b : R\nm n : â„•\nÎ¹ : Type y\ninstâœ : Semiring R\np qâœ r : R[X]\nhp : p.Monic\nq : R[X]\nâŠ¢ (p * q).degree = (q * p).degree"
    },
    {
      "name": "Polynomial.Monic.map",
      "statement": "R : Type u\nS : Type v\na b : R\nm n : â„•\nÎ¹ : Type y\ninstâœÂ¹ : Semiring R\np q r : R[X]\ninstâœ : Semiring S\nf : R â†’+* S\nhp : p.Monic\nâŠ¢ (Polynomial.map f p).Monic"
    },
    {
      "name": "Polynomial.X_mul_divX_add",
      "statement": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : â„•\ninstâœ : Semiring R\npâœ q p : R[X]\nâŠ¢ âˆ€ (n : â„•), (X * p.divX + C (p.coeff 0)).coeff n = p.coeff n"
    },
    {
      "name": "Polynomial.X_ne_zero",
      "statement": "R : Type u\na b : R\nm n : â„•\ninstâœÂ¹ : Semiring R\ninstâœ : Nontrivial R\nâŠ¢ Â¬X.coeff 1 = coeff 0 1"
    },
    {
      "name": "Polynomial.annIdealGenerator_eq_zero_iff",
      "statement": "ğ•œ : Type u_1\nA : Type u_2\ninstâœÂ² : Field ğ•œ\ninstâœÂ¹ : Ring A\ninstâœ : Algebra ğ•œ A\na : A\nâŠ¢ annIdealGenerator ğ•œ a = 0 â†” annIdeal ğ•œ a = âŠ¥"
    },
    {
      "name": "Polynomial.aroots_C",
      "statement": "R : Type u\nS : Type v\nT : Type w\naâœ b : R\nn : â„•\ninstâœâµ : CommRing R\ninstâœâ´ : IsDomain R\np q : R[X]\ninstâœÂ³ : CommRing T\ninstâœÂ² : CommRing S\ninstâœÂ¹ : IsDomain S\ninstâœ : Algebra T S\na : T\nâŠ¢ (C a).aroots S = 0"
    },
    {
      "name": "Polynomial.aroots_neg",
      "statement": "R : Type u\nS : Type v\nT : Type w\na b : R\nn : â„•\ninstâœâµ : CommRing R\ninstâœâ´ : IsDomain R\npâœ q : R[X]\ninstâœÂ³ : CommRing T\ninstâœÂ² : CommRing S\ninstâœÂ¹ : IsDomain S\ninstâœ : Algebra T S\np : T[X]\nâŠ¢ (-p).aroots S = p.aroots S"
    },
    {
      "name": "Polynomial.coeff_X_mul_zero",
      "statement": "R : Type u\nS : Type v\na b : R\nn m : â„•\ninstâœ : Semiring R\npâœ q r p : R[X]\nâŠ¢ (X * p).coeff 0 = 0"
    },
    {
      "name": "Polynomial.coeff_mul_X_pow",
      "statement": "R : Type u\nS : Type v\na b : R\nnâœ m : â„•\ninstâœ : Semiring R\npâœ q r p : R[X]\nn d : â„•\nâŠ¢ (p * X ^ n).coeff (d + n) = p.coeff d"
    },
    {
      "name": "Polynomial.coeff_natTrailingDegree_eq_zero",
      "statement": "R : Type u\nS : Type v\na b : R\nn m : â„•\ninstâœ : Semiring R\np q r : R[X]\nâŠ¢ p.coeff p.natTrailingDegree = 0 â†” p = 0"
    },
    {
      "name": "Polynomial.coeff_one_zero",
      "statement": "R : Type u\na b : R\nm n : â„•\ninstâœ : Semiring R\np q : R[X]\nâŠ¢ coeff 1 0 = 1"
    },
    {
      "name": "Polynomial.coeff_pow_mul_natDegree",
      "statement": "R : Type u\nS : Type v\na b c d : R\nnâœ m : â„•\ninstâœ : Semiring R\npâœÂ¹ pâœ q : R[X]\nÎ¹ : Type u_1\np : R[X]\nn : â„•\nâŠ¢ (p ^ n).coeff (n * p.natDegree) = p.leadingCoeff ^ n"
    },
    {
      "name": "Polynomial.coeff_restriction",
      "statement": "R : Type u\nS : Type u_1\ninstâœ : Ring R\np : R[X]\nn : â„•\nâŠ¢ â†‘(p.restriction.coeff n) = p.coeff n"
    },
    {
      "name": "Polynomial.coeff_toSubring",
      "statement": "R : Type u\nS : Type u_1\ninstâœÂ¹ : Ring R\ninstâœ : Semiring S\nf : R â†’+* S\nx : S\np : R[X]\nT : Subring R\nhp : â†‘p.coeffs âŠ† â†‘T\nn : â„•\nâŠ¢ â†‘((p.toSubring T hp).coeff n) = p.coeff n"
    },
    {
      "name": "Polynomial.comp_X",
      "statement": "R : Type u\nS : Type v\nT : Type w\nÎ¹ : Type y\na b : R\nm n : â„•\ninstâœ : Semiring R\np q r : R[X]\nâŠ¢ p.comp X = p"
    },
    {
      "name": "Polynomial.content_X_mul",
      "statement": "R : Type u_1\ninstâœÂ² : CommRing R\ninstâœÂ¹ : IsDomain R\ninstâœ : NormalizedGCDMonoid R\np : R[X]\nâŠ¢ (X * p).content = p.content"
    },
    {
      "name": "Polynomial.content_monomial",
      "statement": "R : Type u_1\ninstâœÂ² : CommRing R\ninstâœÂ¹ : IsDomain R\ninstâœ : NormalizedGCDMonoid R\nr : R\nk : â„•\nâŠ¢ ((monomial k) r).content = normalize r"
    },
    {
      "name": "Polynomial.cyclotomic.irreducible",
      "statement": "R : Type u_1\ninstâœ : CommRing R\nnâœ n : â„•\nhpos : 0 < n\nâŠ¢ Irreducible (cyclotomic n â„¤)"
    },
    {
      "name": "Polynomial.cyclotomic_expand_eq_cyclotomic_mul",
      "statement": "p n : â„•\nhp : Nat.Prime p\nhdiv : Â¬p âˆ£ n\nR : Type u_1\ninstâœ : CommRing R\nâŠ¢ (expand R p) (cyclotomic n R) = cyclotomic (n * p) R * cyclotomic n R"
    },
    {
      "name": "Polynomial.cyclotomic_two",
      "statement": "R : Type u_1\ninstâœ : Ring R\nâŠ¢ cyclotomic 2 R = X + 1"
    },
    {
      "name": "Polynomial.degree_C_mul",
      "statement": "R : Type u\nS : Type v\nÎ¹ : Type w\naâœ b : R\nm n : â„•\ninstâœÂ¹ : Semiring R\ninstâœ : NoZeroDivisors R\np q : R[X]\na : R\na0 : a â‰  0\nâŠ¢ (C a * p).degree = p.degree"
    },
    {
      "name": "Polynomial.degree_map_eq_iff",
      "statement": "R : Type u\nS : Type v\nÎ¹ : Type w\na b : R\nm n : â„•\ninstâœÂ¹ : Semiring R\npâœ q r : R[X]\ninstâœ : Semiring S\nf : R â†’+* S\np : R[X]\nâŠ¢ (map f p).degree = p.degree â†” f p.leadingCoeff â‰  0 âˆ¨ p = 0"
    },
    {
      "name": "Polynomial.degree_map_eq_of_leadingCoeff_ne_zero",
      "statement": "R : Type u\nS : Type v\nT : Type w\nÎ¹ : Type y\na b : R\nm n : â„•\ninstâœÂ¹ : Semiring R\np q r : R[X]\ninstâœ : Semiring S\nfâœ f : R â†’+* S\nhf : f p.leadingCoeff â‰  0\nâŠ¢ p.degree â‰¤ (map f p).degree"
    },
    {
      "name": "Polynomial.degree_map_le",
      "statement": "R : Type u\nS : Type v\nT : Type w\nÎ¹ : Type y\na b : R\nm n : â„•\ninstâœÂ¹ : Semiring R\npâœ q r : R[X]\ninstâœ : Semiring S\nf : R â†’+* S\np : R[X]\nâŠ¢ (map f p).degree â‰¤ p.degree"
    },
    {
      "name": "Polynomial.degree_toSubring",
      "statement": "R : Type u\nS : Type u_1\ninstâœÂ¹ : Ring R\ninstâœ : Semiring S\nf : R â†’+* S\nx : S\np : R[X]\nT : Subring R\nhp : â†‘p.coeffs âŠ† â†‘T\nâŠ¢ (p.toSubring T hp).degree = p.degree"
    },
    {
      "name": "Polynomial.divByMonic_zero",
      "statement": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : â„•\ninstâœ : Ring R\npâœ q p : R[X]\nthis : DecidableEq R := Classical.decEq R\nh : Monic 0\nâŠ¢ p /â‚˜ 0 = 0"
    },
    {
      "name": "Polynomial.eval_C_mul",
      "statement": "R : Type u\nS : Type v\nT : Type w\nÎ¹ : Type y\na b : R\nm n : â„•\ninstâœ : Semiring R\np q r : R[X]\nx : R\nâŠ¢ eval x (C a * p) = a * eval x p"
    },
    {
      "name": "Polynomial.eval_comp",
      "statement": "R : Type u\nS : Type v\nT : Type w\nÎ¹ : Type y\na b : R\nm n : â„•\ninstâœÂ¹ : CommSemiring R\np q : R[X]\nx : R\ninstâœ : CommSemiring S\nf : R â†’+* S\nâŠ¢ eval x (p.comp q) = eval (eval x q) p"
    },
    {
      "name": "Polynomial.eval_one_map",
      "statement": "R : Type u\nS : Type v\nT : Type w\nÎ¹ : Type y\na b : R\nm n : â„•\ninstâœÂ¹ : Semiring R\npâœ q r : R[X]\ninstâœ : Semiring S\nfâœ f : R â†’+* S\np : R[X]\nâŠ¢ eval 1 (map f p) = f (eval 1 p)"
    },
    {
      "name": "Polynomial.evalâ‚‚_X_pow",
      "statement": "R : Type u\nS : Type v\nT : Type w\nÎ¹ : Type y\na b : R\nm nâœ : â„•\ninstâœÂ¹ : Semiring R\np q r : R[X]\ninstâœ : Semiring S\nf : R â†’+* S\nx : S\nn : â„•\nâŠ¢ evalâ‚‚ f x (X ^ n) = x ^ n"
    },
    {
      "name": "Polynomial.evalâ‚‚_mul_X",
      "statement": "R : Type u\nS : Type v\nT : Type w\nÎ¹ : Type y\na b : R\nm n : â„•\ninstâœÂ² : Semiring R\np q r : R[X]\ninstâœÂ¹ : Semiring S\nf : R â†’+* S\nx : S\ninstâœ : Semiring T\nâŠ¢ evalâ‚‚ f x (p * X) = evalâ‚‚ f x p * x"
    },
    {
      "name": "Polynomial.evalâ‚‚_neg",
      "statement": "R : Type u\nSâœ : Type v\nT : Type w\nÎ¹ : Type y\na b : R\nm n : â„•\ninstâœÂ¹ : Ring R\np q r : R[X]\nS : Type u_1\ninstâœ : Ring S\nf : R â†’+* S\nx : S\nâŠ¢ evalâ‚‚ f x (-p) = -evalâ‚‚ f x p"
    },
    {
      "name": "Polynomial.hasseDeriv_monomial",
      "statement": "R : Type u_1\ninstâœ : Semiring R\nk : â„•\nf : R[X]\nn : â„•\nr : R\nâŠ¢ (hasseDeriv k) ((monomial n) r) = (monomial (n - k)) (â†‘(n.choose k) * r)"
    },
    {
      "name": "Polynomial.isNilpotent_X_mul_iff",
      "statement": "R : Type u_1\nr : R\ninstâœ : Semiring R\nP : R[X]\nâŠ¢ IsNilpotent (X * P) â†” IsNilpotent P"
    },
    {
      "name": "Polynomial.isNilpotent_reflect_iff",
      "statement": "R : Type u_1\nr : R\ninstâœ : CommRing R\nPâœ P : R[X]\nN : â„•\nhN : P.natDegree â‰¤ N\nâŠ¢ IsNilpotent (reflect N P) â†” IsNilpotent P"
    },
    {
      "name": "Polynomial.isRegular_X_pow",
      "statement": "R : Type u\nS : Type v\na b : R\nnâœ m : â„•\ninstâœ : Semiring R\np q r : R[X]\nn : â„•\nâŠ¢ IsRegular (X ^ n)"
    },
    {
      "name": "Polynomial.isUnit_of_coeff_isUnit_isNilpotent",
      "statement": "R : Type u_1\nr : R\ninstâœ : CommRing R\nP : R[X]\nhunit : IsUnit (P.coeff 0)\nhnil : âˆ€ (i : â„•), i â‰  0 â†’ IsNilpotent (P.coeff i)\nâŠ¢ IsUnit P"
    },
    {
      "name": "Polynomial.iterate_derivative_comp_one_sub_X",
      "statement": "R : Type u\nS : Type v\nT : Type w\nÎ¹ : Type y\nA : Type z\na b : R\nn : â„•\ninstâœ : CommRing R\np : R[X]\nk : â„•\nâŠ¢ (â‡‘derivative)^[k] (p.comp (1 - X)) = (-1) ^ k * ((â‡‘derivative)^[k] p).comp (1 - X)"
    },
    {
      "name": "Polynomial.iterate_derivative_smul",
      "statement": "R : Type u\nSâœ : Type v\nT : Type w\nÎ¹ : Type y\nA : Type z\na b : R\nn : â„•\ninstâœÂ³ : Semiring R\nS : Type u_1\ninstâœÂ² : Monoid S\ninstâœÂ¹ : DistribMulAction S R\ninstâœ : IsScalarTower S R R\ns : S\np : R[X]\nk : â„•\nâŠ¢ (â‡‘derivative)^[k] (s â€¢ p) = s â€¢ (â‡‘derivative)^[k] p"
    },
    {
      "name": "Polynomial.leadingCoeff_eq_zero_iff_deg_eq_bot",
      "statement": "R : Type u\nS : Type v\na b c d : R\nn m : â„•\ninstâœ : Semiring R\npâœ p q : R[X]\nÎ¹ : Type u_1\nâŠ¢ p.leadingCoeff = 0 â†” p.degree = âŠ¥"
    },
    {
      "name": "Polynomial.mapAlg_eq_map",
      "statement": "R : Type u\ninstâœÂ² : CommSemiring R\nS : Type v\ninstâœÂ¹ : Semiring S\ninstâœ : Algebra R S\np : R[X]\nâŠ¢ (mapAlg R S) p = map (algebraMap R S) p"
    },
    {
      "name": "Polynomial.mem_aroots'",
      "statement": "R : Type u\nS : Type v\nT : Type w\naâœ b : R\nn : â„•\ninstâœâµ : CommRing R\ninstâœâ´ : IsDomain R\npâœ q : R[X]\ninstâœÂ³ : CommRing T\ninstâœÂ² : CommRing S\ninstâœÂ¹ : IsDomain S\ninstâœ : Algebra T S\np : T[X]\na : S\nâŠ¢ a âˆˆ p.aroots S â†” map (algebraMap T S) p â‰  0 âˆ§ (aeval a) p = 0"
    },
    {
      "name": "Polynomial.mirror_leadingCoeff",
      "statement": "R : Type u_1\ninstâœ : Semiring R\np q : R[X]\nâŠ¢ p.mirror.leadingCoeff = p.trailingCoeff"
    },
    {
      "name": "Polynomial.mirror_zero",
      "statement": "R : Type u_1\ninstâœ : Semiring R\np q : R[X]\nâŠ¢ mirror 0 = 0"
    },
    {
      "name": "Polynomial.mkDerivation_X",
      "statement": "R : Type u_1\nA : Type u_2\ninstâœâ´ : CommSemiring R\ninstâœÂ³ : AddCommMonoid A\ninstâœÂ² : Module R A\ninstâœÂ¹ : Module R[X] A\ninstâœ : IsScalarTower R R[X] A\na : A\nâŠ¢ ((mkDerivation R) a) X = a"
    },
    {
      "name": "Polynomial.modByMonic_X_sub_C_eq_C_eval",
      "statement": "R : Type u\nS : Type v\nT : Type w\nA : Type z\naâœ b : R\nn : â„•\ninstâœ : CommRing R\npâœ q p : R[X]\na : R\nâŠ¢ p %â‚˜ (X - C a) = C (eval a p)"
    },
    {
      "name": "Polynomial.monomial_pow",
      "statement": "R : Type u\na b : R\nm nâœ : â„•\ninstâœ : Semiring R\np q : R[X]\nn : â„•\nr : R\nk : â„•\nâŠ¢ (monomial n) r ^ k = (monomial (n * k)) (r ^ k)"
    },
    {
      "name": "Polynomial.mul_coeff_zero",
      "statement": "R : Type u\nS : Type v\na b : R\nn m : â„•\ninstâœ : Semiring R\npâœ qâœ r p q : R[X]\nâŠ¢ (p * q).coeff 0 = p.coeff 0 * q.coeff 0"
    },
    {
      "name": "Polynomial.natDegree_C",
      "statement": "R : Type u\nS : Type v\naâœ b c d : R\nn m : â„•\ninstâœ : Semiring R\np q r : R[X]\na : R\nâŠ¢ (C a).natDegree = 0"
    },
    {
      "name": "Polynomial.natDegree_C_add",
      "statement": "R : Type u\nS : Type v\naâœ b c d : R\nn m : â„•\ninstâœ : Semiring R\npâœ p q : R[X]\nÎ¹ : Type u_1\na : R\nâŠ¢ (C a + p).natDegree = p.natDegree"
    },
    {
      "name": "Polynomial.natDegree_add_C",
      "statement": "R : Type u\nS : Type v\naâœ b c d : R\nn m : â„•\ninstâœ : Semiring R\npâœ p q : R[X]\nÎ¹ : Type u_1\na : R\nâŠ¢ (p + C a).natDegree = p.natDegree"
    },
    {
      "name": "Polynomial.natDegree_derivative_le",
      "statement": "R : Type u\nS : Type v\nT : Type w\nÎ¹ : Type y\nA : Type z\na b : R\nn : â„•\ninstâœ : Semiring R\np : R[X]\nâŠ¢ (derivative p).natDegree â‰¤ p.natDegree - 1"
    },
    {
      "name": "Polynomial.natDegree_intCast",
      "statement": "R : Type u\nS : Type v\na b c d : R\nnâœ m : â„•\ninstâœ : Ring R\nn : â„¤\nâŠ¢ (â†‘n).natDegree = 0"
    },
    {
      "name": "Polynomial.natDegree_opRingEquiv",
      "statement": "R : Type u_1\ninstâœ : Semiring R\np : R[X]áµáµ’áµ–\nâŠ¢ ((opRingEquiv R) p).natDegree = (unop p).natDegree"
    },
    {
      "name": "Polynomial.natSepDegree_C_mul",
      "statement": "F : Type u\nE : Type v\ninstâœâ´ : Field F\ninstâœÂ³ : Field E\ninstâœÂ² : Algebra F E\nK : Type w\ninstâœÂ¹ : Field K\ninstâœ : Algebra F K\nf : F[X]\nx : F\nhx : x â‰  0\nâŠ¢ (C x * f).natSepDegree = f.natSepDegree"
    },
    {
      "name": "Polynomial.natSepDegree_X",
      "statement": "F : Type u\nE : Type v\ninstâœâ´ : Field F\ninstâœÂ³ : Field E\ninstâœÂ² : Algebra F E\nK : Type w\ninstâœÂ¹ : Field K\ninstâœ : Algebra F K\nf : F[X]\nâŠ¢ X.natSepDegree = 1"
    },
    {
      "name": "Polynomial.natSepDegree_pow",
      "statement": "F : Type u\nE : Type v\ninstâœâ´ : Field F\ninstâœÂ³ : Field E\ninstâœÂ² : Algebra F E\nK : Type w\ninstâœÂ¹ : Field K\ninstâœ : Algebra F K\nf : F[X]\nn : â„•\nâŠ¢ (f ^ n).natSepDegree = if n = 0 then 0 else f.natSepDegree"
    },
    {
      "name": "Polynomial.ofFinsupp_sub",
      "statement": "Râœ : Type u\naâœ bâœ : Râœ\nm n : â„•\ninstâœÂ¹ : Semiring Râœ\np q : Râœ[X]\nR : Type u\ninstâœ : Ring R\na b : R[â„•]\nâŠ¢ { toFinsupp := a - b } = { toFinsupp := a } - { toFinsupp := b }"
    },
    {
      "name": "Polynomial.reflect_C_mul_X_pow",
      "statement": "R : Type u_1\ninstâœ : Semiring R\nf : R[X]\nN n : â„•\nc : R\nâŠ¢ reflect N (C c * X ^ n) = C c * X ^ (revAt N) n"
    },
    {
      "name": "Polynomial.reverse_mul_X",
      "statement": "R : Type u_1\ninstâœ : Semiring R\nf p : R[X]\nâŠ¢ (p * X).reverse = p.reverse"
    },
    {
      "name": "Polynomial.reverse_mul_X_pow",
      "statement": "R : Type u_1\ninstâœ : Semiring R\nf p : R[X]\nn : â„•\nâŠ¢ (p * X ^ n).reverse = p.reverse"
    },
    {
      "name": "Polynomial.rootMultiplicity_mul",
      "statement": "R : Type u\nS : Type v\nT : Type w\na b : R\nn : â„•\ninstâœÂ¹ : CommRing R\ninstâœ : IsDomain R\npâœ qâœ p q : R[X]\nx : R\nhpq : p * q â‰  0\nâŠ¢ rootMultiplicity x (p * q) = rootMultiplicity x p + rootMultiplicity x q"
    },
    {
      "name": "Polynomial.roots_pow",
      "statement": "R : Type u\nS : Type v\nT : Type w\na b : R\nnâœ : â„•\ninstâœÂ¹ : CommRing R\ninstâœ : IsDomain R\npâœ q p : R[X]\nn : â„•\nâŠ¢ (p ^ n).roots = n â€¢ p.roots"
    },
    {
      "name": "Polynomial.smeval_smul",
      "statement": "R : Type u_1\ninstâœÂ³ : Semiring R\np q : R[X]\nS : Type u_2\ninstâœÂ² : AddCommMonoid S\ninstâœÂ¹ : Pow S â„•\ninstâœ : Module R S\nx : S\nr : R\nâŠ¢ (r â€¢ p).smeval x = r â€¢ p.smeval x"
    },
    {
      "name": "Polynomial.splits_id_iff_splits",
      "statement": "R : Type u_1\nF : Type u\nK : Type v\nL : Type w\ninstâœÂ² : CommRing K\ninstâœÂ¹ : Field L\ninstâœ : Field F\ni : K â†’+* L\nf : K[X]\nâŠ¢ Splits (RingHom.id L) (map i f) â†” Splits i f"
    },
    {
      "name": "Polynomial.splits_prod",
      "statement": "R : Type u_1\nF : Type u\nK : Type v\nL : Type w\ninstâœÂ² : CommRing K\ninstâœÂ¹ : Field L\ninstâœ : Field F\ni : K â†’+* L\nÎ¹ : Type u\ns : Î¹ â†’ K[X]\nt : Finset Î¹\nâŠ¢ (âˆ€ j âˆˆ t, Splits i (s j)) â†’ Splits i (âˆ x âˆˆ t, s x)"
    },
    {
      "name": "Polynomial.sub_dvd_eval_sub",
      "statement": "R : Type u\nS : Type v\nT : Type w\nA : Type z\naâœ bâœ : R\nn : â„•\ninstâœ : CommRing R\npâœ q : R[X]\na b : R\np : R[X]\nâŠ¢ a - b âˆ£ eval a p - eval b p"
    },
    {
      "name": "Polynomial.support_neg",
      "statement": "R : Type u\na b : R\nm n : â„•\ninstâœ : Ring R\np : R[X]\nâŠ¢ (-p).support = p.support"
    },
    {
      "name": "Polynomial.taylor_coeff_one",
      "statement": "R : Type u_1\ninstâœ : Semiring R\nr : R\nf : R[X]\nâŠ¢ ((taylor r) f).coeff 1 = eval r (derivative f)"
    },
    {
      "name": "Polynomial.taylor_coeff_zero",
      "statement": "R : Type u_1\ninstâœ : Semiring R\nr : R\nf : R[X]\nâŠ¢ ((taylor r) f).coeff 0 = eval r f"
    },
    {
      "name": "Polynomial.toFinsupp_mul",
      "statement": "R : Type u\naâœ bâœ : R\nm n : â„•\ninstâœ : Semiring R\np q a b : R[X]\nâŠ¢ (a * b).toFinsupp = a.toFinsupp * b.toFinsupp"
    },
    {
      "name": "Polynomial.toSubring_zero",
      "statement": "R : Type u\nS : Type u_1\ninstâœÂ¹ : Ring R\ninstâœ : Semiring S\nf : R â†’+* S\nx : S\np : R[X]\nT : Subring R\nhp : â†‘p.coeffs âŠ† â†‘T\nâŠ¢ â†‘(coeffs 0) âŠ† â†‘T"
    },
    {
      "name": "PolynomialModule.monomial_smul_apply",
      "statement": "R : Type u_1\nM : Type u_2\ninstâœâ¶ : CommRing R\ninstâœâµ : AddCommGroup M\ninstâœâ´ : Module R M\nI : Ideal R\nS : Type u_3\ninstâœÂ³ : CommSemiring S\ninstâœÂ² : Algebra S R\ninstâœÂ¹ : Module S M\ninstâœ : IsScalarTower S R M\ni : â„•\nr : R\ng : PolynomialModule R M\nn : â„•\nâŠ¢ ((monomial i) r â€¢ g) n = if i â‰¤ n then r â€¢ g (n - i) else 0"
    },
    {
      "name": "PosNum.cmp_eq",
      "statement": "Î± : Type u_1\nm n : PosNum\nâŠ¢ m.cmp n = Ordering.eq â†” m = n"
    },
    {
      "name": "PosNum.to_nat_inj",
      "statement": "Î± : Type u_1\nm n : PosNum\nh : â†‘m = â†‘n\nâŠ¢ pos m = pos n"
    },
    {
      "name": "PowerBasis.degree_minpoly",
      "statement": "R : Type u_1\nS : Type u_2\nT : Type u_3\ninstâœâ¹ : CommRing R\ninstâœâ¸ : Ring S\ninstâœâ· : Algebra R S\nA : Type u_4\nB : Type u_5\ninstâœâ¶ : CommRing A\ninstâœâµ : CommRing B\ninstâœâ´ : IsDomain B\ninstâœÂ³ : Algebra A B\nK : Type u_6\ninstâœÂ² : Field K\ninstâœÂ¹ : Algebra A S\ninstâœ : Nontrivial A\npb : PowerBasis A S\nâŠ¢ (minpoly A pb.gen).degree = â†‘pb.dim"
    },
    {
      "name": "PowerBasis.equivAdjoinSimple_symm_aeval",
      "statement": "K : Type u_1\nL : Type u_2\ninstâœÂ² : Field K\ninstâœÂ¹ : Field L\ninstâœ : Algebra K L\npb : PowerBasis K L\nf : K[X]\nâŠ¢ pb.equivAdjoinSimple.symm ((aeval pb.gen) f) = (aeval (AdjoinSimple.gen K pb.gen)) f"
    },
    {
      "name": "PowerBasis.equivAdjoinSimple_symm_gen",
      "statement": "K : Type u_1\nL : Type u_2\ninstâœÂ² : Field K\ninstâœÂ¹ : Field L\ninstâœ : Algebra K L\npb : PowerBasis K L\nâŠ¢ pb.equivAdjoinSimple.symm pb.gen = AdjoinSimple.gen K pb.gen"
    },
    {
      "name": "PowerSeries.coeff_mul_X_pow",
      "statement": "R : Type u_1\ninstâœ : Semiring R\np : RâŸ¦XâŸ§\nn d : â„•\nâŠ¢ (coeff R (d + n)) (p * X ^ n) = (coeff R d) p"
    },
    {
      "name": "PowerSeries.coeff_succ_mul_X",
      "statement": "R : Type u_1\ninstâœ : Semiring R\nn : â„•\nÏ† : RâŸ¦XâŸ§\nâŠ¢ (coeff R (n + 1)) (Ï† * X) = (coeff R n) Ï†"
    },
    {
      "name": "PowerSeries.derivative_X",
      "statement": "R : Type u_1\ninstâœ : CommSemiring R\nâŠ¢ (dâ„dX R) X = 1"
    },
    {
      "name": "PowerSeries.invUnitsSub_mul_X",
      "statement": "R : Type u_1\nS : Type u_2\ninstâœÂ¹ : Ring R\ninstâœ : Ring S\nu : RË£\nâŠ¢ invUnitsSub u * X = invUnitsSub u * (C R) â†‘u - 1"
    },
    {
      "name": "PowerSeries.rescale_zero_apply",
      "statement": "R : Type u_1\ninstâœ : CommSemiring R\nâŠ¢ (rescale 0) X = (C R) ((constantCoeff R) X)"
    },
    {
      "name": "PowerSeries.trunc_trunc_pow",
      "statement": "Râœ : Type u_1\nR : Type u_2\ninstâœ : CommSemiring R\nf : RâŸ¦XâŸ§\nn a : â„•\nâŠ¢ trunc n (â†‘(trunc n f) ^ a) = trunc n (f ^ a)"
    },
    {
      "name": "Prefunctor.IsCovering.map_injective",
      "statement": "U : Type u_1\ninstâœÂ² : Quiver U\nV : Type u_2\ninstâœÂ¹ : Quiver V\nÏ† : U â¥¤q V\nW : Type ?u.1962\ninstâœ : Quiver W\nÏˆ : V â¥¤q W\nhÏ† : Ï†.IsCovering\nu v : U\nâŠ¢ Injective fun f => Ï†.map f"
    },
    {
      "name": "Prefunctor.mapPath_comp",
      "statement": "V : Type uâ‚\ninstâœÂ¹ : Quiver V\nW : Type uâ‚‚\ninstâœ : Quiver W\nF : V â¥¤q W\na b : V\np : Path a b\nc bâœ : V\nq : Path b bâœ\ne : bâœ âŸ¶ c\nâŠ¢ F.mapPath (p.comp (q.cons e)) = (F.mapPath p).comp (F.mapPath (q.cons e))"
    },
    {
      "name": "PresentedGroup.closure_range_of",
      "statement": "Î± : Type u_1\nrels : Set (FreeGroup Î±)\nâŠ¢ Subgroup.closure (Set.range of) = âŠ¤"
    },
    {
      "name": "PrimeMultiset.prod_dvd_iff",
      "statement": "u v : PrimeMultiset\nâŠ¢ u.prod âˆ£ v.prod â†” u â‰¤ v"
    },
    {
      "name": "PrimeMultiset.to_ofNatMultiset",
      "statement": "v : Multiset â„•\nh : âˆ€ p âˆˆ v, Nat.Prime p\nâŠ¢ (ofNatMultiset v h).toNatMultiset = v"
    },
    {
      "name": "PrincipalSeg.irrefl",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nrâœ : Î± â†’ Î± â†’ Prop\ns : Î² â†’ Î² â†’ Prop\nt : Î³ â†’ Î³ â†’ Prop\nr : Î± â†’ Î± â†’ Prop\ninstâœ : IsWellOrder Î± r\nf : r â‰ºi r\nâŠ¢ False"
    },
    {
      "name": "ProbabilityTheory.IndepSet_iff_Indep",
      "statement": "Î© : Type u_1\nÎ¹ : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\nÎº : Î¹ â†’ Type u_5\nÏ€ : Î¹ â†’ Set (Set Î©)\nm : Î¹ â†’ MeasurableSpace Î©\nxâœ : MeasurableSpace Î©\nÎ¼âœ : Measure Î©\nS : Finset Î¹\nsâœ : Î¹ â†’ Set Î©\ns t : Set Î©\nÎ¼ : Measure Î©\nâŠ¢ IndepSet s t Î¼ â†” Indep (generateFrom {s}) (generateFrom {t}) Î¼"
    },
    {
      "name": "ProbabilityTheory.cond_eq_zero",
      "statement": "Î© : Type u_1\nÎ©' : Type u_2\nÎ± : Type u_3\nm : MeasurableSpace Î©\nm' : MeasurableSpace Î©'\nÎ¼ : Measure Î©\ns t : Set Î©\nhÎ¼s : Î¼ s â‰  âŠ¤\nâŠ¢ Î¼[|s] = 0 â†” Î¼ s = 0"
    },
    {
      "name": "ProbabilityTheory.cond_univ",
      "statement": "Î© : Type u_1\nÎ©' : Type u_2\nÎ± : Type u_3\nm : MeasurableSpace Î©\nm' : MeasurableSpace Î©'\nÎ¼ : Measure Î©\ns t : Set Î©\ninstâœ : IsProbabilityMeasure Î¼\nâŠ¢ Î¼[|univ] = Î¼"
    },
    {
      "name": "ProbabilityTheory.evariance_zero",
      "statement": "Î© : Type u_1\nm : MeasurableSpace Î©\nX : Î© â†’ â„\nÎ¼ : Measure Î©\nâŠ¢ evariance 0 Î¼ = 0"
    },
    {
      "name": "ProbabilityTheory.measurable_geometricPMFReal",
      "statement": "p : â„\nâŠ¢ Measurable (geometricPMFReal p)"
    },
    {
      "name": "ProbabilityTheory.moment_zero",
      "statement": "Î© : Type u_1\nÎ¹ : Type u_2\nm : MeasurableSpace Î©\nX : Î© â†’ â„\np : â„•\nÎ¼ : Measure Î©\nhp : p â‰  0\nâŠ¢ moment 0 p Î¼ = 0"
    },
    {
      "name": "Prod.ext_iff",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\np q : Î± Ã— Î²\nâŠ¢ p = q â†” p.fst = q.fst âˆ§ p.snd = q.snd"
    },
    {
      "name": "Prod.gameAdd_swap_swap",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nrÎ± : Î± â†’ Î± â†’ Prop\nrÎ² : Î² â†’ Î² â†’ Prop\na : Î±\nb : Î²\nxâœÂ¹ xâœ : Î± Ã— Î²\naâ‚ : Î±\nbâ‚ : Î²\naâ‚‚ : Î±\nbâ‚‚ : Î²\nâŠ¢ GameAdd rÎ² rÎ± (aâ‚, bâ‚).swap (aâ‚‚, bâ‚‚).swap â†” GameAdd rÎ± rÎ² (aâ‚, bâ‚) (aâ‚‚, bâ‚‚)"
    },
    {
      "name": "Prod.smul_mk_zero",
      "statement": "M : Type u_1\nN : Type u_2\nP : Type u_3\nE : Type u_4\nÎ± : Type u_5\nÎ²âœ : Type u_6\ninstâœâ¶ : SMul M Î±\ninstâœâµ : SMul M Î²âœ\ninstâœâ´ : SMul N Î±\ninstâœÂ³ : SMul N Î²âœ\naâœ : M\nx : Î± Ã— Î²âœ\nÎ² : Type u_7\ninstâœÂ² : Monoid M\ninstâœÂ¹ : AddMonoid Î²\ninstâœ : DistribMulAction M Î²\na : M\nb : Î±\nâŠ¢ a â€¢ (b, 0) = (a â€¢ b, 0)"
    },
    {
      "name": "Prod.smul_zero_mk",
      "statement": "M : Type u_1\nN : Type u_2\nP : Type u_3\nE : Type u_4\nÎ±âœ : Type u_5\nÎ² : Type u_6\ninstâœâ¶ : SMul M Î±âœ\ninstâœâµ : SMul M Î²\ninstâœâ´ : SMul N Î±âœ\ninstâœÂ³ : SMul N Î²\naâœ : M\nx : Î±âœ Ã— Î²\nÎ± : Type u_7\ninstâœÂ² : Monoid M\ninstâœÂ¹ : AddMonoid Î±\ninstâœ : DistribMulAction M Î±\na : M\nc : Î²\nâŠ¢ a â€¢ (0, c) = (0, a â€¢ c)"
    },
    {
      "name": "Prod.snd_zmod_cast",
      "statement": "n : â„•\nR : Type u_1\ninstâœÂ¹ : AddGroupWithOne R\nS : Type u_2\ninstâœ : AddGroupWithOne S\na : ZMod n\nâŠ¢ a.cast.2 = a.cast"
    },
    {
      "name": "Profinite.NobelingProof.GoodProducts.good_lt_maxProducts",
      "statement": "I : Type u\ninstâœÂ¹ : LinearOrder I\ninstâœ : IsWellOrder I fun x x_1 => x < x_1\nC : Set (I â†’ Bool)\no : Ordinal.{u}\nhC : IsClosed C\nhsC : contained C (Order.succ o)\nho : o < Ordinal.type fun x x_1 => x < x_1\nq : â†‘(GoodProducts (Ï€ C fun x => ord I x < o))\nl : â†‘(MaxProducts C ho)\nâŠ¢ List.Lex (fun x x_1 => x < x_1) â†‘â†‘q â†‘â†‘l"
    },
    {
      "name": "ProjectiveSpectrum.zeroLocus_singleton_pow",
      "statement": "R : Type u_1\nA : Type u_2\ninstâœÂ³ : CommSemiring R\ninstâœÂ² : CommRing A\ninstâœÂ¹ : Algebra R A\nğ’œ : â„• â†’ Submodule R A\ninstâœ : GradedAlgebra ğ’œ\nf : A\nn : â„•\nhn : 0 < n\nx : ProjectiveSpectrum ğ’œ\nâŠ¢ x âˆˆ zeroLocus ğ’œ {f ^ n} â†” x âˆˆ zeroLocus ğ’œ {f}"
    },
    {
      "name": "Quaternion.normSq_eq_zero",
      "statement": "R : Type u_1\ninstâœ : LinearOrderedCommRing R\na : â„[R]\nâŠ¢ normSq a = 0 â†” a = 0"
    },
    {
      "name": "QuaternionGroup.a_one_pow_n",
      "statement": "n : â„•\nâŠ¢ a 1 ^ (2 * n) = 1"
    },
    {
      "name": "QuaternionGroup.xa_sq",
      "statement": "n : â„•\ni : ZMod (2 * n)\nâŠ¢ xa i ^ 2 = a â†‘n"
    },
    {
      "name": "Quiver.Path.cast_nil",
      "statement": "U : Type u_1\ninstâœ : Quiver U\nu u' : U\nhu : u = u'\nâŠ¢ cast hu hu nil = nil"
    },
    {
      "name": "QuotientAddGroup.norm_lift_apply_le",
      "statement": "M : Type u_1\nN : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup M\ninstâœ : SeminormedAddCommGroup N\nS : AddSubgroup M\nf : NormedAddGroupHom M N\nhf : âˆ€ x âˆˆ S, f x = 0\nx : M â§¸ S\nâŠ¢ â€–(lift S f.toAddMonoidHom hf) xâ€– â‰¤ â€–fâ€– * â€–xâ€–"
    },
    {
      "name": "QuotientGroup.isClosedMap_coe",
      "statement": "G : Type w\nHâœ : Type x\nÎ± : Type u\nÎ² : Type v\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : Group G\ninstâœ : TopologicalGroup G\ns t : Set G\nH : Subgroup G\nhH : IsCompact â†‘H\nâŠ¢ IsClosedMap mk"
    },
    {
      "name": "RCLike.conj_neg_I",
      "statement": "K : Type u_1\nE : Type u_2\ninstâœ : RCLike K\nâŠ¢ (starRingEnd K) (-I) = I"
    },
    {
      "name": "RCLike.conj_ofReal",
      "statement": "K : Type u_1\nE : Type u_2\ninstâœ : RCLike K\nr : â„\nâŠ¢ (starRingEnd K) â†‘r = â†‘r"
    },
    {
      "name": "RCLike.natCast_re",
      "statement": "K : Type u_1\nE : Type u_2\ninstâœ : RCLike K\nz : K\nn : â„•\nâŠ¢ re â†‘n = â†‘n"
    },
    {
      "name": "RCLike.one_im",
      "statement": "K : Type u_1\nE : Type u_2\ninstâœ : RCLike K\nâŠ¢ im 1 = 0"
    },
    {
      "name": "RCLike.reCLM_norm",
      "statement": "K : Type u_1\nE : Type u_2\ninstâœ : RCLike K\nâŠ¢ â€–reCLMâ€– = 1"
    },
    {
      "name": "Rat.addSubmonoid_closure_range_pow",
      "statement": "n : â„•\nhnâ‚€ : n â‰  0\nhn : Even n\nâŠ¢ closure (range fun x => x ^ n) = nonneg â„š"
    },
    {
      "name": "Rat.add_assoc",
      "statement": "q a b c : â„š\nnâ‚ : â„¤\ndâ‚ : â„•\nhâ‚ : dâ‚ â‰  0\nnâ‚‚ : â„¤\ndâ‚‚ : â„•\nhâ‚‚ : dâ‚‚ â‰  0\nnâ‚ƒ : â„¤\ndâ‚ƒ : â„•\nhâ‚ƒ : dâ‚ƒ â‰  0\nâŠ¢ nâ‚ /. â†‘dâ‚ + nâ‚‚ /. â†‘dâ‚‚ + nâ‚ƒ /. â†‘dâ‚ƒ = nâ‚ /. â†‘dâ‚ + (nâ‚‚ /. â†‘dâ‚‚ + nâ‚ƒ /. â†‘dâ‚ƒ)"
    },
    {
      "name": "Rat.add_def",
      "statement": "a b : Rat\nâŠ¢ a + b = normalize (a.num * â†‘b.den + b.num * â†‘a.den) (a.den * b.den) â‹¯"
    },
    {
      "name": "Rat.cast_natCast",
      "statement": "F : Type u_1\nÎ¹ : Type u_2\nÎ± : Type u_3\nÎ² : Type u_4\ninstâœ : DivisionRing Î±\np q : â„š\nn : â„•\nâŠ¢ â†‘â†‘n = â†‘n"
    },
    {
      "name": "Rat.divInt_nonneg",
      "statement": "aâœ bâœ c p q : â„š\na b : â„¤\nha : 0 â‰¤ a\nhb : 0 â‰¤ b\nâŠ¢ 0 â‰¤ a /. b"
    },
    {
      "name": "Rat.divInt_nonneg_iff_of_pos_right",
      "statement": "aâœ bâœ c p q : â„š\na b : â„¤\nhb : 0 < b\nâŠ¢ 0 â‰¤ a /. b â†” 0 â‰¤ a"
    },
    {
      "name": "Rat.divInt_pow",
      "statement": "num : â„•\nden : â„¤\nn : â„•\nâŠ¢ (â†‘num /. den) ^ n = â†‘num ^ n /. den ^ n"
    },
    {
      "name": "Rat.intCast_div_self",
      "statement": "n : â„¤\nâŠ¢ â†‘(n / n) = â†‘n / â†‘n"
    },
    {
      "name": "Rat.mkRat_nonneg",
      "statement": "aâœ bâœ c p q : â„š\na : â„¤\nha : 0 â‰¤ a\nb : â„•\nâŠ¢ 0 â‰¤ mkRat a b"
    },
    {
      "name": "Rat.mul_add",
      "statement": "q a b c : â„š\nâŠ¢ a * (b + c) = a * b + a * c"
    },
    {
      "name": "Rat.neg_divInt",
      "statement": "n d : Int\nâŠ¢ -(n /. d) = -n /. d"
    },
    {
      "name": "Rat.neg_mkRat",
      "statement": "n : Int\nd : Nat\nâŠ¢ -mkRat n d = mkRat (-n) d"
    },
    {
      "name": "Rat.normalize_eq_zero",
      "statement": "d : Nat\nn : Int\nd0 : d â‰  0\nâŠ¢ normalize n d d0 = 0 â†” n = 0"
    },
    {
      "name": "Rat.ofScientific_true_def",
      "statement": "m e : Nat\nâŠ¢ Rat.ofScientific m true e = mkRat (â†‘m) (10 ^ e)"
    },
    {
      "name": "RatFunc.eval_zero",
      "statement": "K : Type u\ninstâœÂ¹ : Field K\nL : Type u\ninstâœ : Field L\nf : K â†’+* L\na : L\nâŠ¢ eval f a 0 = 0"
    },
    {
      "name": "RatFunc.intDegree_one",
      "statement": "K : Type u\ninstâœ : Field K\nâŠ¢ intDegree 1 = 0"
    },
    {
      "name": "RatFunc.num_div_dvd",
      "statement": "K : Type u\ninstâœ : Field K\np q : K[X]\nhq : q â‰  0\nâŠ¢ ((algebraMap K[X] (RatFunc K)) p / (algebraMap K[X] (RatFunc K)) q).num âˆ£ p"
    },
    {
      "name": "Real.Angle.cos_antiperiodic",
      "statement": "âŠ¢ Function.Antiperiodic cos â†‘Ï€"
    },
    {
      "name": "Real.Angle.sign_pi_add",
      "statement": "Î¸ : Angle\nâŠ¢ (â†‘Ï€ + Î¸).sign = -Î¸.sign"
    },
    {
      "name": "Real.Angle.toIocMod_toReal",
      "statement": "Î¸ : Angle\nâŠ¢ toIocMod two_pi_pos (-Ï€) Î¸.toReal = Î¸.toReal"
    },
    {
      "name": "Real.Angle.toReal_pi",
      "statement": "âŠ¢ (â†‘Ï€).toReal = Ï€"
    },
    {
      "name": "Real.arcsin_nonneg",
      "statement": "xâœ y x : â„\nâŠ¢ sin 0 â‰¤ x â†” 0 â‰¤ x"
    },
    {
      "name": "Real.arsinh_nonpos_iff",
      "statement": "x y : â„\nâŠ¢ arsinh x â‰¤ 0 â†” x â‰¤ 0"
    },
    {
      "name": "Real.convergent_of_zero",
      "statement": "n : â„•\nâŠ¢ convergent 0 n = 0"
    },
    {
      "name": "Real.cos_pi_div_four",
      "statement": "x : â„\nâŠ¢ cos (Ï€ / 4) = âˆš2 / 2"
    },
    {
      "name": "Real.cos_pi_div_three",
      "statement": "x : â„\nâŠ¢ cos (Ï€ / 3) = 1 / 2"
    },
    {
      "name": "Real.cos_pi_over_two_pow",
      "statement": "x : â„\nâŠ¢ cos (Ï€ / 2 ^ (0 + 1)) = sqrtTwoAddSeries 0 0 / 2"
    },
    {
      "name": "Real.deriv_mul_log",
      "statement": "x : â„\nhx : x â‰  0\nâŠ¢ deriv (fun x => x * log x) x = log x + 1"
    },
    {
      "name": "Real.deriv_tan",
      "statement": "x : â„\nh : cos x = 0\nâŠ¢ deriv tan x = 1 / cos x ^ 2"
    },
    {
      "name": "Real.exp_strictMono",
      "statement": "xâœ yâœ x y : â„\nh : x < y\nâŠ¢ rexp x < rexp y"
    },
    {
      "name": "Real.isBigO_exp_comp_one",
      "statement": "Î± : Type u_1\nx y z : â„\nl : Filter Î±\nf : Î± â†’ â„\nâŠ¢ ((fun x => rexp (f x)) =O[l] fun x => 1) â†” IsBoundedUnder (fun x x_1 => x â‰¤ x_1) l f"
    },
    {
      "name": "Real.log_inv",
      "statement": "xâœ y x : â„\nâŠ¢ log xâ»Â¹ = -log x"
    },
    {
      "name": "Real.log_pow",
      "statement": "xâœ y x : â„\nn : â„•\nâŠ¢ log (x ^ n) = â†‘n * log x"
    },
    {
      "name": "Real.mk_le",
      "statement": "x y : â„\nf g : CauSeq â„š abs\nâŠ¢ mk f â‰¤ mk g â†” f â‰¤ g"
    },
    {
      "name": "Real.mul_self_sqrt",
      "statement": "x y : â„\nh : 0 â‰¤ x\nâŠ¢ âˆšx * âˆšx = x"
    },
    {
      "name": "Real.nnabs_of_nonneg",
      "statement": "x : â„\nh : 0 â‰¤ x\nâŠ¢ nnabs x = x.toNNReal"
    },
    {
      "name": "Real.one_lt_exp_iff",
      "statement": "xâœ y x : â„\nâŠ¢ 1 < rexp x â†” 0 < x"
    },
    {
      "name": "Real.range_cos_infinite",
      "statement": "âŠ¢ (range cos).Infinite"
    },
    {
      "name": "Real.rank_rat_real",
      "statement": "âŠ¢ Module.rank â„š â„ = ğ” "
    },
    {
      "name": "Real.rpow_lt_rpow_of_exponent_gt",
      "statement": "x y z : â„\nn : â„•\nhx0 : 0 < x\nhx1 : x < 1\nhyz : z < y\nâŠ¢ x ^ y < x ^ z"
    },
    {
      "name": "Real.sInf_le_sSup",
      "statement": "s : Set â„\nhâ‚ : BddBelow s\nhâ‚‚ : BddAbove s\nâŠ¢ sInf s â‰¤ sSup s"
    },
    {
      "name": "Real.sign_eq_zero_iff",
      "statement": "r : â„\nâŠ¢ r.sign = 0 â†” r = 0"
    },
    {
      "name": "Real.sin_pi_div_six",
      "statement": "x : â„\nâŠ¢ sin (Ï€ / 6) = 1 / 2"
    },
    {
      "name": "Real.sin_two_pi",
      "statement": "âŠ¢ sin (2 * Ï€) = 0"
    },
    {
      "name": "Real.sqrt_sq",
      "statement": "x y : â„\nh : 0 â‰¤ x\nâŠ¢ âˆš(x ^ 2) = x"
    },
    {
      "name": "Real.summable_nat_rpow_inv",
      "statement": "p : â„\nâŠ¢ (Summable fun n => (â†‘n ^ p)â»Â¹) â†” 1 < p"
    },
    {
      "name": "Real.volume_Ioo",
      "statement": "Î¹ : Type u_1\ninstâœ : Fintype Î¹\na b : â„\nâŠ¢ volume (Ioo a b) = ofReal (b - a)"
    },
    {
      "name": "Real.volume_ball",
      "statement": "Î¹ : Type u_1\ninstâœ : Fintype Î¹\na r : â„\nâŠ¢ volume (Metric.ball a r) = ofReal (2 * r)"
    },
    {
      "name": "Real.volume_closedBall",
      "statement": "Î¹ : Type u_1\ninstâœ : Fintype Î¹\na r : â„\nâŠ¢ volume (Metric.closedBall a r) = ofReal (2 * r)"
    },
    {
      "name": "Real.volume_singleton",
      "statement": "Î¹ : Type u_1\ninstâœ : Fintype Î¹\na : â„\nâŠ¢ volume {a} = 0"
    },
    {
      "name": "RegularExpression.matches'_map",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ndec : DecidableEq Î±\naâœ b : Î±\nf : Î± â†’ Î²\na : Î±\nâŠ¢ (map f (char a)).matches' = (Language.map f) (char a).matches'"
    },
    {
      "name": "RegularExpression.rmatch_iff_matches'",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ndec : DecidableEq Î±\na b : Î±\nP : RegularExpression Î±\nx : List Î±\nâŠ¢ P.rmatch x = true â†” x âˆˆ P.matches'"
    },
    {
      "name": "Rel.edgeDensity_empty_right",
      "statement": "ğ•œ : Type u_1\nÎ¹ : Type u_2\nÎº : Type u_3\nÎ± : Type u_4\nÎ² : Type u_5\ninstâœÂ¹ : LinearOrderedField ğ•œ\nr : Î± â†’ Î² â†’ Prop\ninstâœ : (a : Î±) â†’ DecidablePred (r a)\nsâœ sâ‚ sâ‚‚ : Finset Î±\nt tâ‚ tâ‚‚ : Finset Î²\na : Î±\nb : Î²\nÎ´ : ğ•œ\ns : Finset Î±\nâŠ¢ edgeDensity r s âˆ… = 0"
    },
    {
      "name": "Relation.TransGen.tail'",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\nÎµ : Type u_5\nÎ¶ : Type u_6\nr : Î± â†’ Î± â†’ Prop\na b c d : Î±\nhab : ReflTransGen r a b\nhbc : r b c\nâŠ¢ TransGen r a c"
    },
    {
      "name": "Representation.asAlgebraHom_single",
      "statement": "k : Type u_1\nG : Type u_2\nV : Type u_3\ninstâœÂ³ : CommSemiring k\ninstâœÂ² : Monoid G\ninstâœÂ¹ : AddCommMonoid V\ninstâœ : Module k V\nÏ : Representation k G V\ng : G\nr : k\nâŠ¢ Ï.asAlgebraHom (Finsupp.single g r) = r â€¢ Ï g"
    },
    {
      "name": "Right.inv_lt_one_iff",
      "statement": "Î± : Type u\ninstâœÂ² : Group Î±\ninstâœÂ¹ : LT Î±\ninstâœ : CovariantClass Î± Î± (swap fun x x_1 => x * x_1) fun x x_1 => x < x_1\na b c : Î±\nâŠ¢ aâ»Â¹ < 1 â†” 1 < a"
    },
    {
      "name": "Ring.DirectLimit.congr_symm_apply_of",
      "statement": "R : Type u\ninstâœâ· : Ring R\nÎ¹ : Type v\ninstâœâ¶ : Preorder Î¹\nG : Î¹ â†’ Type w\ninstâœâµ : (i : Î¹) â†’ CommRing (G i)\nfâœ : (i j : Î¹) â†’ i â‰¤ j â†’ G i â†’ G j\nf'âœ : (i j : Î¹) â†’ i â‰¤ j â†’ G i â†’+* G j\nP : Type uâ‚\ninstâœâ´ : CommRing P\ngâœ : (i : Î¹) â†’ G i â†’+* P\nHg : âˆ€ (i j : Î¹) (hij : i â‰¤ j) (x : G i), (gâœ j) (fâœ i j hij x) = (gâœ i) x\nf : (i j : Î¹) â†’ i â‰¤ j â†’ G i â†’+* G j\nG' : Î¹ â†’ Type v'\ninstâœÂ³ : (i : Î¹) â†’ CommRing (G' i)\nf' : (i j : Î¹) â†’ i â‰¤ j â†’ G' i â†’+* G' j\nG'' : Î¹ â†’ Type v''\ninstâœÂ² : (i : Î¹) â†’ CommRing (G'' i)\nf'' : (i j : Î¹) â†’ i â‰¤ j â†’ G'' i â†’+* G'' j\ninstâœÂ¹ : Nonempty Î¹\ninstâœ : IsDirected Î¹ fun x x_1 => x â‰¤ x_1\ne : (i : Î¹) â†’ G i â‰ƒ+* G' i\nhe : âˆ€ (i j : Î¹) (h : i â‰¤ j), (e j).toRingHom.comp (f i j h) = (f' i j h).comp â†‘(e i)\ni : Î¹\ng : G' i\nâŠ¢ (congr e he).symm ((of G' (fun x x_1 h => â‡‘(f' x x_1 h)) i) g) = (of G (fun x x_1 h => â‡‘(f x x_1 h)) i) ((e i).symm g)"
    },
    {
      "name": "Ring.inverse_unit",
      "statement": "Î± : Type u_1\nMâ‚€ : Type u_2\nGâ‚€ : Type u_3\nMâ‚€' : Type u_4\nGâ‚€' : Type u_5\nF : Type u_6\nF' : Type u_7\ninstâœ : MonoidWithZero Mâ‚€\nu : Mâ‚€Ë£\nâŠ¢ inverse â†‘u = â†‘uâ»Â¹"
    },
    {
      "name": "Ring.multichoose_one",
      "statement": "Râœ : Type u_1\ninstâœâ¶ : AddCommMonoid Râœ\ninstâœâµ : Pow Râœ â„•\ninstâœâ´ : BinomialRing Râœ\nR : Type u_2\ninstâœÂ³ : NonAssocSemiring R\ninstâœÂ² : Pow R â„•\ninstâœÂ¹ : NatPowAssoc R\ninstâœ : BinomialRing R\nk : â„•\nâŠ¢ multichoose 1 k = 1"
    },
    {
      "name": "Ring.multichoose_one_right'",
      "statement": "R : Type u_1\ninstâœÂ² : AddCommMonoid R\ninstâœÂ¹ : Pow R â„•\ninstâœ : BinomialRing R\nr : R\nâŠ¢ multichoose r 1 = r ^ 1"
    },
    {
      "name": "Ring.multichoose_zero_right'",
      "statement": "R : Type u_1\ninstâœÂ² : AddCommMonoid R\ninstâœÂ¹ : Pow R â„•\ninstâœ : BinomialRing R\nr : R\nâŠ¢ multichoose r 0 = r ^ 0"
    },
    {
      "name": "RingHom.Finite.comp",
      "statement": "A : Type u_1\nB : Type u_2\nC : Type u_3\ninstâœÂ² : CommRing A\ninstâœÂ¹ : CommRing B\ninstâœ : CommRing C\ng : B â†’+* C\nf : A â†’+* B\nhg : g.Finite\nhf : f.Finite\nâŠ¢ (g.comp f).Finite"
    },
    {
      "name": "RingHom.surjective_respectsIso",
      "statement": "âŠ¢ RespectsIso fun {X Y} [CommRing X] [CommRing Y] f => Function.Surjective â‡‘f"
    },
    {
      "name": "RingHom.toMonoidWithZeroHom_eq_coe",
      "statement": "F : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\nxâœÂ¹ : NonAssocSemiring Î±\nxâœ : NonAssocSemiring Î²\nf : Î± â†’+* Î²\nâŠ¢ â‡‘f.toMonoidWithZeroHom = â‡‘f"
    },
    {
      "name": "RingHomInvPair.comp_apply_eqâ‚‚",
      "statement": "Râ‚ : Type u_1\nRâ‚‚ : Type u_2\nRâ‚ƒ : Type u_3\ninstâœÂ³ : Semiring Râ‚\ninstâœÂ² : Semiring Râ‚‚\ninstâœÂ¹ : Semiring Râ‚ƒ\nÏƒâ‚â‚‚ : Râ‚ â†’+* Râ‚‚\nÏƒâ‚‚â‚ƒ : Râ‚‚ â†’+* Râ‚ƒ\nÏƒâ‚â‚ƒ : Râ‚ â†’+* Râ‚ƒ\nÏƒ : Râ‚ â†’+* Râ‚‚\nÏƒ' : Râ‚‚ â†’+* Râ‚\ninstâœ : RingHomInvPair Ïƒ Ïƒ'\nx : Râ‚‚\nâŠ¢ Ïƒ (Ïƒ' x) = x"
    },
    {
      "name": "SemiNormedGrp.explicitCokernelIso_hom_Ï€",
      "statement": "X Y : SemiNormedGrp\nf : X âŸ¶ Y\nâŠ¢ explicitCokernelÏ€ f â‰« (explicitCokernelIso f).hom = cokernel.Ï€ f"
    },
    {
      "name": "SemiconjBy.add_left",
      "statement": "Î± : Type u\nÎ² : Type v\nÎ³ : Type w\nR : Type x\ninstâœ : Distrib R\na b x y : R\nha : SemiconjBy a x y\nhb : SemiconjBy b x y\nâŠ¢ SemiconjBy (a + b) x y"
    },
    {
      "name": "SemiconjBy.inv_symm_left_iffâ‚€",
      "statement": "Î± : Type u_1\nMâ‚€ : Type u_2\nGâ‚€ : Type u_3\nMâ‚€' : Type u_4\nGâ‚€' : Type u_5\nF : Type u_6\nF' : Type u_7\ninstâœ : GroupWithZero Gâ‚€\na x y x' y' : Gâ‚€\nha : a = 0\nâŠ¢ SemiconjBy aâ»Â¹ x y â†” SemiconjBy a y x"
    },
    {
      "name": "SemiconjBy.one_right",
      "statement": "S : Type u_1\nM : Type u_2\nG : Type u_3\ninstâœ : MulOneClass M\na : M\nâŠ¢ SemiconjBy a 1 1"
    },
    {
      "name": "SemiconjBy.pow_right",
      "statement": "S : Type u_1\nM : Type u_2\nG : Type u_3\ninstâœ : Monoid M\na x y : M\nh : SemiconjBy a x y\nn : â„•\nâŠ¢ SemiconjBy a (x ^ n) (y ^ n)"
    },
    {
      "name": "SemidirectProduct.map_inr",
      "statement": "N : Type u_1\nG : Type u_2\nH : Type u_3\ninstâœâ´ : Group N\ninstâœÂ³ : Group G\ninstâœÂ² : Group H\nÏ† : G â†’* MulAut N\nNâ‚ : Type u_4\nGâ‚ : Type u_5\ninstâœÂ¹ : Group Nâ‚\ninstâœ : Group Gâ‚\nÏ†â‚ : Gâ‚ â†’* MulAut Nâ‚\nfâ‚ : N â†’* Nâ‚\nfâ‚‚ : G â†’* Gâ‚\nh : âˆ€ (g : G), fâ‚.comp (MulEquiv.toMonoidHom (Ï† g)) = (MulEquiv.toMonoidHom (Ï†â‚ (fâ‚‚ g))).comp fâ‚\ng : G\nâŠ¢ (map fâ‚ fâ‚‚ h) (inr g) = inr (fâ‚‚ g)"
    },
    {
      "name": "Seminorm.ball_eq_emptyset",
      "statement": "R : Type u_1\nR' : Type u_2\nğ•œ : Type u_3\nğ•œâ‚‚ : Type u_4\nğ•œâ‚ƒ : Type u_5\nğ• : Type u_6\nE : Type u_7\nEâ‚‚ : Type u_8\nEâ‚ƒ : Type u_9\nF : Type u_10\nG : Type u_11\nÎ¹ : Type u_12\ninstâœâ¶ : SeminormedRing ğ•œ\ninstâœâµ : AddCommGroup E\ninstâœâ´ : Module ğ•œ E\ninstâœÂ³ : SeminormedRing ğ•œâ‚‚\ninstâœÂ² : AddCommGroup Eâ‚‚\ninstâœÂ¹ : Module ğ•œâ‚‚ Eâ‚‚\nÏƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\npâœ p : Seminorm ğ•œ E\nx : E\nr : â„\nhr : r â‰¤ 0\nâŠ¢ p.ball x r = âˆ…"
    },
    {
      "name": "Seminorm.neg_ball",
      "statement": "R : Type u_1\nR' : Type u_2\nğ•œ : Type u_3\nğ•œâ‚‚ : Type u_4\nğ•œâ‚ƒ : Type u_5\nğ• : Type u_6\nE : Type u_7\nEâ‚‚ : Type u_8\nEâ‚ƒ : Type u_9\nF : Type u_10\nG : Type u_11\nÎ¹ : Type u_12\ninstâœâ¶ : SeminormedRing ğ•œ\ninstâœâµ : AddCommGroup E\ninstâœâ´ : Module ğ•œ E\ninstâœÂ³ : SeminormedRing ğ•œâ‚‚\ninstâœÂ² : AddCommGroup Eâ‚‚\ninstâœÂ¹ : Module ğ•œâ‚‚ Eâ‚‚\nÏƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\npâœ p : Seminorm ğ•œ E\nr : â„\nx : E\nâŠ¢ -p.ball x r = p.ball (-x) r"
    },
    {
      "name": "Set.Countable.image",
      "statement": "Î± : Type u\nÎ² : Type v\nÎ³ : Type w\nÎ¹ : Sort x\ns : Set Î±\nhs : s.Countable\nf : Î± â†’ Î²\nâŠ¢ (f '' s).Countable"
    },
    {
      "name": "Set.Definable.inter",
      "statement": "M : Type w\nA : Set M\nL : Language\ninstâœ : L.Structure M\nÎ± : Type uâ‚\nÎ² : Type u_1\nB : Set M\ns f g : Set (Î± â†’ M)\nhf : A.Definable L f\nhg : A.Definable L g\nâŠ¢ A.Definable L (f âˆ© g)"
    },
    {
      "name": "Set.Finite.toFinset_eq_toFinset",
      "statement": "Î± : Type u\nÎ² : Type v\nÎ¹ : Sort w\nÎ³ : Type x\ns : Set Î±\ninstâœ : Fintype â†‘s\nh : s.Finite\nâŠ¢ h.toFinset = s.toFinset"
    },
    {
      "name": "Set.Icc.one_sub_le_one",
      "statement": "Î± : Type u_1\ninstâœÂ¹ : OrderedSemiring Î±\nÎ² : Type u_2\ninstâœ : OrderedRing Î²\nx : â†‘(Icc 0 1)\nâŠ¢ 1 - â†‘x â‰¤ 1"
    },
    {
      "name": "Set.Icc_eq_singleton_iff",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\ninstâœ : PartialOrder Î±\na b c : Î±\nâŠ¢ Icc a b = {c} â†” a = c âˆ§ b = c"
    },
    {
      "name": "Set.Ici_diff_Ici",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\ninstâœ : LinearOrder Î±\na aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±\nâŠ¢ Ici a \\ Ici b = Ico a b"
    },
    {
      "name": "Set.Ico_disjoint_Ico",
      "statement": "Î¹ : Sort u\nÎ± : Type v\nÎ² : Type w\ninstâœ : LinearOrder Î±\naâ‚ aâ‚‚ bâ‚ bâ‚‚ : Î±\nâŠ¢ Disjoint (Ico aâ‚ aâ‚‚) (Ico bâ‚ bâ‚‚) â†” min aâ‚‚ bâ‚‚ â‰¤ max aâ‚ bâ‚"
    },
    {
      "name": "Set.Iic.coe_iSup",
      "statement": "Î¹ : Sort u_1\nÎ± : Type u_2\ns : Set Î±\ninstâœ : CompleteLattice Î±\na : Î±\nS : Set â†‘(Iic a)\nf : Î¹ â†’ â†‘(Iic a)\np : Î¹ â†’ Prop\nâŠ¢ â†‘(â¨† i, f i) = â¨† i, â†‘(f i)"
    },
    {
      "name": "Set.Ioc_union_Ioc_left",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : LinearOrder Î±\ninstâœ : LinearOrder Î²\nf : Î± â†’ Î²\na aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±\nâŠ¢ Ioc a c âˆª Ioc b c = Ioc (min a b) c"
    },
    {
      "name": "Set.Ioc_union_Ioc_union_Ioc_cycle",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : LinearOrder Î±\ninstâœ : LinearOrder Î²\nf : Î± â†’ Î²\na aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±\nâŠ¢ Ioc a b âˆª Ioc b c âˆª Ioc c a = Ioc (min a (min b c)) (max a (max b c))"
    },
    {
      "name": "Set.Ioi_subset_Ici_iff",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : LinearOrder Î±\na aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±\ninstâœ : DenselyOrdered Î±\nâŠ¢ Ioi b âŠ† Ici a â†” a â‰¤ b"
    },
    {
      "name": "Set.biUnion_pair",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ¹ : Sort u_4\nÎ¹' : Sort u_5\nÎ¹â‚‚ : Sort u_6\nÎº : Î¹ â†’ Sort u_7\nÎºâ‚ : Î¹ â†’ Sort u_8\nÎºâ‚‚ : Î¹ â†’ Sort u_9\nÎº' : Î¹' â†’ Sort u_10\na b : Î±\ns : Î± â†’ Set Î²\nâŠ¢ â‹ƒ x âˆˆ {a, b}, s x = s a âˆª s b"
    },
    {
      "name": "Set.comp_rangeSplitting",
      "statement": "Î± : Type u\nÎ² : Type v\nÎ³ : Type w\nf : Î± â†’ Î²\nâŠ¢ f âˆ˜ rangeSplitting f = Subtype.val"
    },
    {
      "name": "Set.countable_iUnion",
      "statement": "Î± : Type u\nÎ² : Type v\nÎ³ : Type w\nÎ¹ : Sort x\nt : Î¹ â†’ Set Î±\ninstâœ : Countable Î¹\nht : âˆ€ (i : Î¹), (t i).Countable\nâŠ¢ (â‹ƒ i, t i).Countable"
    },
    {
      "name": "Set.disjoint_pi",
      "statement": "Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u_2\nÎ² : Î¹ â†’ Type u_3\ns sâ‚ sâ‚‚ : Set Î¹\nt tâ‚ tâ‚‚ : (i : Î¹) â†’ Set (Î± i)\ni : Î¹\ninstâœ : âˆ€ (i : Î¹), Nonempty (Î± i)\nâŠ¢ Disjoint (s.pi tâ‚) (s.pi tâ‚‚) â†” âˆƒ i âˆˆ s, Disjoint (tâ‚ i) (tâ‚‚ i)"
    },
    {
      "name": "Set.div_mem_center",
      "statement": "M : Type u_1\ninstâœ : DivisionMonoid M\na b : M\nha : a âˆˆ center M\nhb : b âˆˆ center M\nâŠ¢ a / b âˆˆ center M"
    },
    {
      "name": "Set.encard_eq_zero",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\ns t : Set Î±\nâŠ¢ s.encard = 0 â†” s = âˆ…"
    },
    {
      "name": "Set.encard_pos",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\ns t : Set Î±\nâŠ¢ 0 < s.encard â†” s.Nonempty"
    },
    {
      "name": "Set.eqOn_univ",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ¹ : Sort u_4\nÏ€ : Î± â†’ Type u_5\ns sâ‚ sâ‚‚ : Set Î±\nt tâ‚ tâ‚‚ : Set Î²\np : Set Î³\nf fâ‚âœ fâ‚‚âœ fâ‚ƒ : Î± â†’ Î²\ng gâ‚ gâ‚‚ : Î² â†’ Î³\nf' fâ‚' fâ‚‚' : Î² â†’ Î±\ng' : Î³ â†’ Î²\na : Î±\nb : Î²\nfâ‚ fâ‚‚ : Î± â†’ Î²\nâŠ¢ EqOn fâ‚ fâ‚‚ univ â†” fâ‚ = fâ‚‚"
    },
    {
      "name": "Set.iUnion_Ico_eq_Iio_self_iff",
      "statement": "Î¹ : Sort u\nÎ± : Type v\nÎ² : Type w\ninstâœ : LinearOrder Î±\naâ‚ aâ‚‚ bâ‚ bâ‚‚ : Î±\nf : Î¹ â†’ Î±\na : Î±\nâŠ¢ â‹ƒ i, Ico (f i) a = Iio a â†” âˆ€ x < a, âˆƒ i, f i â‰¤ x"
    },
    {
      "name": "Set.image2_congr",
      "statement": "Î± : Type u_1\nÎ±' : Type u_2\nÎ² : Type u_3\nÎ²' : Type u_4\nÎ³ : Type u_5\nÎ³' : Type u_6\nÎ´ : Type u_7\nÎ´' : Type u_8\nÎµ : Type u_9\nÎµ' : Type u_10\nÎ¶ : Type u_11\nÎ¶' : Type u_12\nÎ½ : Type u_13\nf f' : Î± â†’ Î² â†’ Î³\ng g' : Î± â†’ Î² â†’ Î³ â†’ Î´\ns s' : Set Î±\nt t' : Set Î²\nu u' : Set Î³\nv : Set Î´\na a' : Î±\nb b' : Î²\nc c' : Î³\nd d' : Î´\nh : âˆ€ a âˆˆ s, âˆ€ b âˆˆ t, f a b = f' a b\nâŠ¢ image2 f s t = image2 f' s t"
    },
    {
      "name": "Set.image_add_const_uIcc",
      "statement": "Î± : Type u_1\ninstâœ : LinearOrderedAddCommGroup Î±\na b c d : Î±\nâŠ¢ (fun x => x + a) '' [[b, c]] = [[b + a, c + a]]"
    },
    {
      "name": "Set.image_const_sub_Icc",
      "statement": "Î± : Type u_1\ninstâœ : OrderedAddCommGroup Î±\na b c : Î±\nâŠ¢ (fun x => a - x) '' Icc b c = Icc (a - c) (a - b)"
    },
    {
      "name": "Set.image_const_sub_uIcc",
      "statement": "Î± : Type u_1\ninstâœ : LinearOrderedAddCommGroup Î±\na b c d : Î±\nâŠ¢ (fun x => a - x) '' [[b, c]] = [[a - b, a - c]]"
    },
    {
      "name": "Set.image_eq",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nf : Î± â†’ Î²\ns : Set Î±\nâŠ¢ f '' s = (Function.graph f).image s"
    },
    {
      "name": "Set.image_fst_graphOn",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ¹ : Sort u_4\nÏ€ : Î± â†’ Type u_5\nsâœ sâ‚ sâ‚‚ : Set Î±\nt tâ‚ tâ‚‚ : Set Î²\np : Set Î³\nfâœ fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²\ng gâ‚ gâ‚‚ : Î² â†’ Î³\nf' fâ‚' fâ‚‚' : Î² â†’ Î±\ng' : Î³ â†’ Î²\na : Î±\nb : Î²\nf : Î± â†’ Î²\ns : Set Î±\nâŠ¢ Prod.fst '' graphOn f s = s"
    },
    {
      "name": "Set.image_id_eq",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ¹ : Sort u_4\nÎ¹' : Sort u_5\nf : Î± â†’ Î²\ns t : Set Î±\nâŠ¢ image id = id"
    },
    {
      "name": "Set.image_inf_prod",
      "statement": "F : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ³ : SemilatticeInf Î±\ninstâœÂ² : SemilatticeInf Î²\ninstâœÂ¹ : FunLike F Î± Î²\ninstâœ : InfHomClass F Î± Î²\nsâœ sâ‚ sâ‚‚ tâœ tâ‚ tâ‚‚ u v : Set Î±\na b c : Î±\ns t : Set Î±\nthis : (uncurry fun x x_1 => x âŠ“ x_1) '' s Ã—Ë¢ t = image2 (fun x x_1 => x âŠ“ x_1) s t\nâŠ¢ image2 (fun x x_1 => x âŠ“ x_1) s t = s âŠ¼ t"
    },
    {
      "name": "Set.insert_subset_insert_iff",
      "statement": "Î± : Type u\nÎ² : Type v\nÎ³ : Type w\nÎ¹ : Sort x\na b : Î±\ns sâ‚ sâ‚‚ t tâ‚ tâ‚‚ u : Set Î±\nha : a âˆ‰ s\nâŠ¢ insert a s âŠ† insert a t â†” s âŠ† t"
    },
    {
      "name": "Set.inv_mem_center",
      "statement": "M : Type u_1\ninstâœ : DivisionMonoid M\na : M\nha : a âˆˆ center M\nâŠ¢ aâ»Â¹ âˆˆ center M"
    },
    {
      "name": "Set.inv_mem_inv",
      "statement": "F : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\ninstâœ : InvolutiveInv Î±\ns t : Set Î±\na : Î±\nâŠ¢ aâ»Â¹ âˆˆ sâ»Â¹ â†” a âˆˆ s"
    },
    {
      "name": "Set.inv_op_smul_set_distribâ‚€",
      "statement": "F : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\ninstâœÂ¹ : GroupWithZero Î±\ninstâœ : MulAction Î± Î²\nsâœ t : Set Î²\naâœ a : Î±\ns : Set Î±\nâŠ¢ (op a â€¢ s)â»Â¹ = aâ»Â¹ â€¢ sâ»Â¹"
    },
    {
      "name": "Set.isUnit_iff",
      "statement": "F : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\ninstâœ : DivisionMonoid Î±\ns t : Set Î±\nâŠ¢ IsUnit s â†” âˆƒ a, s = {a} âˆ§ IsUnit a"
    },
    {
      "name": "Set.ite_empty_right",
      "statement": "Î± : Type u\nÎ² : Type v\nÎ³ : Type w\nÎ¹ : Sort x\na b : Î±\nsâœ sâ‚ sâ‚‚ tâœ tâ‚ tâ‚‚ u t s : Set Î±\nâŠ¢ t.ite s âˆ… = s âˆ© t"
    },
    {
      "name": "Set.le_einfsep_pair",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\ninstâœ : EDist Î±\nx y : Î±\ns t : Set Î±\nâŠ¢ edist x y âŠ“ edist y x â‰¤ {x, y}.einfsep"
    },
    {
      "name": "Set.left_mem_Ioc",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\ninstâœ : Preorder Î±\na aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±\nâŠ¢ a âˆˆ Ioc a b â†” False"
    },
    {
      "name": "Set.ncard_eq_one",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\ns t : Set Î±\nf : Î± â†’ Î²\nâŠ¢ s.ncard = 1 â†” âˆƒ a, s = {a}"
    },
    {
      "name": "Set.ncard_univ",
      "statement": "Î±âœ : Type u_1\nÎ² : Type u_2\ns t : Set Î±âœ\nÎ± : Type u_3\nâŠ¢ univ.ncard = Nat.card Î±"
    },
    {
      "name": "Set.neg_mem_center",
      "statement": "M : Type u_1\ninstâœ : NonUnitalNonAssocRing M\na : M\nha : a âˆˆ center M\nxâœ : M\nâŠ¢ -a * xâœ = xâœ * -a"
    },
    {
      "name": "Set.nonempty_iUnion",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ¹ : Sort u_4\nÎ¹' : Sort u_5\nÎ¹â‚‚ : Sort u_6\nÎº : Î¹ â†’ Sort u_7\nÎºâ‚ : Î¹ â†’ Sort u_8\nÎºâ‚‚ : Î¹ â†’ Sort u_9\nÎº' : Î¹' â†’ Sort u_10\ns : Î¹ â†’ Set Î±\nâŠ¢ (â‹ƒ i, s i).Nonempty â†” âˆƒ i, (s i).Nonempty"
    },
    {
      "name": "Set.one_mem_center",
      "statement": "M : Type u_1\ninstâœ : MulOneClass M\nxâœ : M\nâŠ¢ 1 * xâœ = xâœ * 1"
    },
    {
      "name": "Set.pairwise_univ",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ¹ : Type u_4\nÎ¹' : Type u_5\nr p q : Î± â†’ Î± â†’ Prop\nf g : Î¹ â†’ Î±\ns t u : Set Î±\na b : Î±\nâŠ¢ univ.Pairwise r â†” Pairwise r"
    },
    {
      "name": "Set.piecewise_empty",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ¹ : Sort u_4\nÏ€ : Î± â†’ Type u_5\nÎ´ : Î± â†’ Sort u_6\ns : Set Î±\nf g : (i : Î±) â†’ Î´ i\ninstâœ : (i : Î±) â†’ Decidable (i âˆˆ âˆ…)\nâŠ¢ âˆ….piecewise f g = g"
    },
    {
      "name": "Set.preimage_const_add_Icc",
      "statement": "Î± : Type u_1\ninstâœ : OrderedAddCommGroup Î±\na b c : Î±\nâŠ¢ (fun x => a + x) â»Â¹' Icc b c = Icc (b - a) (c - a)"
    },
    {
      "name": "Set.preimage_const_sub_Icc",
      "statement": "Î± : Type u_1\ninstâœ : OrderedAddCommGroup Î±\na b c : Î±\nâŠ¢ (fun x => a - x) â»Â¹' Icc b c = Icc (a - c) (a - b)"
    },
    {
      "name": "Set.preimage_const_sub_uIcc",
      "statement": "Î± : Type u_1\ninstâœ : LinearOrderedAddCommGroup Î±\na b c d : Î±\nâŠ¢ (fun x => a - x) â»Â¹' [[b, c]] = [[a - b, a - c]]"
    },
    {
      "name": "Set.preimage_injective",
      "statement": "Î± : Type u\nÎ² : Type v\nf : Î± â†’ Î²\nâŠ¢ Injective (preimage f) â†” Surjective f"
    },
    {
      "name": "Set.preimage_mul_const_Ioo",
      "statement": "Î± : Type u_1\ninstâœ : LinearOrderedField Î±\naâœ a b c : Î±\nh : 0 < c\nâŠ¢ (fun x => x * c) â»Â¹' Ioo a b = Ioo (a / c) (b / c)"
    },
    {
      "name": "Set.preimage_singleton_true",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ¹ : Sort u_4\nÎ¹' : Sort u_5\nf : Î± â†’ Î²\ng : Î² â†’ Î³\np : Î± â†’ Prop\nâŠ¢ p â»Â¹' {True} = {a | p a}"
    },
    {
      "name": "Set.preimage_sub_const_Icc",
      "statement": "Î± : Type u_1\ninstâœ : OrderedAddCommGroup Î±\na b c : Î±\nâŠ¢ (fun x => x - a) â»Â¹' Icc b c = Icc (b + a) (c + a)"
    },
    {
      "name": "Set.preimage_subset_preimage_iff",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ¹ : Sort u_4\nÎ¹' : Sort u_5\nfâœ : Î¹ â†’ Î±\nsâœ tâœ s t : Set Î±\nf : Î² â†’ Î±\nhs : s âŠ† range f\nâŠ¢ f â»Â¹' s âŠ† f â»Â¹' t â†” s âŠ† t"
    },
    {
      "name": "Set.preimage_surjective",
      "statement": "Î± : Type u\nÎ² : Type v\nf : Î± â†’ Î²\nâŠ¢ Surjective (preimage f) â†” Injective f"
    },
    {
      "name": "Set.sized_iUnion",
      "statement": "Î± : Type u_1\nÎ¹ : Sort u_2\nÎº : Î¹ â†’ Sort u_3\nA B : Set (Finset Î±)\ns : Finset Î±\nr : â„•\nf : Î¹ â†’ Set (Finset Î±)\nâŠ¢ Sized r (â‹ƒ i, f i) â†” âˆ€ (i : Î¹), Sized r (f i)"
    },
    {
      "name": "Set.uIoc_of_le",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : LinearOrder Î±\ninstâœ : LinearOrder Î²\nf : Î± â†’ Î²\ns : Set Î±\na aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d x : Î±\nh : a â‰¤ b\nâŠ¢ Î™ a b = Ioc a b"
    },
    {
      "name": "SetLike.coe_list_dProd",
      "statement": "Î¹ : Type u_1\nR : Type u_2\nÎ± : Type u_3\nS : Type u_4\ninstâœÂ³ : SetLike S R\ninstâœÂ² : Monoid R\ninstâœÂ¹ : AddMonoid Î¹\nA : Î¹ â†’ S\ninstâœ : GradedMonoid A\nfÎ¹ : Î± â†’ Î¹\nfA : (a : Î±) â†’ â†¥(A (fÎ¹ a))\nl : List Î±\nâŠ¢ â†‘(l.dProd fÎ¹ fA) = (List.map (fun a => â†‘(fA a)) l).prod"
    },
    {
      "name": "SetLike.pow_mem_graded",
      "statement": "Î¹ : Type u_1\nR : Type u_2\nS : Type u_3\ninstâœÂ³ : SetLike S R\ninstâœÂ² : Monoid R\ninstâœÂ¹ : AddMonoid Î¹\nA : Î¹ â†’ S\ninstâœ : GradedMonoid A\nn : â„•\nr : R\ni : Î¹\nh : r âˆˆ A i\nâŠ¢ r ^ n âˆˆ A (n â€¢ i)"
    },
    {
      "name": "SetTheory.PGame.grundyValue_nim_add_nim",
      "statement": "n m : â„•\nâŠ¢ (nim â†‘n + nim â†‘m).grundyValue = â†‘(n ^^^ m)"
    },
    {
      "name": "SetTheory.PGame.invVal_isEmpty",
      "statement": "l r : Type u\nb : Bool\nL : l â†’ PGame\nR : r â†’ PGame\nIHl : l â†’ PGame\nIHr : r â†’ PGame\ni : InvTy l r b\ninstâœÂ¹ : IsEmpty l\ninstâœ : IsEmpty r\nâŠ¢ invVal L R IHl IHr i = 0"
    },
    {
      "name": "SetTheory.PGame.mul_moveRight_inl",
      "statement": "x y : PGame\ni : x.LeftMoves\nj : y.RightMoves\nâŠ¢ (x * y).moveRight (toRightMovesMul (Sum.inl (i, j))) =\n    x.moveLeft i * y + x * y.moveRight j - x.moveLeft i * y.moveRight j"
    },
    {
      "name": "SetTheory.PGame.star_fuzzy_zero",
      "statement": "xl xr : Type u\nâŠ¢ star â§ 0"
    },
    {
      "name": "SetTheory.PGame.toRightMovesNim_one_symm",
      "statement": "i : (nim 1).RightMoves\nâŠ¢ toRightMovesNim.symm i = âŸ¨0, â‹¯âŸ©"
    },
    {
      "name": "Shrink.ext",
      "statement": "Î± : Type v\ninstâœ : Small.{w, v} Î±\nx y : Shrink.{w, v} Î±\nw : (equivShrink Î±).symm x = (equivShrink Î±).symm y\nâŠ¢ x = y"
    },
    {
      "name": "SignType.nonneg_iff_ne_neg_one",
      "statement": "a : SignType\nâŠ¢ 0 â‰¤ a â†” a â‰  -1"
    },
    {
      "name": "SimpleGraph.Connected.ofBoxProdLeft",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nG : SimpleGraph Î±\nH : SimpleGraph Î²\nh : (G â–¡ H).Connected\nâŠ¢ G.Connected"
    },
    {
      "name": "SimpleGraph.Connected.ofBoxProdRight",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nG : SimpleGraph Î±\nH : SimpleGraph Î²\nh : (G â–¡ H).Connected\nâŠ¢ H.Connected"
    },
    {
      "name": "SimpleGraph.Subgraph.deleteEdges_inter_edgeSet_right_eq",
      "statement": "Î¹ : Sort u_1\nV : Type u\nW : Type v\nG : SimpleGraph V\nG' : G.Subgraph\ns : Set (Sym2 V)\nâŠ¢ G'.deleteEdges (s âˆ© G'.edgeSet) = G'.deleteEdges s"
    },
    {
      "name": "SimpleGraph.Subgraph.deleteVerts_inter_verts_set_right_eq",
      "statement": "Î¹ : Sort u_1\nV : Type u\nW : Type v\nG : SimpleGraph V\nG' : G.Subgraph\ns : Set V\nâŠ¢ G'.deleteVerts (s âˆ© G'.verts) = G'.deleteVerts s"
    },
    {
      "name": "SimpleGraph.Subgraph.iSup_adj",
      "statement": "Î¹ : Sort u_1\nV : Type u\nW : Type v\nG : SimpleGraph V\nGâ‚ Gâ‚‚ : G.Subgraph\na b : V\nf : Î¹ â†’ G.Subgraph\nâŠ¢ (â¨† i, f i).Adj a b â†” âˆƒ i, (f i).Adj a b"
    },
    {
      "name": "SimpleGraph.Subgraph.neighborSet_iSup",
      "statement": "Î¹ : Sort u_1\nV : Type u\nW : Type v\nG : SimpleGraph V\nGâ‚ Gâ‚‚ : G.Subgraph\na b : V\nf : Î¹ â†’ G.Subgraph\nv : V\nâŠ¢ (â¨† i, f i).neighborSet v = â‹ƒ i, (f i).neighborSet v"
    },
    {
      "name": "SimpleGraph.Subgraph.subgraphOfAdj_connected",
      "statement": "V : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\nv w : V\nhvw : G.Adj v w\nâŠ¢ (G.subgraphOfAdj hvw).Connected"
    },
    {
      "name": "SimpleGraph.TripartiteFromTriangles.locallyLinear",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nğ•œ : Type u_4\ninstâœÂ² : LinearOrderedField ğ•œ\nt : Finset (Î± Ã— Î² Ã— Î³)\na a' : Î±\nb b' : Î²\nc c' : Î³\nx : Î± Ã— Î² Ã— Î³\nÎµ : ğ•œ\ninstâœÂ¹ : ExplicitDisjoint t\ninstâœ : NoAccidental t\nâŠ¢ (graph t).LocallyLinear"
    },
    {
      "name": "SimpleGraph.Walk.dropUntil_copy",
      "statement": "V : Type u\nV' : Type v\nV'' : Type w\nG : SimpleGraph V\nG' : SimpleGraph V'\nG'' : SimpleGraph V''\nuâœ vâœ wâœ x y : V\ninstâœ : DecidableEq V\nu v w v' w' : V\np : G.Walk v w\nhv : v = v'\nhw : w = w'\nh : u âˆˆ (p.copy hv hw).support\nâŠ¢ u âˆˆ p.support"
    },
    {
      "name": "SimpleGraph.Walk.edges_map",
      "statement": "V : Type u\nV' : Type v\nV'' : Type w\nG : SimpleGraph V\nG' : SimpleGraph V'\nG'' : SimpleGraph V''\nf : G â†’g G'\nf' : G' â†’g G''\nu v u' v' : V\np : G.Walk u v\nâŠ¢ (Walk.map f p).edges = List.map (Sym2.map â‡‘f) p.edges"
    },
    {
      "name": "SimpleGraph.Walk.edges_transfer",
      "statement": "V : Type u\nV' : Type v\nV'' : Type w\nG : SimpleGraph V\nG' : SimpleGraph V'\nG'' : SimpleGraph V''\nu v : V\np : G.Walk u v\nH : SimpleGraph V\nhp : âˆ€ e âˆˆ p.edges, e âˆˆ H.edgeSet\nâŠ¢ (p.transfer H hp).edges = p.edges"
    },
    {
      "name": "SimpleGraph.Walk.exists_length_eq_zero_iff",
      "statement": "V : Type u\nV' : Type v\nV'' : Type w\nG : SimpleGraph V\nG' : SimpleGraph V'\nG'' : SimpleGraph V''\nu v : V\nâŠ¢ (âˆƒ p, p.length = 0) â†” u = v"
    },
    {
      "name": "SimpleGraph.Walk.length_edges",
      "statement": "V : Type u\nV' : Type v\nV'' : Type w\nG : SimpleGraph V\nG' : SimpleGraph V'\nG'' : SimpleGraph V''\nu v : V\np : G.Walk u v\nâŠ¢ p.edges.length = p.length"
    },
    {
      "name": "SimpleGraph.Walk.length_tail_add_one",
      "statement": "V : Type u\nV' : Type v\nV'' : Type w\nG : SimpleGraph V\nG' : SimpleGraph V'\nG'' : SimpleGraph V''\nu v w x y : V\np : G.Walk x y\nhp : Â¬p.Nil\nâŠ¢ (p.tail hp).length + 1 = p.length"
    },
    {
      "name": "SimpleGraph.Walk.map_map",
      "statement": "V : Type u\nV' : Type v\nV'' : Type w\nG : SimpleGraph V\nG' : SimpleGraph V'\nG'' : SimpleGraph V''\nf : G â†’g G'\nf' : G' â†’g G''\nu v u' v' : V\np : G.Walk u v\nâŠ¢ Walk.map f' (Walk.map f p) = Walk.map (f'.comp f) p"
    },
    {
      "name": "SimpleGraph.Walk.reverseAux_append",
      "statement": "V : Type u\nV' : Type v\nV'' : Type w\nG : SimpleGraph V\nG' : SimpleGraph V'\nG'' : SimpleGraph V''\nu v w x : V\np : G.Walk u v\nq : G.Walk u w\nr : G.Walk w x\nâŠ¢ (p.reverseAux q).append r = p.reverseAux (q.append r)"
    },
    {
      "name": "SimpleGraph.Walk.toDeleteEdges_copy",
      "statement": "V : Type u\nV' : Type v\nV'' : Type w\nG : SimpleGraph V\nG' : SimpleGraph V'\nG'' : SimpleGraph V''\nvâœ w v u u' v' : V\ns : Set (Sym2 V)\np : G.Walk u v\nhu : u = u'\nhv : v = v'\nh : âˆ€ e âˆˆ (p.copy hu hv).edges, e âˆ‰ s\nâŠ¢ âˆ€ e âˆˆ p.edges, e âˆ‰ s"
    },
    {
      "name": "SimpleGraph.chromaticNumber_ne_top_iff_exists",
      "statement": "V : Type u\nG : SimpleGraph V\nn : â„•\nÎ± : Type u_1\nÎ² : Type u_2\nC : G.Coloring Î±\nâŠ¢ G.chromaticNumber â‰  âŠ¤ â†” âˆƒ n, G.Colorable n"
    },
    {
      "name": "SimpleGraph.cliqueFinset_map_of_equiv",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nG H : SimpleGraph Î±\ninstâœâµ : Fintype Î±\ninstâœâ´ : DecidableEq Î±\ninstâœÂ³ : DecidableRel G.Adj\nnâœ : â„•\na b c : Î±\ns : Finset Î±\ninstâœÂ² : DecidableRel H.Adj\ninstâœÂ¹ : Fintype Î²\ninstâœ : DecidableEq Î²\ne : Î± â‰ƒ Î²\nn : â„•\nâŠ¢ â†‘((SimpleGraph.map e.toEmbedding G).cliqueFinset n) =\n    â†‘(map { toFun := map e.toEmbedding, inj' := â‹¯ } (G.cliqueFinset n))"
    },
    {
      "name": "SimpleGraph.cliqueSet_map_of_equiv",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nGâœ H : SimpleGraph Î±\nnâœ : â„•\na b c : Î±\ns : Finset Î±\nG : SimpleGraph Î±\ne : Î± â‰ƒ Î²\nn : â„•\nâŠ¢ (SimpleGraph.map e.toEmbedding G).cliqueSet n = map e.toEmbedding '' G.cliqueSet n"
    },
    {
      "name": "SimpleGraph.dist_eq_zero_of_not_reachable",
      "statement": "V : Type u_1\nG : SimpleGraph V\nu v : V\nh : Â¬G.Reachable u v\nâŠ¢ G.dist u v = 0"
    },
    {
      "name": "SimpleGraph.exists_maximal_degree_vertex",
      "statement": "V : Type u_1\nG : SimpleGraph V\ne : Sym2 V\ninstâœÂ² : Fintype V\ninstâœÂ¹ : DecidableRel G.Adj\ninstâœ : Nonempty V\nâŠ¢ âˆƒ v, G.maxDegree = G.degree v"
    },
    {
      "name": "SimpleGraph.isEmpty_of_colorable_zero",
      "statement": "V : Type u\nG : SimpleGraph V\nn : â„•\nÎ± : Type u_1\nÎ² : Type u_2\nC : G.Coloring Î±\nh : G.Colorable 0\nâŠ¢ IsEmpty V"
    },
    {
      "name": "SimpleGraph.locallyLinear_comap",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nğ•œ : Type u_3\ninstâœ : LinearOrderedField ğ•œ\nGâœ H : SimpleGraph Î±\nÎµ Î´ : ğ•œ\nn : â„•\ns : Finset Î±\nG : SimpleGraph Î²\ne : Î± â‰ƒ Î²\nâŠ¢ (SimpleGraph.comap (â‡‘e) G).LocallyLinear â†” G.LocallyLinear"
    },
    {
      "name": "SimpleGraph.map_singletonSubgraph",
      "statement": "Î¹ : Sort u_1\nV : Type u\nW : Type v\nG : SimpleGraph V\nG' : SimpleGraph W\nf : G â†’g G'\nv : V\nâŠ¢ Subgraph.map f (G.singletonSubgraph v) = G'.singletonSubgraph (f v)"
    },
    {
      "name": "SimpleGraph.mem_incidence_iff_neighbor",
      "statement": "Î¹ : Sort u_1\nV : Type u\nG : SimpleGraph V\na b c u vâœ wâœ : V\ne : Sym2 V\nv w : V\nâŠ¢ s(v, w) âˆˆ G.incidenceSet v â†” w âˆˆ G.neighborSet v"
    },
    {
      "name": "SimpleGraph.singletonSubgraph_le_iff",
      "statement": "Î¹ : Sort u_1\nV : Type u\nW : Type v\nG : SimpleGraph V\nG' : SimpleGraph W\nv : V\nH : G.Subgraph\nâŠ¢ G.singletonSubgraph v â‰¤ H â†” v âˆˆ H.verts"
    },
    {
      "name": "SimpleGraph.top_preconnected",
      "statement": "V : Type u\nV' : Type v\nV'' : Type w\nG : SimpleGraph V\nG' : SimpleGraph V'\nG'' : SimpleGraph V''\nx y : V\nâŠ¢ âŠ¤.Reachable x y"
    },
    {
      "name": "SimpleGraph.turanGraph_eq_top",
      "statement": "V : Type u_1\ninstâœÂ² : Fintype V\ninstâœÂ¹ : DecidableEq V\nG : SimpleGraph V\ninstâœ : DecidableRel G.Adj\nn r : â„•\nH : SimpleGraph V\nâŠ¢ turanGraph n r = âŠ¤ â†” r = 0 âˆ¨ n â‰¤ r"
    },
    {
      "name": "SimplexCategory.eq_Ïƒ_of_epi",
      "statement": "n : â„•\nÎ¸ : [n + 1] âŸ¶ [n]\ninstâœ : Epi Î¸\nâŠ¢ âˆƒ i, Î¸ = Ïƒ i"
    },
    {
      "name": "SimplexCategory.len_le_of_epi",
      "statement": "x y : SimplexCategory\nf : x âŸ¶ y\nâŠ¢ Epi f â†’ y.len â‰¤ x.len"
    },
    {
      "name": "SimplicialObject.Splitting.Ï€Summand_comp_cofan_inj_id_comp_PInfty_eq_PInfty",
      "statement": "C : Type u_1\ninstâœÂ¹ : Category.{u_2, u_1} C\nX : SimplicialObject C\ns : Splitting X\ninstâœ : Preadditive C\nn : â„•\nâŠ¢ s.Ï€Summand (IndexSet.id { unop := [n] }) â‰« (s.cofan { unop := [n] }).inj (IndexSet.id { unop := [n] }) â‰« PInfty.f n =\n    PInfty.f n"
    },
    {
      "name": "StieltjesFunction.length_Ioc",
      "statement": "f : StieltjesFunction\na b : â„\nâŠ¢ f.length (Ioc a b) = ofReal (â†‘f b - â†‘f a)"
    },
    {
      "name": "StieltjesFunction.measure_Icc",
      "statement": "f : StieltjesFunction\na b : â„\nâŠ¢ f.measure (Icc a b) = ofReal (â†‘f b - leftLim (â†‘f) a)"
    },
    {
      "name": "StieltjesFunction.outer_Ioc",
      "statement": "f : StieltjesFunction\na b : â„\nâŠ¢ f.outer (Ioc a b) = ofReal (â†‘f b - â†‘f a)"
    },
    {
      "name": "Stream'.Seq1.ret_bind",
      "statement": "Î± : Type u\nÎ² : Type v\nÎ³ : Type w\na : Î±\nf : Î± â†’ Seq1 Î²\nâŠ¢ (ret a).bind f = f a"
    },
    {
      "name": "Stream'.WSeq.bind_assoc",
      "statement": "Î± : Type u\nÎ² : Type v\nÎ³ : Type w\ns : WSeq Î±\nf : Î± â†’ WSeq Î²\ng : Î² â†’ WSeq Î³\nâŠ¢ (s.bind f).bind g ~Ê· s.bind fun x => (f x).bind g"
    },
    {
      "name": "Stream'.WSeq.bind_ret",
      "statement": "Î± : Type u\nÎ² : Type v\nÎ³ : Type w\nf : Î± â†’ Î²\ns : WSeq Î±\nâŠ¢ s.bind (ret âˆ˜ f) ~Ê· map f s"
    },
    {
      "name": "Stream'.WSeq.join_append",
      "statement": "Î± : Type u\nÎ² : Type v\nÎ³ : Type w\nS T : WSeq (WSeq Î±)\nâŠ¢ (S.append T).join ~Ê· S.join.append T.join"
    },
    {
      "name": "Stream'.WSeq.mem_think",
      "statement": "Î± : Type u\nÎ² : Type v\nÎ³ : Type w\ns : WSeq Î±\na : Î±\nâŠ¢ a âˆˆ s.think â†” a âˆˆ s"
    },
    {
      "name": "Stream'.WSeq.tail_cons",
      "statement": "Î± : Type u\nÎ² : Type v\nÎ³ : Type w\na : Î±\ns : WSeq Î±\nâŠ¢ (cons a s).tail = s"
    },
    {
      "name": "Stream'.dropLast_take",
      "statement": "Î± : Type u\nÎ² : Type v\nÎ´ : Type w\nn : â„•\nxs : Stream' Î±\nâŠ¢ (take n xs).dropLast = take (n - 1) xs"
    },
    {
      "name": "Stream'.get_inits",
      "statement": "Î± : Type u\nÎ² : Type v\nÎ´ : Type w\nâŠ¢ âˆ€ (n : â„•) (s : Stream' Î±), s.inits.get n = take n.succ s"
    },
    {
      "name": "Subfield.coe_sInf",
      "statement": "K : Type u\nL : Type v\nM : Type w\ninstâœÂ² : DivisionRing K\ninstâœÂ¹ : DivisionRing L\ninstâœ : DivisionRing M\nS : Set (Subfield K)\nâŠ¢ â†‘(sInf (toSubring '' S)) = â‹‚ s âˆˆ S, â†‘s"
    },
    {
      "name": "Subgroup.eq_top_of_card_eq",
      "statement": "G : Type u_1\ninstâœÂ² : Group G\nA : Type u_2\ninstâœÂ¹ : AddGroup A\nH K : Subgroup G\ninstâœ : Finite â†¥H\nh : Nat.card â†¥H = Nat.card G\nâŠ¢ H = âŠ¤"
    },
    {
      "name": "Subgroup.normalClosure_le_normal",
      "statement": "G : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninstâœâ´ : Group G\ninstâœÂ³ : Group G'\ninstâœÂ² : Group G''\nA : Type u_4\ninstâœÂ¹ : AddGroup A\ns : Set G\nN : Subgroup G\ninstâœ : N.Normal\nh : s âŠ† â†‘N\nâŠ¢ normalClosure s â‰¤ N"
    },
    {
      "name": "Subgroup.smul_inf",
      "statement": "Î± : Type u_1\nG : Type u_2\nA : Type u_3\nSâœ : Type u_4\ninstâœÂ³ : Group G\ninstâœÂ² : AddGroup A\ns : Set G\ninstâœÂ¹ : Group Î±\ninstâœ : MulDistribMulAction Î± G\na : Î±\nS T : Subgroup G\nâŠ¢ a â€¢ (S âŠ“ T) = a â€¢ S âŠ“ a â€¢ T"
    },
    {
      "name": "Subgroup.subtype_range",
      "statement": "G : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninstâœâµ : Group G\ninstâœâ´ : Group G'\ninstâœÂ³ : Group G''\nA : Type u_4\ninstâœÂ² : AddGroup A\nN : Type u_5\nP : Type u_6\ninstâœÂ¹ : Group N\ninstâœ : Group P\nK H : Subgroup G\nâŠ¢ H.subtype.range = H"
    },
    {
      "name": "Submodule.cardQuot_apply",
      "statement": "R : Type u_1\nM : Type u_2\ninstâœÂ² : Ring R\ninstâœÂ¹ : AddCommGroup M\ninstâœ : Module R M\nS : Submodule R M\nh : Fintype (M â§¸ S)\nâŠ¢ S.cardQuot = Fintype.card (M â§¸ S)"
    },
    {
      "name": "Submodule.comap_fst",
      "statement": "R : Type u\nK : Type u'\nM : Type v\nV : Type v'\nMâ‚‚ : Type w\nVâ‚‚ : Type w'\nMâ‚ƒ : Type y\nVâ‚ƒ : Type y'\nMâ‚„ : Type z\nÎ¹ : Type x\nMâ‚… : Type u_1\nMâ‚† : Type u_2\ninstâœâ´ : Semiring R\ninstâœÂ³ : AddCommMonoid M\ninstâœÂ² : AddCommMonoid Mâ‚‚\ninstâœÂ¹ : Module R M\ninstâœ : Module R Mâ‚‚\np : Submodule R M\nq : Submodule R Mâ‚‚\nâŠ¢ comap (fst R M Mâ‚‚) p = p.prod âŠ¤"
    },
    {
      "name": "Submodule.comm_trans_rTensorOne",
      "statement": "R : Type u\nS : Type v\ninstâœÂ² : CommSemiring R\ninstâœÂ¹ : Semiring S\ninstâœ : Algebra R S\nM N : Submodule R S\nâŠ¢ TensorProduct.comm R â†¥âŠ¥ â†¥M â‰ªâ‰«â‚— M.rTensorOne = M.lTensorOne"
    },
    {
      "name": "Submodule.ker_inclusion",
      "statement": "R : Type u_1\nRâ‚ : Type u_2\nRâ‚‚ : Type u_3\nRâ‚ƒ : Type u_4\nK : Type u_5\nM : Type u_6\nMâ‚ : Type u_7\nMâ‚‚ : Type u_8\nMâ‚ƒ : Type u_9\nV : Type u_10\nVâ‚‚ : Type u_11\ninstâœâ· : Semiring R\ninstâœâ¶ : Semiring Râ‚‚\ninstâœâµ : AddCommMonoid M\ninstâœâ´ : AddCommMonoid Mâ‚‚\ninstâœÂ³ : Module R M\ninstâœÂ² : Module Râ‚‚ Mâ‚‚\npâœ p'âœ : Submodule R M\nq : Submodule Râ‚‚ Mâ‚‚\nÏ„â‚â‚‚ : R â†’+* Râ‚‚\nF : Type u_12\ninstâœÂ¹ : FunLike F M Mâ‚‚\ninstâœ : SemilinearMapClass F Ï„â‚â‚‚ M Mâ‚‚\np p' : Submodule R M\nh : p â‰¤ p'\nâŠ¢ ker (inclusion h) = âŠ¥"
    },
    {
      "name": "Submodule.map_unop_one",
      "statement": "Î¹ : Sort uÎ¹\nR : Type u\ninstâœÂ² : CommSemiring R\nA : Type v\ninstâœÂ¹ : Semiring A\ninstâœ : Algebra R A\nS T : Set A\nM N P Q : Submodule R A\nm n : A\nâŠ¢ map (â†‘(opLinearEquiv R).symm) 1 = 1"
    },
    {
      "name": "Submodule.mem_dualAnnihilator",
      "statement": "R : Type u\nM : Type v\ninstâœÂ² : CommSemiring R\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : Module R M\nW : Submodule R M\nÏ† : Module.Dual R M\nâŠ¢ Ï† âˆˆ W.dualAnnihilator â†” âˆ€ w âˆˆ W, Ï† w = 0"
    },
    {
      "name": "Submodule.mulRightMap_apply_single",
      "statement": "R : Type u_1\nMâœ : Type u_2\nNâœ : Type u_3\ninstâœâ¹ : Semiring R\ninstâœâ¸ : AddCommMonoid Mâœ\ninstâœâ· : Module R Mâœ\ninstâœâ¶ : AddCommMonoid Nâœ\ninstâœâµ : Module R Nâœ\nS : Type u_4\ninstâœâ´ : Semiring S\ninstâœÂ³ : Module R S\ninstâœÂ² : SMulCommClass R R S\ninstâœÂ¹ : SMulCommClass R S S\ninstâœ : IsScalarTower R S S\nM N : Submodule R S\nÎ¹ : Type u_5\nn : Î¹ â†’ â†¥N\ni : Î¹\nm : â†¥M\nâŠ¢ (M.mulRightMap n) (Finsupp.single i m) = â†‘m * â†‘(n i)"
    },
    {
      "name": "Submodule.restrictScalars_mul",
      "statement": "Î¹ : Sort uÎ¹\nR : Type u\ninstâœâ¹ : CommSemiring R\nAâœ : Type v\ninstâœâ¸ : Semiring Aâœ\ninstâœâ· : Algebra R Aâœ\nS T : Set Aâœ\nM N P Q : Submodule R Aâœ\nm n : Aâœ\nA : Type u_1\nB : Type u_2\nC : Type u_3\ninstâœâ¶ : CommSemiring A\ninstâœâµ : CommSemiring B\ninstâœâ´ : Semiring C\ninstâœÂ³ : Algebra A B\ninstâœÂ² : Algebra A C\ninstâœÂ¹ : Algebra B C\ninstâœ : IsScalarTower A B C\nI J : Submodule B C\nâŠ¢ restrictScalars A (I * J) = restrictScalars A I * restrictScalars A J"
    },
    {
      "name": "Submodule.span_singleton_eq_bot",
      "statement": "R : Type u_1\nRâ‚‚ : Type u_2\nK : Type u_3\nM : Type u_4\nMâ‚‚ : Type u_5\nV : Type u_6\nS : Type u_7\ninstâœâ· : Semiring R\ninstâœâ¶ : AddCommMonoid M\ninstâœâµ : Module R M\nx : M\np p' : Submodule R M\ninstâœâ´ : Semiring Râ‚‚\nÏƒâ‚â‚‚ : R â†’+* Râ‚‚\ninstâœÂ³ : AddCommMonoid Mâ‚‚\ninstâœÂ² : Module Râ‚‚ Mâ‚‚\nF : Type u_8\ninstâœÂ¹ : FunLike F M Mâ‚‚\ninstâœ : SemilinearMapClass F Ïƒâ‚â‚‚ M Mâ‚‚\ns t : Set M\nâŠ¢ (âˆ€ x_1 âˆˆ {x}, x_1 = 0) â†” x = 0"
    },
    {
      "name": "Submodule.torsionBy_one",
      "statement": "R : Type u_1\nM : Type u_2\ninstâœÂ² : CommSemiring R\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : Module R M\ns : Set R\na : R\nxâœ : M\nh : xâœ âˆˆ torsionBy R M 1\nâŠ¢ xâœ âˆˆ âŠ¥"
    },
    {
      "name": "Submonoid.LocalizationMap.lift_of_comp",
      "statement": "M : Type u_1\ninstâœÂ² : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninstâœÂ¹ : CommMonoid N\nP : Type u_3\ninstâœ : CommMonoid P\nf : S.LocalizationMap N\ng : M â†’* P\nhg : âˆ€ (y : â†¥S), IsUnit (g â†‘y)\nj : N â†’* P\nâŠ¢ f.lift â‹¯ = j"
    },
    {
      "name": "Submonoid.LocalizationMap.map_mk'",
      "statement": "M : Type u_1\ninstâœÂ³ : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninstâœÂ² : CommMonoid N\nP : Type u_3\ninstâœÂ¹ : CommMonoid P\nf : S.LocalizationMap N\ng : M â†’* P\nhg : âˆ€ (y : â†¥S), IsUnit (g â†‘y)\nT : Submonoid P\nhy : âˆ€ (y : â†¥S), g â†‘y âˆˆ T\nQ : Type u_4\ninstâœ : CommMonoid Q\nk : T.LocalizationMap Q\nx : M\ny : â†¥S\nâŠ¢ (f.map hy k) (f.mk' x y) = k.mk' (g x) âŸ¨g â†‘y, â‹¯âŸ©"
    },
    {
      "name": "Submonoid.LocalizationMap.mk'_mul_cancel_right",
      "statement": "M : Type u_1\ninstâœÂ² : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninstâœÂ¹ : CommMonoid N\nP : Type u_3\ninstâœ : CommMonoid P\nf : S.LocalizationMap N\nx : M\ny : â†¥S\nâŠ¢ f.mk' (x * â†‘y) y = f.toMap x"
    },
    {
      "name": "Submonoid.coe_mul_self_eq",
      "statement": "Î± : Type u_1\nG : Type u_2\nM : Type u_3\nR : Type u_4\nA : Type u_5\ninstâœÂ¹ : Monoid M\ninstâœ : AddMonoid A\nsâœ t u : Set M\ns : Submonoid M\nâŠ¢ â†‘s * â†‘s = â†‘s"
    },
    {
      "name": "Submonoid.mul_leftInvEquiv",
      "statement": "M : Type u_1\ninstâœ : CommMonoid M\nS : Submonoid M\nhS : S â‰¤ IsUnit.submonoid M\nx : â†¥S.leftInv\nâŠ¢ â†‘x * â†‘((S.leftInvEquiv hS) x) = 1"
    },
    {
      "name": "Subsemiring.closure_addSubmonoid_closure",
      "statement": "R : Type u\nS : Type v\nT : Type w\ninstâœÂ² : NonAssocSemiring R\nM : Submonoid R\ninstâœÂ¹ : NonAssocSemiring S\ninstâœ : NonAssocSemiring T\ns : Set R\nâŠ¢ closure â†‘(AddSubmonoid.closure s) = closure s"
    },
    {
      "name": "Subspace.dual_finrank_eq",
      "statement": "K : Type u\nV : Type v\ninstâœÂ² : Field K\ninstâœÂ¹ : AddCommGroup V\ninstâœ : Module K V\nW : Subspace K V\nâŠ¢ finrank K (Module.Dual K V) = finrank K V"
    },
    {
      "name": "Subtype.coe_eq_top_iff",
      "statement": "Î± : Type u\nÎ² : Type v\nÎ³ : Type u_1\nÎ´ : Type u_2\np : Î± â†’ Prop\ninstâœÂ² : PartialOrder Î±\ninstâœÂ¹ : OrderTop Î±\ninstâœ : OrderTop (Subtype p)\nhtop : p âŠ¤\nx : { x // p x }\nâŠ¢ â†‘x = âŠ¤ â†” x = âŠ¤"
    },
    {
      "name": "Subtype.range_coe",
      "statement": "Î± : Type u_1\ns : Set Î±\nâŠ¢ range val = s"
    },
    {
      "name": "Sum.Lex.mono",
      "statement": "Î±âœ : Type u_1\nrâ‚ râ‚‚ : Î±âœ â†’ Î±âœ â†’ Prop\nÎ²âœ : Type u_2\nsâ‚ sâ‚‚ : Î²âœ â†’ Î²âœ â†’ Prop\nx y : Î±âœ âŠ• Î²âœ\nhr : âˆ€ (a b : Î±âœ), râ‚ a b â†’ râ‚‚ a b\nhs : âˆ€ (a b : Î²âœ), sâ‚ a b â†’ sâ‚‚ a b\nh : Lex râ‚ sâ‚ x y\nâŠ¢ Lex râ‚‚ sâ‚‚ x y"
    },
    {
      "name": "Sum.LiftRel.exists_of_isLeft_left",
      "statement": "Î± : Type u\nÎ±' : Type w\nÎ² : Type v\nÎ²' : Type x\nÎ³ : Type u_1\nÎ´ : Type u_2\nr : Î± â†’ Î³ â†’ Prop\ns : Î² â†’ Î´ â†’ Prop\nx : Î± âŠ• Î²\ny : Î³ âŠ• Î´\na : Î±\nb : Î²\nc : Î³\nd : Î´\nhâ‚ : LiftRel r s x y\nhâ‚‚ : x.isLeft = true\nâŠ¢ âˆƒ a c, r a c âˆ§ x = inl a âˆ§ y = inl c"
    },
    {
      "name": "Sum.LiftRel.isLeft_right",
      "statement": "Î± : Type u\nÎ±' : Type w\nÎ² : Type v\nÎ²' : Type x\nÎ³ : Type u_1\nÎ´ : Type u_2\nr : Î± â†’ Î³ â†’ Prop\ns : Î² â†’ Î´ â†’ Prop\nx : Î± âŠ• Î²\ny : Î³ âŠ• Î´\na : Î±\nb : Î²\nc : Î³\nd : Î´\nh : LiftRel r s (inl a) y\nâŠ¢ y.isLeft = true"
    },
    {
      "name": "Sum.denselyOrdered_iff",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\ninstâœÂ¹ : LT Î±\ninstâœ : LT Î²\nxâœ : DenselyOrdered (Î± âŠ• Î²)\na b : Î±\nh : a < b\nâŠ¢ âˆƒ a_1, a < a_1 âˆ§ a_1 < b"
    },
    {
      "name": "Sum.isRight_eq_false",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nx : Î± âŠ• Î²\nâŠ¢ x.isRight = false â†” x.isLeft = true"
    },
    {
      "name": "Sum.update_inl_apply_inl",
      "statement": "Î± : Type u\nÎ±' : Type w\nÎ² : Type v\nÎ²' : Type x\nÎ³ : Type u_1\nÎ´ : Type u_2\ninstâœÂ¹ : DecidableEq Î±\ninstâœ : DecidableEq (Î± âŠ• Î²)\nf : Î± âŠ• Î² â†’ Î³\ni j : Î±\nx : Î³\nâŠ¢ update f (inl i) x (inl j) = update (f âˆ˜ inl) i x j"
    },
    {
      "name": "Sylow.smul_eq_iff_mem_normalizer",
      "statement": "p : â„•\nG : Type u_1\ninstâœ : Group G\ng : G\nP : Sylow p G\nâŠ¢ g â€¢ P = P â†” g âˆˆ (â†‘P).normalizer"
    },
    {
      "name": "Sym.cons_of_coe_eq",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nn n' m : â„•\ns : Sym Î± n\naâœ b a : Î±\nv : Vector Î± n\nâŠ¢ â†‘(a ::â‚› ofVector v) = â†‘(ofVector (a ::áµ¥ v))"
    },
    {
      "name": "Sym.map_id",
      "statement": "Î±âœ : Type u_1\nÎ² : Type u_2\nnâœ n' m : â„•\nsâœ : Sym Î±âœ nâœ\na b : Î±âœ\nÎ± : Type u_3\nn : â„•\ns : Sym Î± n\nâŠ¢ map id s = s"
    },
    {
      "name": "Sym.ofVector_cons",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nn n' m : â„•\ns : Sym Î± n\naâœ b a : Î±\nv : Vector Î± n\nâŠ¢ ofVector (a ::áµ¥ v) = a ::â‚› ofVector v"
    },
    {
      "name": "Sym2.GameAdd.fst_snd",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nrÎ± : Î± â†’ Î± â†’ Prop\nrÎ² : Î² â†’ Î² â†’ Prop\na : Î±\nbâœ : Î²\naâ‚ aâ‚‚ b : Î±\nh : rÎ± aâ‚ aâ‚‚\nâŠ¢ GameAdd rÎ± s(aâ‚, b) s(b, aâ‚‚)"
    },
    {
      "name": "Symmetric.forall_existsUnique_iff'",
      "statement": "Î± : Sort u_1\nÎ² : Sort u_2\nr : Î± â†’ Î± â†’ Prop\nhr : Symmetric r\nâŠ¢ (âˆ€ (a : Î±), âˆƒ! b, r a b) â†” âˆƒ f, Involutive f âˆ§ r = fun x x_1 => f x = x_1"
    },
    {
      "name": "TensorPower.toTensorAlgebra_gMul",
      "statement": "R : Type u_1\nM : Type u_2\ninstâœÂ² : CommSemiring R\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : Module R M\ni j : â„•\na : â¨‚[R]^i M\nb : â¨‚[R]^j M\nâŠ¢ toTensorAlgebra (GradedMonoid.GMul.mul a b) = toTensorAlgebra a * toTensorAlgebra b"
    },
    {
      "name": "TensorProduct.LieModule.lie_tmul_right",
      "statement": "R : Type u\ninstâœÂ¹â¸ : CommRing R\nL : Type v\nM : Type w\nN : Type wâ‚\nP : Type wâ‚‚\nQ : Type wâ‚ƒ\ninstâœÂ¹â· : LieRing L\ninstâœÂ¹â¶ : LieAlgebra R L\ninstâœÂ¹âµ : AddCommGroup M\ninstâœÂ¹â´ : Module R M\ninstâœÂ¹Â³ : LieRingModule L M\ninstâœÂ¹Â² : LieModule R L M\ninstâœÂ¹Â¹ : AddCommGroup N\ninstâœÂ¹â° : Module R N\ninstâœâ¹ : LieRingModule L N\ninstâœâ¸ : LieModule R L N\ninstâœâ· : AddCommGroup P\ninstâœâ¶ : Module R P\ninstâœâµ : LieRingModule L P\ninstâœâ´ : LieModule R L P\ninstâœÂ³ : AddCommGroup Q\ninstâœÂ² : Module R Q\ninstâœÂ¹ : LieRingModule L Q\ninstâœ : LieModule R L Q\nx : L\nm : M\nn : N\nâŠ¢ (hasBracketAux x) (m âŠ—â‚œ[R] n) = â…x, mâ† âŠ—â‚œ[R] n + m âŠ—â‚œ[R] â…x, nâ†"
    },
    {
      "name": "TensorProduct.LieModule.liftLie_apply",
      "statement": "R : Type u\ninstâœÂ¹â¸ : CommRing R\nL : Type v\nM : Type w\nN : Type wâ‚\nP : Type wâ‚‚\nQ : Type wâ‚ƒ\ninstâœÂ¹â· : LieRing L\ninstâœÂ¹â¶ : LieAlgebra R L\ninstâœÂ¹âµ : AddCommGroup M\ninstâœÂ¹â´ : Module R M\ninstâœÂ¹Â³ : LieRingModule L M\ninstâœÂ¹Â² : LieModule R L M\ninstâœÂ¹Â¹ : AddCommGroup N\ninstâœÂ¹â° : Module R N\ninstâœâ¹ : LieRingModule L N\ninstâœâ¸ : LieModule R L N\ninstâœâ· : AddCommGroup P\ninstâœâ¶ : Module R P\ninstâœâµ : LieRingModule L P\ninstâœâ´ : LieModule R L P\ninstâœÂ³ : AddCommGroup Q\ninstâœÂ² : Module R Q\ninstâœÂ¹ : LieRingModule L Q\ninstâœ : LieModule R L Q\nf : M â†’â‚—â…R,Lâ† N â†’â‚—[R] P\nm : M\nn : N\nâŠ¢ ((liftLie R L M N P) f) (m âŠ—â‚œ[R] n) = (f m) n"
    },
    {
      "name": "TensorProduct.directSumLeft_tmul_lof",
      "statement": "R : Type u\ninstâœÂ¹â´ : CommSemiring R\nS : Type ?u.117055\ninstâœÂ¹Â³ : Semiring S\ninstâœÂ¹Â² : Algebra R S\nÎ¹â‚ : Type vâ‚\nÎ¹â‚‚ : Type vâ‚‚\ninstâœÂ¹Â¹ : DecidableEq Î¹â‚\ninstâœÂ¹â° : DecidableEq Î¹â‚‚\nMâ‚ : Î¹â‚ â†’ Type wâ‚\nMâ‚' : Type wâ‚'\nMâ‚‚ : Î¹â‚‚ â†’ Type wâ‚‚\nMâ‚‚' : Type wâ‚‚'\ninstâœâ¹ : (iâ‚ : Î¹â‚) â†’ AddCommMonoid (Mâ‚ iâ‚)\ninstâœâ¸ : AddCommMonoid Mâ‚'\ninstâœâ· : (iâ‚‚ : Î¹â‚‚) â†’ AddCommMonoid (Mâ‚‚ iâ‚‚)\ninstâœâ¶ : AddCommMonoid Mâ‚‚'\ninstâœâµ : (iâ‚ : Î¹â‚) â†’ Module R (Mâ‚ iâ‚)\ninstâœâ´ : Module R Mâ‚'\ninstâœÂ³ : (iâ‚‚ : Î¹â‚‚) â†’ Module R (Mâ‚‚ iâ‚‚)\ninstâœÂ² : Module R Mâ‚‚'\ninstâœÂ¹ : (iâ‚ : Î¹â‚) â†’ Module S (Mâ‚ iâ‚)\ninstâœ : âˆ€ (iâ‚ : Î¹â‚), IsScalarTower R S (Mâ‚ iâ‚)\ni : Î¹â‚\nx : Mâ‚ i\ny : Mâ‚‚'\nâŠ¢ (directSumLeft R Mâ‚ Mâ‚‚') ((lof R Î¹â‚ Mâ‚ i) x âŠ—â‚œ[R] y) = (lof R Î¹â‚ (fun i => Mâ‚ i âŠ—[R] Mâ‚‚') i) (x âŠ—â‚œ[R] y)"
    },
    {
      "name": "TensorProduct.gradedCommAux_comp_gradedCommAux",
      "statement": "R : Type u_1\nÎ¹ : Type u_2\nA : Type u_3\nB : Type u_4\ninstâœÂ¹Â¹ : CommSemiring Î¹\ninstâœÂ¹â° : Module Î¹ (Additive â„¤Ë£)\ninstâœâ¹ : DecidableEq Î¹\nğ’œ : Î¹ â†’ Type u_5\nâ„¬ : Î¹ â†’ Type u_6\ninstâœâ¸ : CommRing R\ninstâœâ· : (i : Î¹) â†’ AddCommGroup (ğ’œ i)\ninstâœâ¶ : (i : Î¹) â†’ AddCommGroup (â„¬ i)\ninstâœâµ : (i : Î¹) â†’ Module R (ğ’œ i)\ninstâœâ´ : (i : Î¹) â†’ Module R (â„¬ i)\ninstâœÂ³ : DirectSum.GRing ğ’œ\ninstâœÂ² : DirectSum.GRing â„¬\ninstâœÂ¹ : DirectSum.GAlgebra R ğ’œ\ninstâœ : DirectSum.GAlgebra R â„¬\nâŠ¢ gradedCommAux R ğ’œ â„¬ âˆ˜â‚— gradedCommAux R â„¬ ğ’œ = LinearMap.id"
    },
    {
      "name": "TensorProduct.liftAux.smul",
      "statement": "R : Type u_1\ninstâœÂ¹â¶ : CommSemiring R\nR' : Type u_2\ninstâœÂ¹âµ : Monoid R'\nR'' : Type u_3\ninstâœÂ¹â´ : Semiring R''\nM : Type u_4\nN : Type u_5\nP : Type u_6\nQ : Type u_7\nS : Type u_8\nT : Type u_9\ninstâœÂ¹Â³ : AddCommMonoid M\ninstâœÂ¹Â² : AddCommMonoid N\ninstâœÂ¹Â¹ : AddCommMonoid P\ninstâœÂ¹â° : AddCommMonoid Q\ninstâœâ¹ : AddCommMonoid S\ninstâœâ¸ : AddCommMonoid T\ninstâœâ· : Module R M\ninstâœâ¶ : Module R N\ninstâœâµ : Module R P\ninstâœâ´ : Module R Q\ninstâœÂ³ : Module R S\ninstâœÂ² : Module R T\ninstâœÂ¹ : DistribMulAction R' M\ninstâœ : Module R'' M\nf : M â†’â‚—[R] N â†’â‚—[R] P\nr : R\nx : M âŠ—[R] N\np : M\nq : N\nâŠ¢ (liftAux f) (r â€¢ p âŠ—â‚œ[R] q) = r â€¢ (liftAux f) (p âŠ—â‚œ[R] q)"
    },
    {
      "name": "TensorProduct.toDirectLimit_tmul_of",
      "statement": "R : Type u_1\ninstâœâ¶ : CommRing R\nÎ¹ : Type u_2\ninstâœâµ : DecidableEq Î¹\ninstâœâ´ : Preorder Î¹\nG : Î¹ â†’ Type u_3\ninstâœÂ³ : (i : Î¹) â†’ AddCommGroup (G i)\ninstâœÂ² : (i : Î¹) â†’ Module R (G i)\nf : (i j : Î¹) â†’ i â‰¤ j â†’ G i â†’â‚—[R] G j\nM : Type u_4\ninstâœÂ¹ : AddCommGroup M\ninstâœ : Module R M\ni : Î¹\ng : G i\nm : M\nâŠ¢ (toDirectLimit f M) ((of R Î¹ G f i) g âŠ—â‚œ[R] m) =\n    (of R Î¹ (fun x => G x âŠ—[R] M) (fun i j h => LinearMap.rTensor M (f i j h)) i) (g âŠ—â‚œ[R] m)"
    },
    {
      "name": "TensorProduct.uncurry_apply",
      "statement": "R : Type u_1\ninstâœÂ¹â¶ : CommSemiring R\nR' : Type u_2\ninstâœÂ¹âµ : Monoid R'\nR'' : Type u_3\ninstâœÂ¹â´ : Semiring R''\nM : Type u_4\nN : Type u_5\nP : Type u_6\nQ : Type u_7\nS : Type u_8\nT : Type u_9\ninstâœÂ¹Â³ : AddCommMonoid M\ninstâœÂ¹Â² : AddCommMonoid N\ninstâœÂ¹Â¹ : AddCommMonoid P\ninstâœÂ¹â° : AddCommMonoid Q\ninstâœâ¹ : AddCommMonoid S\ninstâœâ¸ : AddCommMonoid T\ninstâœâ· : Module R M\ninstâœâ¶ : Module R N\ninstâœâµ : Module R P\ninstâœâ´ : Module R Q\ninstâœÂ³ : Module R S\ninstâœÂ² : Module R T\ninstâœÂ¹ : DistribMulAction R' M\ninstâœ : Module R'' M\nfâœ f : M â†’â‚—[R] N â†’â‚—[R] P\nm : M\nn : N\nâŠ¢ ((uncurry R M N P) f) (m âŠ—â‚œ[R] n) = (f m) n"
    },
    {
      "name": "TopCat.Presheaf.Pushforward.comp_inv_app",
      "statement": "C : Type u\ninstâœ : Category.{v, u} C\nX : TopCat\nâ„± : Presheaf C X\nY Z : TopCat\nf : X âŸ¶ Y\ng : Y âŸ¶ Z\nU : (Opens â†‘Z)áµ’áµ–\nâŠ¢ (comp â„± f g).inv.app U = ğŸ™ ((g _* (f _* â„±)).obj U)"
    },
    {
      "name": "TopCat.Presheaf.covering_presieve_eq_self",
      "statement": "X : TopCat\nY : Opens â†‘X\nR : Presieve Y\nâŠ¢ presieveOfCoveringAux (coveringOfPresieve Y R) Y = R"
    },
    {
      "name": "TopCat.of_isoOfHomeo",
      "statement": "X Y : TopCat\nf : â†‘X â‰ƒâ‚œ â†‘Y\nâŠ¢ homeoOfIso (isoOfHomeo f) = f"
    },
    {
      "name": "TopCat.prodIsoProd_hom_apply",
      "statement": "J : Type v\ninstâœ : SmallCategory J\nX Y : TopCat\nx : â†‘(X â¨¯ Y)\nâŠ¢ (X.prodIsoProd Y).hom x = (prod.fst x, prod.snd x)"
    },
    {
      "name": "TopologicalSpace.Compacts.coe_finset_sup",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : TopologicalSpace Î²\ninstâœ : TopologicalSpace Î³\nÎ¹ : Type u_4\ns : Finset Î¹\nf : Î¹ â†’ Compacts Î±\nâŠ¢ â†‘(s.sup f) = s.sup fun i => â†‘(f i)"
    },
    {
      "name": "Topology.IsLowerSet.closure_singleton",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ² : Preorder Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : Topology.IsLowerSet Î±\ns : Set Î±\na : Î±\nâŠ¢ closure {a} = Ici a"
    },
    {
      "name": "TotallyBounded.isSeparable",
      "statement": "X : Type u_1\ninstâœ : UniformSpace X\ni : (ğ“¤ X).IsCountablyGenerated\ns : Set X\nh : TotallyBounded s\nâŠ¢ TopologicalSpace.IsSeparable s"
    },
    {
      "name": "Traversable.foldlm.ofFreeMonoid_comp_of",
      "statement": "Î± Î² Î³ : Type u\nt : Type u â†’ Type u\ninstâœÂ³ : Traversable t\ninstâœÂ² : LawfulTraversable t\nm : Type u â†’ Type u\ninstâœÂ¹ : Monad m\ninstâœ : LawfulMonad m\nf : Î± â†’ Î² â†’ m Î±\nâŠ¢ â‡‘(foldlM.ofFreeMonoid f) âˆ˜ FreeMonoid.of = foldlM.mk âˆ˜ flip f"
    },
    {
      "name": "Traversable.toList_eq_self",
      "statement": "Î± Î² Î³ : Type u\nt : Type u â†’ Type u\ninstâœÂ¹ : Traversable t\ninstâœ : LawfulTraversable t\nxs : List Î±\nâŠ¢ toList xs = xs"
    },
    {
      "name": "TrivSqZeroExt.inv_inr",
      "statement": "R : Type u\nM : Type v\ninstâœâ´ : DivisionSemiring R\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module Ráµáµ’áµ– M\ninstâœÂ¹ : Module R M\ninstâœ : SMulCommClass R Ráµáµ’áµ– M\nm : M\nâŠ¢ (inr m)â»Â¹ = 0"
    },
    {
      "name": "TrivSqZeroExt.norm_inl",
      "statement": "ğ•œ : Type u_1\nS : Type u_2\nR : Type u_3\nM : Type u_4\ninstâœÂ¹Â³ : SeminormedCommRing S\ninstâœÂ¹Â² : SeminormedRing R\ninstâœÂ¹Â¹ : SeminormedAddCommGroup M\ninstâœÂ¹â° : Algebra S R\ninstâœâ¹ : Module S M\ninstâœâ¸ : Module R M\ninstâœâ· : Module Ráµáµ’áµ– M\ninstâœâ¶ : BoundedSMul S R\ninstâœâµ : BoundedSMul S M\ninstâœâ´ : BoundedSMul R M\ninstâœÂ³ : BoundedSMul Ráµáµ’áµ– M\ninstâœÂ² : SMulCommClass R Ráµáµ’áµ– M\ninstâœÂ¹ : IsScalarTower S R M\ninstâœ : IsScalarTower S Ráµáµ’áµ– M\nr : R\nâŠ¢ â€–inl râ€– = â€–râ€–"
    },
    {
      "name": "Trivialization.preimageSingletonHomeomorph_symm_apply",
      "statement": "Î¹ : Type u_1\nB : Type u_2\nF : Type u_3\nE : B â†’ Type u_4\nZ : Type u_5\ninstâœÂ³ : TopologicalSpace B\ninstâœÂ² : TopologicalSpace F\nproj : Z â†’ B\ninstâœÂ¹ : TopologicalSpace Z\ninstâœ : TopologicalSpace (TotalSpace F E)\ne : Trivialization F proj\nx : Z\nb : B\nhb : b âˆˆ e.baseSet\np : F\nâŠ¢ â†‘e.symm (b, p) âˆˆ proj â»Â¹' {b}"
    },
    {
      "name": "Tropical.add_pow",
      "statement": "R : Type u\ninstâœÂ³ : LinearOrder R\ninstâœÂ² : AddMonoid R\ninstâœÂ¹ : CovariantClass R R (fun x x_1 => x + x_1) fun x x_1 => x â‰¤ x_1\ninstâœ : CovariantClass R R (Function.swap fun x x_1 => x + x_1) fun x x_1 => x â‰¤ x_1\nx y : Tropical R\nn : â„•\nâŠ¢ (x + y) ^ n = x ^ n + y ^ n"
    },
    {
      "name": "TruncatedWittVector.coeff_out",
      "statement": "p : â„•\nhp : Fact (Nat.Prime p)\nn : â„•\nR : Type u_1\ninstâœ : CommRing R\nx : TruncatedWittVector p n R\ni : Fin n\nâŠ¢ x.out.coeff â†‘i = coeff i x"
    },
    {
      "name": "Tuple.graph.card",
      "statement": "n : â„•\nÎ± : Type u_1\ninstâœ : LinearOrder Î±\nf : Fin n â†’ Î±\nâŠ¢ (graph f).card = n"
    },
    {
      "name": "Tuple.lt_card_le_iff_apply_le_of_monotone",
      "statement": "n : â„•\nÎ± : Type u_1\ninstâœÂ¹ : PartialOrder Î±\ninstâœ : DecidableRel LE.le\nm : â„•\nf : Fin m â†’ Î±\na : Î±\nh_sorted : Monotone f\nj : Fin m\nâŠ¢ â†‘j < Fintype.card { i // f i â‰¤ a } â†” f j â‰¤ a"
    },
    {
      "name": "Turing.ListBlank.tail_map",
      "statement": "Î“ : Type u_1\nÎ“' : Type u_2\ninstâœÂ¹ : Inhabited Î“\ninstâœ : Inhabited Î“'\nf : PointedMap Î“ Î“'\nl : ListBlank Î“\nâŠ¢ (map f l).tail = map f l.tail"
    },
    {
      "name": "TypeVec.diag_sub_val",
      "statement": "nâœ n : â„•\nÎ± : TypeVec.{u} n\nâŠ¢ subtypeVal Î±.repeatEq âŠš diagSub = prod.diag"
    },
    {
      "name": "TypeVec.lastFun_of_subtype",
      "statement": "n : â„•\nÎ± : TypeVec.{u_1} (n + 1)\np : Î± âŸ¹ repeat (n + 1) Prop\nâŠ¢ lastFun (ofSubtype p) = _root_.id"
    },
    {
      "name": "TypeVec.lastFun_prod",
      "statement": "n : â„•\nÎ± Î±' Î² Î²' : TypeVec.{u_1} (n + 1)\nf : Î± âŸ¹ Î²\nf' : Î±' âŸ¹ Î²'\nâŠ¢ lastFun (f âŠ—' f') = Prod.map (lastFun f) (lastFun f')"
    },
    {
      "name": "TypeVec.prod_map_id",
      "statement": "n : â„•\nÎ± Î² : TypeVec.{u_1} n\nâŠ¢ (id âŠ—' id) = id"
    },
    {
      "name": "TypeVec.toSubtype_of_subtype",
      "statement": "n : â„•\nÎ± : TypeVec.{u_1} n\np : Î± âŸ¹ repeat n Prop\nâŠ¢ toSubtype p âŠš ofSubtype p = id"
    },
    {
      "name": "ULower.up_down",
      "statement": "Î± : Type u_1\ninstâœ : Encodable Î±\na : Î±\nâŠ¢ (down a).up = a"
    },
    {
      "name": "UV.compress_self",
      "statement": "Î± : Type u_1\ninstâœÂ² : GeneralizedBooleanAlgebra Î±\ninstâœÂ¹ : DecidableRel Disjoint\ninstâœ : DecidableRel fun x x_1 => x â‰¤ x_1\ns : Finset Î±\nuâœ v aâœ b u a : Î±\nâŠ¢ compress u u a = a"
    },
    {
      "name": "Ultrafilter.tendsto_pure_self",
      "statement": "Î± : Type u\nb : Ultrafilter Î±\nâŠ¢ Tendsto pure (â†‘b) (ğ“ b)"
    },
    {
      "name": "UniqueFactorizationMonoid.factors_pos",
      "statement": "Î± : Type u_1\ninstâœÂ¹ : CancelCommMonoidWithZero Î±\ninstâœ : UniqueFactorizationMonoid Î±\nx : Î±\nhx : x â‰  0\nâŠ¢ 0 < factors x â†” Â¬IsUnit x"
    },
    {
      "name": "UniqueFactorizationMonoid.normalizedFactors_pow",
      "statement": "Î± : Type u_1\ninstâœÂ² : CancelCommMonoidWithZero Î±\ninstâœÂ¹ : NormalizationMonoid Î±\ninstâœ : UniqueFactorizationMonoid Î±\nx : Î±\nn : â„•\nâŠ¢ normalizedFactors (x ^ n) = n â€¢ normalizedFactors x"
    },
    {
      "name": "Unitization.isStarNormal_inr",
      "statement": "R : Type u_1\nA : Type u_2\ninstâœâµ : Semiring R\ninstâœâ´ : AddCommMonoid A\ninstâœÂ³ : Mul A\ninstâœÂ² : SMulWithZero R A\ninstâœÂ¹ : StarAddMonoid R\ninstâœ : Star A\na : A\nâŠ¢ IsStarNormal â†‘a â†” IsStarNormal a"
    },
    {
      "name": "Units.isUnit_mul_units",
      "statement": "Î± : Type u\nM : Type u_1\nN : Type u_2\ninstâœ : Monoid M\na : M\nu : MË£\nxâœ : IsUnit (a * â†‘u)\nv : MË£\nhv : â†‘v = a * â†‘u\nâŠ¢ IsUnit a"
    },
    {
      "name": "Units.mul_right_eq_zero",
      "statement": "Î± : Type u_1\nMâ‚€ : Type u_2\nGâ‚€ : Type u_3\nMâ‚€' : Type u_4\nGâ‚€' : Type u_5\nF : Type u_6\nF' : Type u_7\ninstâœ : MonoidWithZero Mâ‚€\nu : Mâ‚€Ë£\na : Mâ‚€\nh : â†‘u * a = 0\nâŠ¢ a = 0"
    },
    {
      "name": "UpperHalfPlane.center_zero",
      "statement": "zâœ w : â„\nr R : â„\nz : â„\nâŠ¢ (z.center 0).im = z.im"
    },
    {
      "name": "Valuation.map_add'",
      "statement": "K : Type u_1\nF : Type u_2\nR : Type u_3\ninstâœâ´ : DivisionRing K\nÎ“â‚€ : Type u_4\nÎ“'â‚€ : Type u_5\nÎ“''â‚€ : Type u_6\ninstâœÂ³ : LinearOrderedCommMonoidWithZero Î“''â‚€\ninstâœÂ² : Ring R\ninstâœÂ¹ : LinearOrderedCommMonoidWithZero Î“â‚€\ninstâœ : LinearOrderedCommMonoidWithZero Î“'â‚€\nv : Valuation R Î“â‚€\nx y z : R\nâŠ¢ âˆ€ (x y : R), v (x + y) â‰¤ v x âˆ¨ v (x + y) â‰¤ v y"
    },
    {
      "name": "ValuationSubring.ofPrime_idealOfLE",
      "statement": "K : Type u\ninstâœ : Field K\nA R S : ValuationSubring K\nh : R â‰¤ S\nâŠ¢ R.ofPrime (R.idealOfLE S h) = S"
    },
    {
      "name": "VectorBundleCore.localTriv_symmL",
      "statement": "R : Type u_1\nB : Type u_2\nF : Type u_3\nE : B â†’ Type u_4\ninstâœâ¸ : NontriviallyNormedField R\ninstâœâ· : (x : B) â†’ AddCommMonoid (E x)\ninstâœâ¶ : (x : B) â†’ Module R (E x)\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace R F\ninstâœÂ³ : TopologicalSpace B\ninstâœÂ² : TopologicalSpace (TotalSpace F E)\ninstâœÂ¹ : (x : B) â†’ TopologicalSpace (E x)\ninstâœ : FiberBundle F E\nÎ¹ : Type u_5\nZ : VectorBundleCore R B F Î¹\nbâœ : B\na : F\ni j : Î¹\nb : B\nhb : b âˆˆ Z.baseSet i\nâŠ¢ Trivialization.symmL R (Z.localTriv i) b = Z.coordChange i (Z.indexAt b) b"
    },
    {
      "name": "WeierstrassCurve.Affine.baseChange_addY",
      "statement": "Râœ : Type u\ninstâœÂ¹Â¹ : CommRing Râœ\nWâœ : Affine Râœ\nR : Type r\ninstâœÂ¹â° : CommRing R\nW : Affine R\nS : Type s\ninstâœâ¹ : CommRing S\ninstâœâ¸ : Algebra R S\nA : Type u\ninstâœâ· : CommRing A\ninstâœâ¶ : Algebra R A\ninstâœâµ : Algebra S A\ninstâœâ´ : IsScalarTower R S A\nB : Type v\ninstâœÂ³ : CommRing B\ninstâœÂ² : Algebra R B\ninstâœÂ¹ : Algebra S B\ninstâœ : IsScalarTower R S B\nf : A â†’â‚[S] B\nxâ‚ xâ‚‚ yâ‚ L : A\nâŠ¢ (baseChange W B).toAffine.addY (f xâ‚) (f xâ‚‚) (f yâ‚) (f L) = f ((baseChange W A).toAffine.addY xâ‚ xâ‚‚ yâ‚ L)"
    },
    {
      "name": "WeierstrassCurve.Affine.evalEval_polynomialY_zero",
      "statement": "R : Type u\ninstâœ : CommRing R\nW : Affine R\nâŠ¢ evalEval 0 0 W.polynomialY = W.aâ‚ƒ"
    },
    {
      "name": "WeierstrassCurve.Affine.evalEval_polynomial_zero",
      "statement": "R : Type u\ninstâœ : CommRing R\nW : Affine R\nâŠ¢ evalEval 0 0 W.polynomial = -W.aâ‚†"
    },
    {
      "name": "WeierstrassCurve.Affine.irreducible_polynomial",
      "statement": "R : Type u\ninstâœÂ¹ : CommRing R\nW : Affine R\ninstâœ : IsDomain R\nâŠ¢ Irreducible W.polynomial"
    },
    {
      "name": "WeierstrassCurve.Jacobian.map_addX",
      "statement": "R : Type u\ninstâœÂ² : CommRing R\nW' : Jacobian R\nF : Type v\ninstâœÂ¹ : Field F\nW : Jacobian F\nS : Type u_1\ninstâœ : CommRing S\nf : R â†’+* S\nP Q : Fin 3 â†’ R\nâŠ¢ addX (map W' f) (â‡‘f âˆ˜ P) (â‡‘f âˆ˜ Q) = f (W'.addX P Q)"
    },
    {
      "name": "WeierstrassCurve.map_bâ‚‚",
      "statement": "R : Type u\ninstâœÂ¹ : CommRing R\nW : WeierstrassCurve R\nA : Type v\ninstâœ : CommRing A\nÏ† : R â†’+* A\nâŠ¢ (W.map Ï†).bâ‚‚ = Ï† W.bâ‚‚"
    },
    {
      "name": "WeierstrassCurve.map_Ï†",
      "statement": "R : Type r\nS : Type s\ninstâœÂ¹ : CommRing R\ninstâœ : CommRing S\nW : WeierstrassCurve R\nf : R â†’+* S\nn : â„¤\nâŠ¢ (W.map f).Ï† n = Polynomial.map (mapRingHom f) (W.Ï† n)"
    },
    {
      "name": "WeierstrassCurve.natDegree_Î¨Sq_pos",
      "statement": "R : Type u\ninstâœÂ¹ : CommRing R\nW : WeierstrassCurve R\ninstâœ : NoZeroDivisors R\nn : â„¤\nhn : 1 < n.natAbs\nh : â†‘n â‰  0\nâŠ¢ 0 < (W.Î¨Sq n).natDegree"
    },
    {
      "name": "WeierstrassCurve.Î¦_one",
      "statement": "R : Type r\nS : Type s\ninstâœÂ¹ : CommRing R\ninstâœ : CommRing S\nW : WeierstrassCurve R\nâŠ¢ W.Î¦ 1 = X"
    },
    {
      "name": "WeierstrassCurve.Î¦_two",
      "statement": "R : Type r\nS : Type s\ninstâœÂ¹ : CommRing R\ninstâœ : CommRing S\nW : WeierstrassCurve R\nâŠ¢ W.Î¦ 2 = X ^ 4 - C W.bâ‚„ * X ^ 2 - C (2 * W.bâ‚†) * X - C W.bâ‚ˆ"
    },
    {
      "name": "WeierstrassCurve.Î¨Sq_one",
      "statement": "R : Type r\nS : Type s\ninstâœÂ¹ : CommRing R\ninstâœ : CommRing S\nW : WeierstrassCurve R\nâŠ¢ W.Î¨Sq 1 = 1"
    },
    {
      "name": "WithBot.le_bot_iff",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\naâœ b : Î±\ninstâœ : LE Î±\na : Î±\nâŠ¢ â†‘a â‰¤ âŠ¥ â†” â†‘a = âŠ¥"
    },
    {
      "name": "WithLp.prod_norm_eq_of_L2",
      "statement": "p : â„â‰¥0âˆ\nğ•œ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nhp : Fact (1 â‰¤ p)\ninstâœÂ¹ : SeminormedAddCommGroup Î±\ninstâœ : SeminormedAddCommGroup Î²\nx : WithLp 2 (Î± Ã— Î²)\nâŠ¢ â€–xâ€– = âˆš(â€–x.1â€– ^ 2 + â€–x.2â€– ^ 2)"
    },
    {
      "name": "WithTop.mapâ‚‚_coe_right",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\naâœ bâœ : Î±\nf : Î± â†’ Î² â†’ Î³\na : WithTop Î±\nb : Î²\nâŠ¢ mapâ‚‚ f a â†‘b = map (fun x => f x b) a"
    },
    {
      "name": "WithZero.map'_id",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ² : MulOneClass Î±\ninstâœÂ¹ : MulOneClass Î²\ninstâœ : MulOneClass Î³\nâŠ¢ â†‘(map' (MonoidHom.id Î²)) = MonoidHom.id (WithZero Î²)"
    },
    {
      "name": "WittVector.bindâ‚_onePoly_wittPolynomial",
      "statement": "p : â„•\nR S : Type u\nÏƒ : Type u_1\nidx : Type u_2\ninstâœÂ¹ : CommRing R\ninstâœ : CommRing S\nhp : Fact (Nat.Prime p)\nn : â„•\nâŠ¢ (bindâ‚ onePoly) (wittPolynomial p â„¤ n) = 1"
    },
    {
      "name": "WittVector.coeff_frobenius_charP",
      "statement": "p : â„•\nR : Type u_1\nS : Type u_2\nhp : Fact (Nat.Prime p)\ninstâœÂ² : CommRing R\ninstâœÂ¹ : CommRing S\ninstâœ : CharP R p\nx : ğ• R\nn : â„•\nâŠ¢ (frobenius x).coeff n = x.coeff n ^ p"
    },
    {
      "name": "WittVector.exists_eq_pow_p_mul",
      "statement": "p : â„•\nhp : Fact (Nat.Prime p)\nk : Type u_1\ninstâœÂ² : CommRing k\ninstâœÂ¹ : CharP k p\ninstâœ : PerfectRing k p\na : ğ• k\nha : a â‰  0\nâŠ¢ âˆƒ m b, b.coeff 0 â‰  0 âˆ§ a = â†‘p ^ m * b"
    },
    {
      "name": "WittVector.out_truncateFun",
      "statement": "p : â„•\nhp : Fact (Nat.Prime p)\nn : â„•\nR : Type u_1\ninstâœ : CommRing R\nx : ğ• R\nâŠ¢ (truncateFun n x).out = init n x"
    },
    {
      "name": "WittVector.zero_coeff",
      "statement": "p : â„•\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninstâœ : CommRing R\nn : â„•\nâŠ¢ (aeval (Function.uncurry fun i => (![] i).coeff)) (wittZero p n) = 0"
    },
    {
      "name": "YoungDiagram.le_of_transpose_le",
      "statement": "Î¼ Î½ : YoungDiagram\nh_le : Î¼.transpose â‰¤ Î½\nc : â„• Ã— â„•\nhc : c âˆˆ Î¼.cells\nâŠ¢ c âˆˆ Î½.transpose.cells"
    },
    {
      "name": "YoungDiagram.mk_mem_col_iff",
      "statement": "Î¼ : YoungDiagram\ni j : â„•\nâŠ¢ (i, j) âˆˆ Î¼.col j â†” (i, j) âˆˆ Î¼"
    },
    {
      "name": "ZFSet.mem_prod",
      "statement": "x y z : ZFSet\nâŠ¢ z âˆˆ x.prod y â†” âˆƒ a âˆˆ x, âˆƒ b âˆˆ y, z = a.pair b"
    },
    {
      "name": "ZFSet.mem_sep",
      "statement": "p : ZFSet â†’ Prop\nx yâœ : ZFSet\nxâœÂ¹ y : PSet\nÎ± : Type u\nA : Î± â†’ PSet\nxâœ : âŸ¦yâŸ§ âˆˆ ZFSet.sep p âŸ¦PSet.mk Î± AâŸ§\na : (PSet.mk Î± A).Type\npa : (fun y => p (mk y)) ((PSet.mk Î± A).Func a)\nh : y.Equiv (Func â†‘(Resp.f âŸ¨PSet.sep fun y => p (mk y), â‹¯âŸ© (PSet.mk Î± A)) âŸ¨a, paâŸ©)\nâŠ¢ p âŸ¦yâŸ§"
    },
    {
      "name": "ZFSet.toSet_sUnion",
      "statement": "x : ZFSet\nâŠ¢ (â‹ƒâ‚€ x).toSet = â‹ƒâ‚€ (toSet '' x.toSet)"
    },
    {
      "name": "ZFSet.toSet_sdiff",
      "statement": "x y : ZFSet\nâŠ¢ (x \\ y).toSet = x.toSet \\ y.toSet"
    },
    {
      "name": "ZMod.addOrderOf_coe",
      "statement": "a n : â„•\nn0 : n â‰  0\nâŠ¢ addOrderOf â†‘a = n / n.gcd a"
    },
    {
      "name": "ZMod.card",
      "statement": "n : â„•\ninstâœ : Fintype (ZMod n)\nâŠ¢ Fintype.card (ZMod n) = n"
    },
    {
      "name": "ZMod.coe_valMinAbs",
      "statement": "k n : â„•\nhâœ : k = n + 1\nx : ZMod (namedPattern k (n + 1) hâœ)\nâŠ¢ â†‘x.valMinAbs = x"
    },
    {
      "name": "ZMod.inv_coe_unit",
      "statement": "n : â„•\nu : (ZMod n)Ë£\nâŠ¢ (â†‘u)â»Â¹ = â†‘uâ»Â¹"
    },
    {
      "name": "ZMod.natAbs_mod_two",
      "statement": "a : â„¤\nâŠ¢ â†‘a.natAbs = â†‘a"
    },
    {
      "name": "ZMod.natCast_comp_val",
      "statement": "n : â„•\nR : Type u_1\ninstâœÂ¹ : Ring R\ninstâœ : NeZero n\nâŠ¢ Nat.cast âˆ˜ val = cast"
    },
    {
      "name": "ZMod.natCast_zmod_val",
      "statement": "nâœ : â„•\nR : Type u_1\nn : â„•\ninstâœ : NeZero n\na : ZMod n\nâŠ¢ â†‘a.val = a"
    },
    {
      "name": "ZMod.neg_eq_self_mod_two",
      "statement": "a : ZMod 2\nâŠ¢ -a = a"
    },
    {
      "name": "ZMod.pow_card_pow",
      "statement": "K : Type u_1\nR : Type u_2\nn p : â„•\ninstâœ : Fact (Nat.Prime p)\nx : ZMod p\nâŠ¢ x ^ p ^ n = x"
    },
    {
      "name": "ZMod.valMinAbs_eq_zero",
      "statement": "n : â„•\nx : ZMod n\nâŠ¢ x.valMinAbs = 0 â†” x = 0"
    },
    {
      "name": "ZMod.val_natCast",
      "statement": "n a : â„•\nâŠ¢ (â†‘a).val = a % n"
    },
    {
      "name": "ZMod.Ï‡â‚„_nat_mod_four",
      "statement": "n : â„•\nâŠ¢ Ï‡â‚„ â†‘n = Ï‡â‚„ â†‘(n % 4)"
    },
    {
      "name": "ZNum.bit1_of_bit1",
      "statement": "Î± : Type u_1\na : PosNum\nâŠ¢ sub' 1 (_root_.bit0 a) = (neg a).bit1"
    },
    {
      "name": "ZNum.cast_add",
      "statement": "Î± : Type u_1\ninstâœ : AddGroupWithOne Î±\na : ZNum\nâŠ¢ â†‘(0 + a) = â†‘0 + â†‘a"
    },
    {
      "name": "ZNum.cast_succ",
      "statement": "Î± : Type u_1\ninstâœ : AddGroupWithOne Î±\nn : ZNum\nâŠ¢ â†‘n.succ = â†‘n + 1"
    },
    {
      "name": "ZNum.ofInt'_neg",
      "statement": "Î± : Type u_1\nn : â„•\nâŠ¢ ofInt' â†‘(n + 1) = -ofInt' -[n+1]"
    },
    {
      "name": "ZNum.zero_add",
      "statement": "Î± : Type u_1\nn : ZNum\nâŠ¢ 0 + n = n"
    },
    {
      "name": "ZNum.zneg_zneg",
      "statement": "Î± : Type u_1\nn : ZNum\nâŠ¢ - -n = n"
    },
    {
      "name": "Zsqrtd.dmuld",
      "statement": "d : â„¤\nâŠ¢ sqrtd * sqrtd = â†‘d"
    },
    {
      "name": "Zsqrtd.norm_intCast",
      "statement": "d n : â„¤\nâŠ¢ (â†‘n).norm = n * n"
    },
    {
      "name": "Zsqrtd.smuld_val",
      "statement": "d n x y : â„¤\nâŠ¢ sqrtd * â†‘n * { re := x, im := y } = { re := d * n * y, im := n * x }"
    },
    {
      "name": "absorbs_inter",
      "statement": "Gâ‚€ : Type u_1\nÎ± : Type u_2\ninstâœÂ² : GroupWithZero Gâ‚€\ninstâœÂ¹ : Bornology Gâ‚€\ninstâœ : MulAction Gâ‚€ Î±\ns t u : Set Î±\nS : Set (Set Î±)\nâŠ¢ Absorbs Gâ‚€ (s âˆ© t) u â†” Absorbs Gâ‚€ s u âˆ§ Absorbs Gâ‚€ t u"
    },
    {
      "name": "ack_one",
      "statement": "n : â„•\nâŠ¢ ack 1 n = n + 2"
    },
    {
      "name": "ack_three",
      "statement": "n : â„•\nâŠ¢ ack 3 n = 2 ^ (n + 3) - 3"
    },
    {
      "name": "add_pow_expChar",
      "statement": "R : Type u\ninstâœ : CommSemiring R\nq : â„•\nhR : ExpChar R q\nx y : R\nâŠ¢ (x + y) ^ q = x ^ q + y ^ q"
    },
    {
      "name": "aemeasurable_union_iff",
      "statement": "Î¹ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\nÎ´ : Type u_5\nR : Type u_6\nm0 : MeasurableSpace Î±\ninstâœÂ² : MeasurableSpace Î²\ninstâœÂ¹ : MeasurableSpace Î³\ninstâœ : MeasurableSpace Î´\nf g : Î± â†’ Î²\nÎ¼ Î½ : Measure Î±\ns t : Set Î±\nâŠ¢ AEMeasurable f (Î¼.restrict (s âˆª t)) â†” AEMeasurable f (Î¼.restrict s) âˆ§ AEMeasurable f (Î¼.restrict t)"
    },
    {
      "name": "antivary_inv",
      "statement": "Î¹ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OrderedCommGroup Î±\ninstâœ : OrderedCommGroup Î²\ns : Set Î¹\nf fâ‚ fâ‚‚ : Î¹ â†’ Î±\ng gâ‚ gâ‚‚ : Î¹ â†’ Î²\nâŠ¢ Antivary fâ»Â¹ gâ»Â¹ â†” Antivary f g"
    },
    {
      "name": "antivary_invâ‚€",
      "statement": "Î¹ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : LinearOrderedSemifield Î±\ninstâœ : LinearOrderedSemifield Î²\ns : Set Î¹\nf fâ‚ fâ‚‚ : Î¹ â†’ Î±\ng gâ‚ gâ‚‚ : Î¹ â†’ Î²\nhf : StrongLT 0 f\nhg : StrongLT 0 g\nâŠ¢ Antivary fâ»Â¹ gâ»Â¹ â†” Antivary f g"
    },
    {
      "name": "ascPochhammer_natDegree",
      "statement": "S : Type u\ninstâœÂ² : Semiring S\nn : â„•\ninstâœÂ¹ : NoZeroDivisors S\ninstâœ : Nontrivial S\nâŠ¢ (ascPochhammer S n).natDegree = n"
    },
    {
      "name": "associated_zero_iff_eq_zero",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\ninstâœ : MonoidWithZero Î±\na : Î±\nh : a ~áµ¤ 0\nâŠ¢ a = 0"
    },
    {
      "name": "bddBelow_closure",
      "statement": "Î± : Type u\nÎ² : Type v\nÎ³ : Type w\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : Preorder Î±\ninstâœ : ClosedIciTopology Î±\nf : Î² â†’ Î±\na b : Î±\ns : Set Î±\nâŠ¢ BddBelow (closure s) â†” BddBelow s"
    },
    {
      "name": "bernoulli'_one",
      "statement": "A : Type u_1\ninstâœÂ¹ : CommRing A\ninstâœ : Algebra â„š A\nâŠ¢ bernoulli' 1 = 1 / 2"
    },
    {
      "name": "bernoulli'_zero",
      "statement": "A : Type u_1\ninstâœÂ¹ : CommRing A\ninstâœ : Algebra â„š A\nâŠ¢ bernoulli' 0 = 1"
    },
    {
      "name": "bernstein.probability",
      "statement": "n : â„•\nx : â†‘I\nâŠ¢ âˆ‘ k : Fin (n + 1), (bernstein n â†‘k) x = 1"
    },
    {
      "name": "cauchySeq_of_edist_le_of_summable",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ¹ instâœ : PseudoEMetricSpace Î±\nf : â„• â†’ Î±\nd : â„• â†’ â„â‰¥0\nhf : âˆ€ (n : â„•), edist (f n) (f n.succ) â‰¤ â†‘(d n)\nhd : Summable d\nâŠ¢ CauchySeq f"
    },
    {
      "name": "ceilDiv_one",
      "statement": "Î¹ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœâ´ : OrderedSemiring Î±\ninstâœÂ³ : OrderedAddCommMonoid Î²\ninstâœÂ² : MulActionWithZero Î± Î²\ninstâœÂ¹ : CeilDiv Î± Î²\na : Î±\ninstâœ : Nontrivial Î±\nb c : Î²\nâŠ¢ b âŒˆ/âŒ‰ 1 â‰¤ c â†” b â‰¤ c"
    },
    {
      "name": "cfc_apply_of_not_predicate",
      "statement": "R : Type u_1\nA : Type u_2\np : A â†’ Prop\ninstâœâ¹ : CommSemiring R\ninstâœâ¸ : StarRing R\ninstâœâ· : MetricSpace R\ninstâœâ¶ : TopologicalSemiring R\ninstâœâµ : ContinuousStar R\ninstâœâ´ : TopologicalSpace A\ninstâœÂ³ : Ring A\ninstâœÂ² : StarRing A\ninstâœÂ¹ : Algebra R A\ninstâœ : ContinuousFunctionalCalculus R p\nfâœ g : R â†’ R\naâœ : A\nhaâœ : autoParam (p aâœ) _autoâœ\nhf : autoParam (ContinuousOn fâœ (spectrum R aâœ)) _autoâœ\nhg : autoParam (ContinuousOn g (spectrum R aâœ)) _autoâœ\nf : R â†’ R\na : A\nha : Â¬p a\nâŠ¢ cfc f a = 0"
    },
    {
      "name": "ciSup_of_empty",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ¹ : Sort u_4\ninstâœÂ¹ : ConditionallyCompleteLinearOrderBot Î±\ns : Set Î±\nfâœ : Î¹ â†’ Î±\na : Î±\ninstâœ : IsEmpty Î¹\nf : Î¹ â†’ Î±\nâŠ¢ â¨† i, f i = âŠ¥"
    },
    {
      "name": "compare_ge_iff_ge",
      "statement": "Î± : Type u\ninstâœ : LinearOrder Î±\na b : Î±\nâŠ¢ compare a b â‰  Ordering.lt â†” a â‰¥ b"
    },
    {
      "name": "compl_le_compl_iff_le",
      "statement": "Î± : Type u\nÎ² : Type u_1\nw x y z : Î±\ninstâœ : BooleanAlgebra Î±\nh : yá¶œ â‰¤ xá¶œ\nâŠ¢ x â‰¤ y"
    },
    {
      "name": "constantCoeff_wittStructureInt_zero",
      "statement": "p : â„•\nR : Type u_1\nidx : Type u_2\ninstâœ : CommRing R\nhp : Fact (Nat.Prime p)\nÎ¦ : MvPolynomial idx â„¤\nâŠ¢ constantCoeff (wittStructureInt p Î¦ 0) = constantCoeff Î¦"
    },
    {
      "name": "constantCoeff_wittStructureRat_zero",
      "statement": "p : â„•\nR : Type u_1\nidx : Type u_2\ninstâœ : CommRing R\nhp : Fact (Nat.Prime p)\nÎ¦ : MvPolynomial idx â„š\nâŠ¢ constantCoeff (wittStructureRat p Î¦ 0) = constantCoeff Î¦"
    },
    {
      "name": "constantCoeff_xInTermsOfW",
      "statement": "p : â„•\nR : Type u_1\ninstâœÂ² : CommRing R\ninstâœÂ¹ : DecidableEq R\nhp : Fact (Nat.Prime p)\ninstâœ : Invertible â†‘p\nn : â„•\nâŠ¢ constantCoeff (xInTermsOfW p R n) = 0"
    },
    {
      "name": "continuous_sigma_map",
      "statement": "X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\nÎµ : Type u_3\nÎ¶ : Type u_4\nÎ¹ : Type u_5\nÎº : Type u_6\nÏƒ : Î¹ â†’ Type u_7\nÏ„ : Îº â†’ Type u_8\ninstâœÂ² : (i : Î¹) â†’ TopologicalSpace (Ïƒ i)\ninstâœÂ¹ : (k : Îº) â†’ TopologicalSpace (Ï„ k)\ninstâœ : TopologicalSpace X\nfâ‚ : Î¹ â†’ Îº\nfâ‚‚ : (i : Î¹) â†’ Ïƒ i â†’ Ï„ (fâ‚ i)\nâŠ¢ (âˆ€ (i : Î¹), Continuous fun a => Sigma.map fâ‚ fâ‚‚ âŸ¨i, aâŸ©) â†” âˆ€ (i : Î¹), Continuous (fâ‚‚ i)"
    },
    {
      "name": "convexHull_empty_iff",
      "statement": "ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : OrderedSemiring ğ•œ\ninstâœÂ³ : AddCommMonoid E\ninstâœÂ² : AddCommMonoid F\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œ F\ns t : Set E\nx y : E\nâŠ¢ (convexHull ğ•œ) s = âˆ… â†” s = âˆ…"
    },
    {
      "name": "denseRange_discrete",
      "statement": "Î± : Type u_1\nt tâ‚ tâ‚‚ : TopologicalSpace Î±\ns : Set Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : DiscreteTopology Î±\nÎ² : Type u_2\nÎ¹ : Type u_3\nf : Î¹ â†’ Î±\nâŠ¢ DenseRange f â†” Surjective f"
    },
    {
      "name": "dense_discrete",
      "statement": "Î± : Type u_1\nt tâ‚ tâ‚‚ : TopologicalSpace Î±\nsâœ : Set Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : DiscreteTopology Î±\nÎ² : Type u_2\ns : Set Î±\nâŠ¢ Dense s â†” s = univ"
    },
    {
      "name": "denselyOrdered_orderDual",
      "statement": "Î¹ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nÏ€ : Î¹ â†’ Type u_4\ninstâœ : LT Î±\nâŠ¢ DenselyOrdered Î±áµ’áµˆ â†’ DenselyOrdered Î±"
    },
    {
      "name": "derivedSeries_le_map_derivedSeries",
      "statement": "G : Type u_1\nG' : Type u_2\ninstâœÂ¹ : Group G\ninstâœ : Group G'\nf : G â†’* G'\nhf : Function.Surjective â‡‘f\nn : â„•\nâŠ¢ derivedSeries G' n â‰¤ map f (derivedSeries G n)"
    },
    {
      "name": "dist_vadd_left",
      "statement": "Î± : Type u_1\nV : Type u_2\nP : Type u_3\nW : Type u_4\nQ : Type u_5\ninstâœâµ : SeminormedAddCommGroup V\ninstâœâ´ : PseudoMetricSpace P\ninstâœÂ³ : NormedAddTorsor V P\ninstâœÂ² : NormedAddCommGroup W\ninstâœÂ¹ : MetricSpace Q\ninstâœ : NormedAddTorsor W Q\nv : V\nx : P\nâŠ¢ dist (v +áµ¥ x) x = â€–vâ€–"
    },
    {
      "name": "dist_vsub_cancel_left",
      "statement": "Î± : Type u_1\nV : Type u_2\nP : Type u_3\nW : Type u_4\nQ : Type u_5\ninstâœâµ : SeminormedAddCommGroup V\ninstâœâ´ : PseudoMetricSpace P\ninstâœÂ³ : NormedAddTorsor V P\ninstâœÂ² : NormedAddCommGroup W\ninstâœÂ¹ : MetricSpace Q\ninstâœ : NormedAddTorsor W Q\nx y z : P\nâŠ¢ dist (x -áµ¥ y) (x -áµ¥ z) = dist y z"
    },
    {
      "name": "div_neg_eq_neg_div",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nK : Type u_3\ninstâœÂ¹ : DivisionMonoid K\ninstâœ : HasDistribNeg K\naâœ bâœ a b : K\nâŠ¢ b / -a = b * (1 / -a)"
    },
    {
      "name": "dualTensorHomEquivOfBasis_apply",
      "statement": "Î¹ : Type w\nR : Type u\nM : Type vâ‚\nN : Type vâ‚‚\nP : Type vâ‚ƒ\nQ : Type vâ‚„\ninstâœÂ¹â° : CommRing R\ninstâœâ¹ : AddCommGroup M\ninstâœâ¸ : AddCommGroup N\ninstâœâ· : AddCommGroup P\ninstâœâ¶ : AddCommGroup Q\ninstâœâµ : Module R M\ninstâœâ´ : Module R N\ninstâœÂ³ : Module R P\ninstâœÂ² : Module R Q\ninstâœÂ¹ : DecidableEq Î¹\ninstâœ : Fintype Î¹\nb : Basis Î¹ R M\nx : Dual R M âŠ—[R] N\nâŠ¢ (dualTensorHomEquivOfBasis b) x = (dualTensorHom R M N) x"
    },
    {
      "name": "egauge_zero_right",
      "statement": "ğ•œ : Type u_1\ninstâœÂ² : NormedDivisionRing ğ•œ\nÎ± : Type u_2\nE : Type u_3\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nc : ğ•œ\ns t : Set E\nx y : E\nr : â„â‰¥0âˆ\nhs : s.Nonempty\nâŠ¢ egauge ğ•œ s 0 = 0"
    },
    {
      "name": "eq_of_hammingDist_eq_zero",
      "statement": "Î± : Type u_1\nÎ¹ : Type u_2\nÎ² : Î¹ â†’ Type u_3\ninstâœÂ² : Fintype Î¹\ninstâœÂ¹ : (i : Î¹) â†’ DecidableEq (Î² i)\nÎ³ : Î¹ â†’ Type u_4\ninstâœ : (i : Î¹) â†’ DecidableEq (Î³ i)\nx y : (i : Î¹) â†’ Î² i\nâŠ¢ hammingDist x y = 0 â†’ x = y"
    },
    {
      "name": "eq_of_vsub_eq_zero",
      "statement": "G : Type u_1\nP : Type u_2\ninstâœ : AddGroup G\nT : AddTorsor G P\npâ‚ pâ‚‚ : P\nh : pâ‚ -áµ¥ pâ‚‚ = 0\nâŠ¢ pâ‚ = pâ‚‚"
    },
    {
      "name": "expNegInvGlue.zero_of_nonpos",
      "statement": "x : â„\nhx : x â‰¤ 0\nâŠ¢ expNegInvGlue x = 0"
    },
    {
      "name": "fderivWithin_iteratedFDerivWithin",
      "statement": "ğ•œ : Type u\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type uF\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\nX : Type uX\ninstâœÂ¹ : NormedAddCommGroup X\ninstâœ : NormedSpace ğ•œ X\nsâœ sâ‚ t u : Set E\nf fâ‚ : E â†’ F\ng : F â†’ G\nx xâ‚€ : E\nc : F\nm nâœ : â„•âˆ\np : E â†’ FormalMultilinearSeries ğ•œ E F\ns : Set E\nn : â„•\nâŠ¢ fderivWithin ğ•œ (iteratedFDerivWithin ğ•œ n f s) s =\n    â‡‘(continuousMultilinearCurryLeftEquiv ğ•œ (fun x => E) F).symm âˆ˜ iteratedFDerivWithin ğ•œ (n + 1) f s"
    },
    {
      "name": "finSuccEquiv'_last_apply",
      "statement": "m n : â„•\ni : Fin (n + 1)\nh : i â‰  Fin.last n\nâŠ¢ (finSuccEquiv' (Fin.last n)) i = some (i.castLT â‹¯)"
    },
    {
      "name": "finprod_mem_mulSupport",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nG : Type u_4\nM : Type u_5\nN : Type u_6\ninstâœÂ¹ : CommMonoid M\ninstâœ : CommMonoid N\nf : Î± â†’ M\na : Î±\nâŠ¢ âˆá¶  (_ : f a â‰  1), f a = f a"
    },
    {
      "name": "floorDiv_le_ceilDiv",
      "statement": "Î¹ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœâµ : LinearOrderedAddCommMonoid Î±\ninstâœâ´ : OrderedAddCommMonoid Î²\ninstâœÂ³ : SMulZeroClass Î± Î²\ninstâœÂ² : PosSMulReflectLE Î± Î²\ninstâœÂ¹ : FloorDiv Î± Î²\ninstâœ : CeilDiv Î± Î²\na : Î±\nb c : Î²\nâŠ¢ b âŒŠ/âŒ‹ a â‰¤ b âŒˆ/âŒ‰ a"
    },
    {
      "name": "fourier_neg",
      "statement": "T : â„\nn : â„¤\nx : AddCircle T\nâŠ¢ (fourier (-n)) x = (starRingEnd â„‚) ((fourier n) x)"
    },
    {
      "name": "fourier_neg'",
      "statement": "T : â„\nn : â„¤\nx : AddCircle T\nâŠ¢ â†‘(-(n â€¢ x)).toCircle = (starRingEnd â„‚) ((fourier n) x)"
    },
    {
      "name": "galRestrictHom_symm_algebraMap_apply",
      "statement": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninstâœÂ¹Â³ : CommRing A\ninstâœÂ¹Â² : CommRing B\ninstâœÂ¹Â¹ : Algebra A B\ninstâœÂ¹â° : Field K\ninstâœâ¹ : Field L\ninstâœâ¸ : Algebra A K\ninstâœâ· : IsFractionRing A K\ninstâœâ¶ : Algebra B L\ninstâœâµ : Algebra K L\ninstâœâ´ : Algebra A L\ninstâœÂ³ : IsScalarTower A B L\ninstâœÂ² : IsScalarTower A K L\ninstâœÂ¹ : IsIntegralClosure B A L\ninstâœ : FiniteDimensional K L\nÏƒ : B â†’â‚[A] B\nx : B\nâŠ¢ ((galRestrictHom A K L B).symm Ïƒ) ((algebraMap B L) x) = (algebraMap B L) (Ïƒ x)"
    },
    {
      "name": "gcd_mul_left",
      "statement": "Î± : Type u_1\ninstâœÂ¹ : CancelCommMonoidWithZero Î±\ninstâœ : NormalizedGCDMonoid Î±\na b c : Î±\nâŠ¢ a = 0 â†’ gcd (a * b) (a * c) = normalize a * gcd b c"
    },
    {
      "name": "gcd_one_right'",
      "statement": "Î± : Type u_1\ninstâœÂ¹ : CancelCommMonoidWithZero Î±\ninstâœ : GCDMonoid Î±\na : Î±\nâŠ¢ Associated (gcd a 1) 1"
    },
    {
      "name": "goldConj_sq",
      "statement": "âŠ¢ Ïˆ ^ 2 = Ïˆ + 1"
    },
    {
      "name": "gold_mul_goldConj",
      "statement": "âŠ¢ Ï† * Ïˆ = -1"
    },
    {
      "name": "groupCohomology.dOne_comp_dZero",
      "statement": "k G : Type u\ninstâœÂ¹ : CommRing k\ninstâœ : Group G\nA : Rep k G\nâŠ¢ dOne A âˆ˜â‚— dZero A = 0"
    },
    {
      "name": "groupCohomology.groupCohomologyÏ€_comp_isoH0_hom",
      "statement": "k G : Type u\ninstâœÂ¹ : CommRing k\ninstâœ : Group G\nA : Rep k G\nâŠ¢ groupCohomologyÏ€ A 0 â‰« (isoH0 A).hom = (isoZeroCocycles A).hom"
    },
    {
      "name": "hammingDist_lt_one",
      "statement": "Î± : Type u_1\nÎ¹ : Type u_2\nÎ² : Î¹ â†’ Type u_3\ninstâœÂ² : Fintype Î¹\ninstâœÂ¹ : (i : Î¹) â†’ DecidableEq (Î² i)\nÎ³ : Î¹ â†’ Type u_4\ninstâœ : (i : Î¹) â†’ DecidableEq (Î³ i)\nx y : (i : Î¹) â†’ Î² i\nâŠ¢ hammingDist x y < 1 â†” x = y"
    },
    {
      "name": "himp_compl",
      "statement": "Î¹ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœ : HeytingAlgebra Î±\naâœ b c a : Î±\nâŠ¢ a â‡¨ aá¶œ = aá¶œ"
    },
    {
      "name": "holderOnWith_singleton",
      "statement": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninstâœÂ² : PseudoEMetricSpace X\ninstâœÂ¹ : PseudoEMetricSpace Y\ninstâœ : PseudoEMetricSpace Z\nC r : â„â‰¥0\nf : X â†’ Y\nx : X\nâŠ¢ HolderOnWith C r f {x}"
    },
    {
      "name": "hyperoperation_three",
      "statement": "âŠ¢ hyperoperation 3 = fun x x_1 => x ^ x_1"
    },
    {
      "name": "iSup_const",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ²â‚‚ : Type u_3\nÎ³ : Type u_4\nÎ¹ : Sort u_5\nÎ¹' : Sort u_6\nÎº : Î¹ â†’ Sort u_7\nÎº' : Î¹' â†’ Sort u_8\ninstâœÂ¹ : CompleteLattice Î±\nf g s t : Î¹ â†’ Î±\na b : Î±\ninstâœ : Nonempty Î¹\nâŠ¢ â¨† x, a = a"
    },
    {
      "name": "imageToKernel_comp_hom_inv_comp",
      "statement": "Î¹ : Type u_1\nV : Type u\ninstâœÂ³ : Category.{v, u} V\ninstâœÂ² : HasZeroMorphisms V\nA B C : V\nf : A âŸ¶ B\ng : B âŸ¶ C\ninstâœÂ¹ : HasEqualizers V\ninstâœ : HasImages V\nZ : V\ni : B â‰… Z\nw : (f â‰« i.hom) â‰« i.inv â‰« g = 0\nâŠ¢ f â‰« g = 0"
    },
    {
      "name": "imageToKernel_epi_comp",
      "statement": "Î¹ : Type u_1\nV : Type u\ninstâœâ´ : Category.{v, u} V\ninstâœÂ³ : HasZeroMorphisms V\nA B C : V\nf : A âŸ¶ B\ng : B âŸ¶ C\ninstâœÂ² : HasKernels V\ninstâœÂ¹ : HasImages V\nZ : V\nh : Z âŸ¶ A\ninstâœ : Epi h\nw : (h â‰« f) â‰« g = 0\nâŠ¢ h â‰« f â‰« g = h â‰« 0"
    },
    {
      "name": "imaginaryPart_I_smul",
      "statement": "A : Type u_1\ninstâœÂ³ : AddCommGroup A\ninstâœÂ² : Module â„‚ A\ninstâœÂ¹ : StarAddMonoid A\ninstâœ : StarModule â„‚ A\na : A\nâŠ¢ â„‘ (I â€¢ a) = â„œ a"
    },
    {
      "name": "infClosed_univ",
      "statement": "F : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : SemilatticeInf Î±\ninstâœ : SemilatticeInf Î²\nÎ¹ : Sort u_4\nS : Set (Set Î±)\nf : Î¹ â†’ Set Î±\ns t : Set Î±\na : Î±\nâŠ¢ InfClosed univ"
    },
    {
      "name": "infPrime_iff_infIrred",
      "statement": "Î¹ : Type u_1\nÎ± : Type u_2\ninstâœ : DistribLattice Î±\na bâœ câœ : Î±\nh : âˆ€ â¦ƒb c : Î±â¦„, b âŠ“ c = a â†’ b = a âˆ¨ c = a\nb c : Î±\nâŠ¢ b âŠ“ c â‰¤ a â†’ b â‰¤ a âˆ¨ c â‰¤ a"
    },
    {
      "name": "infinite_prod",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nâŠ¢ Infinite (Î± Ã— Î²) â†” Infinite Î± âˆ§ Nonempty Î² âˆ¨ Nonempty Î± âˆ§ Infinite Î²"
    },
    {
      "name": "integral_comp_neg_Iic",
      "statement": "E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace â„ E\nc : â„\nf : â„ â†’ E\nâŠ¢ âˆ« (x : â„) in Iic c, f (-x) = âˆ« (x : â„) in Ioi (-c), f x"
    },
    {
      "name": "integral_log",
      "statement": "a b : â„\nn : â„•\nh : 0 âˆ‰ [[a, b]]\nâŠ¢ âˆ« (x : â„) in a..b, Real.log x = b * Real.log b - a * Real.log a - b + a"
    },
    {
      "name": "integral_sin_sq_mul_cos_sq",
      "statement": "a b : â„\nn : â„•\nâŠ¢ âˆ« (x : â„) in a..b, sin x ^ 2 * cos x ^ 2 = (b - a) / 8 - (sin (4 * b) - sin (4 * a)) / 32"
    },
    {
      "name": "intervalIntegrable_sub_inv_iff",
      "statement": "E : Type u_1\nF : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace â„ E\ninstâœ : NormedAddCommGroup F\na b c : â„\nâŠ¢ IntervalIntegrable (fun x => (x - c)â»Â¹) volume a b â†” a = b âˆ¨ c âˆ‰ [[a, b]]"
    },
    {
      "name": "intervalIntegral.integral_comp_add_left",
      "statement": "Î¹ : Type u_1\nğ•œ : Type u_2\nE : Type u_3\nF : Type u_4\nA : Type u_5\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : CompleteSpace E\ninstâœ : NormedSpace â„ E\na b c dâœ : â„\nf : â„ â†’ E\nd : â„\nâŠ¢ âˆ« (x : â„) in a..b, f (d + x) = âˆ« (x : â„) in d + a..d + b, f x"
    },
    {
      "name": "intervalIntegral.integral_comp_neg",
      "statement": "Î¹ : Type u_1\nğ•œ : Type u_2\nE : Type u_3\nF : Type u_4\nA : Type u_5\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : CompleteSpace E\ninstâœ : NormedSpace â„ E\na b c d : â„\nf : â„ â†’ E\nâŠ¢ âˆ« (x : â„) in a..b, f (-x) = âˆ« (x : â„) in -b..-a, f x"
    },
    {
      "name": "intervalIntegral.integral_comp_sub_right",
      "statement": "Î¹ : Type u_1\nğ•œ : Type u_2\nE : Type u_3\nF : Type u_4\nA : Type u_5\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : CompleteSpace E\ninstâœ : NormedSpace â„ E\na b c dâœ : â„\nf : â„ â†’ E\nd : â„\nâŠ¢ âˆ« (x : â„) in a..b, f (x - d) = âˆ« (x : â„) in a - d..b - d, f x"
    },
    {
      "name": "intervalIntegral.intervalIntegrable_one_div_one_add_sq",
      "statement": "a b : â„\nn : â„•\nf : â„ â†’ â„\nÎ¼ Î½ : Measure â„\ninstâœ : IsLocallyFiniteMeasure Î¼\nc d : â„\nâŠ¢ IntervalIntegrable (fun x => 1 / (1 + x ^ 2)) Î¼ a b"
    },
    {
      "name": "intrinsicClosure_nonempty",
      "statement": "ğ•œ : Type u_1\nV : Type u_2\nW : Type u_3\nQ : Type u_4\nP : Type u_5\ninstâœâ´ : Ring ğ•œ\ninstâœÂ³ : AddCommGroup V\ninstâœÂ² : Module ğ•œ V\ninstâœÂ¹ : TopologicalSpace P\ninstâœ : AddTorsor V P\ns t : Set P\nx : P\nâŠ¢ (intrinsicClosure ğ•œ s).Nonempty â†’ s.Nonempty"
    },
    {
      "name": "inv_mul_cancel_leftâ‚€",
      "statement": "Î± : Type u_1\nMâ‚€ : Type u_2\nGâ‚€ : Type u_3\nMâ‚€' : Type u_4\nGâ‚€' : Type u_5\nF : Type u_6\nF' : Type u_7\ninstâœ : GroupWithZero Gâ‚€\na bâœ c g hâœ x : Gâ‚€\nh : a â‰  0\nb : Gâ‚€\nâŠ¢ aâ»Â¹ * a * b = b"
    },
    {
      "name": "isAdjointPair_toLinearMapâ‚‚'",
      "statement": "R : Type u_1\nRâ‚ : Type u_2\nRâ‚‚ : Type u_3\nM : Type u_4\nMâ‚ : Type u_5\nMâ‚‚ : Type u_6\nMâ‚' : Type u_7\nMâ‚‚' : Type u_8\nn : Type u_9\nm : Type u_10\nn' : Type u_11\nm' : Type u_12\nÎ¹ : Type u_13\ninstâœâ¸ : CommRing R\ninstâœâ· : AddCommMonoid Mâ‚\ninstâœâ¶ : Module R Mâ‚\ninstâœâµ : AddCommMonoid Mâ‚‚\ninstâœâ´ : Module R Mâ‚‚\ninstâœÂ³ : Fintype n\ninstâœÂ² : Fintype n'\nbâ‚ : Basis n R Mâ‚\nbâ‚‚ : Basis n' R Mâ‚‚\nJ Jâ‚‚ : Matrix n n R\nJ' : Matrix n' n' R\nA : Matrix n' n R\nA' : Matrix n n' R\nAâ‚ Aâ‚‚ : Matrix n n R\ninstâœÂ¹ : DecidableEq n\ninstâœ : DecidableEq n'\nâŠ¢ (toLinearMapâ‚‚' J).IsAdjointPair (toLinearMapâ‚‚' J') (toLin' A) (toLin' A') â†” J.IsAdjointPair J' A A'"
    },
    {
      "name": "isComplete_iUnion_separated",
      "statement": "Î± : Type u\nÎ² : Type v\nuniformSpace : UniformSpace Î±\nÎ¹ : Sort u_1\ns : Î¹ â†’ Set Î±\nhs : âˆ€ (i : Î¹), IsComplete (s i)\nU : Set (Î± Ã— Î±)\nhU : U âˆˆ ğ“¤ Î±\nhd : âˆ€ (i j : Î¹), âˆ€ x âˆˆ s i, âˆ€ y âˆˆ s j, (x, y) âˆˆ U â†’ i = j\nâŠ¢ IsComplete (â‹ƒ i, s i)"
    },
    {
      "name": "isConnected_univ_pi",
      "statement": "Î± : Type u\nÎ² : Type v\nÎ¹ : Type u_1\nÏ€ : Î¹ â†’ Type u_2\ninstâœÂ¹ : TopologicalSpace Î±\nsâœ t u v : Set Î±\ninstâœ : (i : Î¹) â†’ TopologicalSpace (Ï€ i)\ns : (i : Î¹) â†’ Set (Ï€ i)\nâŠ¢ IsConnected (univ.pi s) â†” âˆ€ (i : Î¹), IsConnected (s i)"
    },
    {
      "name": "isExtreme_singleton",
      "statement": "ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nÎ¹ : Type u_4\nÏ€ : Î¹ â†’ Type u_5\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : SMul ğ•œ E\nA B C : Set E\nx : E\nâŠ¢ IsExtreme ğ•œ A {x} â†” x âˆˆ extremePoints ğ•œ A"
    },
    {
      "name": "isSeparatedMap_iff_isClosed_diagonal",
      "statement": "X : Type u_1\nY : Sort u_2\nA : Type ?u.7735\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace A\nf : X â†’ Y\nâŠ¢ IsSeparatedMap f â†” IsClosed (Function.pullbackDiagonal f)"
    },
    {
      "name": "isSolvable_of_comm",
      "statement": "Gâœ : Type u_1\nG' : Type u_2\ninstâœÂ¹ : Group Gâœ\ninstâœ : Group G'\nf : Gâœ â†’* G'\nG : Type u_3\nhG : Group G\nh : âˆ€ (a b : G), a * b = b * a\nâŠ¢ IsSolvable G"
    },
    {
      "name": "iterateFrobenius_inj",
      "statement": "R : Type u_1\ninstâœÂ² : CommRing R\ninstâœÂ¹ : IsReduced R\np n : â„•\ninstâœ : ExpChar R p\nx y : R\nH : (iterateFrobenius R p n) x = (iterateFrobenius R p n) y\nâŠ¢ x = y"
    },
    {
      "name": "jacobiThetaâ‚‚_neg_left",
      "statement": "z Ï„ : â„‚\nâŠ¢ jacobiThetaâ‚‚ (-z) Ï„ = jacobiThetaâ‚‚ z Ï„"
    },
    {
      "name": "le_iInfâ‚‚_iff",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ²â‚‚ : Type u_3\nÎ³ : Type u_4\nÎ¹ : Sort u_5\nÎ¹' : Sort u_6\nÎº : Î¹ â†’ Sort u_7\nÎº' : Î¹' â†’ Sort u_8\ninstâœ : CompleteLattice Î±\nfâœ g s t : Î¹ â†’ Î±\na b : Î±\nf : (i : Î¹) â†’ Îº i â†’ Î±\nâŠ¢ a â‰¤ â¨… i, â¨… j, f i j â†” âˆ€ (i : Î¹) (j : Îº i), a â‰¤ f i j"
    },
    {
      "name": "le_max_right",
      "statement": "Î± : Type u\ninstâœ : LinearOrder Î±\na b : Î±\nâŠ¢ b â‰¤ max a b"
    },
    {
      "name": "le_sup_iff",
      "statement": "Î± : Type u\nÎ² : Type v\ninstâœ : LinearOrder Î±\na b c d : Î±\nâŠ¢ a â‰¤ b âŠ” c â†” a â‰¤ b âˆ¨ a â‰¤ c"
    },
    {
      "name": "left_eq_midpoint_iff",
      "statement": "R : Type u_1\nV : Type u_2\nV' : Type u_3\nP : Type u_4\nP' : Type u_5\ninstâœâ· : Ring R\ninstâœâ¶ : Invertible 2\ninstâœâµ : AddCommGroup V\ninstâœâ´ : Module R V\ninstâœÂ³ : AddTorsor V P\ninstâœÂ² : AddCommGroup V'\ninstâœÂ¹ : Module R V'\ninstâœ : AddTorsor V' P'\nxâœ yâœ z x y : P\nâŠ¢ x = midpoint R x y â†” x = y"
    },
    {
      "name": "lp.coeFn_sum",
      "statement": "Î± : Type u_1\nE : Î± â†’ Type u_2\np q : â„â‰¥0âˆ\ninstâœ : (i : Î±) â†’ NormedAddCommGroup (E i)\nÎ¹ : Type u_3\nf : Î¹ â†’ â†¥(lp E p)\ns : Finset Î¹\nâŠ¢ â†‘(âˆ‘ i âˆˆ s, f i) = âˆ‘ i âˆˆ s, â†‘(f i)"
    },
    {
      "name": "lp.hasSum_single",
      "statement": "Î± : Type u_1\nE : Î± â†’ Type u_2\np q : â„â‰¥0âˆ\ninstâœâµ : (i : Î±) â†’ NormedAddCommGroup (E i)\nğ•œ : Type u_3\ninstâœâ´ : NormedRing ğ•œ\ninstâœÂ³ : (i : Î±) â†’ Module ğ•œ (E i)\ninstâœÂ² : âˆ€ (i : Î±), BoundedSMul ğ•œ (E i)\ninstâœÂ¹ : DecidableEq Î±\ninstâœ : Fact (1 â‰¤ p)\nhp : p â‰  âŠ¤\nf : â†¥(lp E p)\nâŠ¢ HasSum (fun i => lp.single p i (â†‘f i)) f"
    },
    {
      "name": "lp.single_smul",
      "statement": "Î± : Type u_1\nE : Î± â†’ Type u_2\npâœ q : â„â‰¥0âˆ\ninstâœâ´ : (i : Î±) â†’ NormedAddCommGroup (E i)\nğ•œ : Type u_3\ninstâœÂ³ : NormedRing ğ•œ\ninstâœÂ² : (i : Î±) â†’ Module ğ•œ (E i)\ninstâœÂ¹ : âˆ€ (i : Î±), BoundedSMul ğ•œ (E i)\ninstâœ : DecidableEq Î±\np : â„â‰¥0âˆ\ni : Î±\na : E i\nc : ğ•œ\nâŠ¢ lp.single p i (c â€¢ a) = c â€¢ lp.single p i a"
    },
    {
      "name": "lt_compl_self",
      "statement": "Î¹ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : HeytingAlgebra Î±\na b c : Î±\ninstâœ : Nontrivial Î±\nâŠ¢ a < aá¶œ â†” a = âŠ¥"
    },
    {
      "name": "lt_inv_mul_iff_lt",
      "statement": "Î± : Type u\ninstâœÂ² : Group Î±\ninstâœÂ¹ : LT Î±\ninstâœ : CovariantClass Î± Î± (fun x x_1 => x * x_1) fun x x_1 => x < x_1\na b c : Î±\nâŠ¢ 1 < bâ»Â¹ * a â†” b < a"
    },
    {
      "name": "lt_sup_iff",
      "statement": "Î± : Type u\nÎ² : Type v\ninstâœ : LinearOrder Î±\na b c d : Î±\nâŠ¢ a < b âŠ” c â†” a < b âˆ¨ a < c"
    },
    {
      "name": "matPolyEquiv_smul_one",
      "statement": "R : Type u_1\nA : Type u_2\ninstâœâ´ : CommSemiring R\ninstâœÂ³ : Semiring A\ninstâœÂ² : Algebra R A\nn : Type w\ninstâœÂ¹ : DecidableEq n\ninstâœ : Fintype n\np : R[X]\nâŠ¢ matPolyEquiv (p â€¢ 1) = Polynomial.map (algebraMap R (Matrix n n R)) p"
    },
    {
      "name": "max_le",
      "statement": "Î± : Type u\ninstâœ : LinearOrder Î±\na b c : Î±\nhâ‚ : a â‰¤ c\nhâ‚‚ : b â‰¤ c\nâŠ¢ max a b â‰¤ c"
    },
    {
      "name": "measurable_inv_iff",
      "statement": "Î±âœ : Type u_1\nGâœ : Type u_2\nÎ± : Type u_3\ninstâœâµ : Inv Gâœ\ninstâœâ´ : MeasurableSpace Gâœ\ninstâœÂ³ : MeasurableInv Gâœ\nm : MeasurableSpace Î±\nfâœ : Î± â†’ Gâœ\nÎ¼ : Measure Î±\nG : Type u_4\ninstâœÂ² : Group G\ninstâœÂ¹ : MeasurableSpace G\ninstâœ : MeasurableInv G\nf : Î± â†’ G\nh : Measurable fun x => (f x)â»Â¹\nâŠ¢ Measurable f"
    },
    {
      "name": "measurable_to_prop",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\nÎ´' : Type u_5\nÎ¹ : Sort uÎ¹\ns t u : Set Î±\ninstâœ : MeasurableSpace Î±\nf : Î± â†’ Prop\nh : MeasurableSet (f â»Â¹' {True})\nâŠ¢ Measurable f"
    },
    {
      "name": "mem_nhds_discrete",
      "statement": "Î± : Type u_1\nt tâ‚ tâ‚‚ : TopologicalSpace Î±\nsâœ : Set Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : DiscreteTopology Î±\nÎ² : Type u_2\nx : Î±\ns : Set Î±\nâŠ¢ s âˆˆ ğ“ x â†” x âˆˆ s"
    },
    {
      "name": "mem_primitiveRoots",
      "statement": "M : Type u_1\nN : Type u_2\nG : Type u_3\nR : Type u_4\nS : Type u_5\nF : Type u_6\ninstâœâ´ : CommMonoid M\ninstâœÂ³ : CommMonoid N\ninstâœÂ² : DivisionCommMonoid G\nk : â„•\ninstâœÂ¹ : CommRing R\ninstâœ : IsDomain R\nÎ¶ : R\nh0 : 0 < k\nâŠ¢ Î¶ âˆˆ primitiveRoots k R â†” IsPrimitiveRoot Î¶ k"
    },
    {
      "name": "mem_rootsOfUnity_prime_pow_mul_iff",
      "statement": "M : Type u_1\nN : Type u_2\nG : Type u_3\nR : Type u_4\nS : Type u_5\nF : Type u_6\ninstâœâµ : CommMonoid M\ninstâœâ´ : CommMonoid N\ninstâœÂ³ : DivisionCommMonoid G\nkâœ l : â„•+\ninstâœÂ² : CommRing R\ninstâœÂ¹ : IsReduced R\np k : â„•\nm : â„•+\ninstâœ : ExpChar R p\nÎ¶ : RË£\nâŠ¢ Î¶ âˆˆ rootsOfUnity (âŸ¨p, â‹¯âŸ© ^ k * m) R â†” Î¶ âˆˆ rootsOfUnity m R"
    },
    {
      "name": "mem_segment_translate",
      "statement": "ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\nÎ¹ : Type u_5\nÏ€ : Î¹ â†’ Type u_6\ninstâœâµ : OrderedRing ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : AddCommGroup F\ninstâœÂ² : AddCommGroup G\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œ F\na x b c : E\nâŠ¢ a + x âˆˆ [a + b-[ğ•œ]a + c] â†” x âˆˆ [b-[ğ•œ]c]"
    },
    {
      "name": "mfderiv_congr",
      "statement": "ğ•œ : Type u_1\ninstâœÂ¹âµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹â´ : NormedAddCommGroup E\ninstâœÂ¹Â³ : NormedSpace ğ•œ E\nH : Type u_3\ninstâœÂ¹Â² : TopologicalSpace H\nI : ModelWithCorners ğ•œ E H\nM : Type u_4\ninstâœÂ¹Â¹ : TopologicalSpace M\ninstâœÂ¹â° : ChartedSpace H M\nE' : Type u_5\ninstâœâ¹ : NormedAddCommGroup E'\ninstâœâ¸ : NormedSpace ğ•œ E'\nH' : Type u_6\ninstâœâ· : TopologicalSpace H'\nI' : ModelWithCorners ğ•œ E' H'\nM' : Type u_7\ninstâœâ¶ : TopologicalSpace M'\ninstâœâµ : ChartedSpace H' M'\nE'' : Type u_8\ninstâœâ´ : NormedAddCommGroup E''\ninstâœÂ³ : NormedSpace ğ•œ E''\nH'' : Type u_9\ninstâœÂ² : TopologicalSpace H''\nI'' : ModelWithCorners ğ•œ E'' H''\nM'' : Type u_10\ninstâœÂ¹ : TopologicalSpace M''\ninstâœ : ChartedSpace H'' M''\nf fâ‚€ fâ‚ : M â†’ M'\nx : M\ns t : Set M\ng : M' â†’ M''\nu : Set M'\nIs : SmoothManifoldWithCorners I M\nI's : SmoothManifoldWithCorners I' M'\nI''s : SmoothManifoldWithCorners I'' M''\nf'âœ fâ‚€' fâ‚' : TangentSpace I x â†’L[ğ•œ] TangentSpace I' (f x)\ng' : TangentSpace I' (f x) â†’L[ğ•œ] TangentSpace I'' (g (f x))\nn : â„•âˆ\nf' : M â†’ M'\nh : f = f'\nâŠ¢ mfderiv I I' f x = mfderiv I I' f' x"
    },
    {
      "name": "midpoint_add_sub",
      "statement": "R : Type u_1\nV : Type u_2\nV' : Type u_3\nP : Type u_4\nP' : Type u_5\ninstâœâ· : Ring R\ninstâœâ¶ : Invertible 2\ninstâœâµ : AddCommGroup V\ninstâœâ´ : Module R V\ninstâœÂ³ : AddTorsor V P\ninstâœÂ² : AddCommGroup V'\ninstâœÂ¹ : Module R V'\ninstâœ : AddTorsor V' P'\nxâœ yâœ z : P\nx y : V\nâŠ¢ midpoint R (x + y) (x - y) = x"
    },
    {
      "name": "midpoint_sub_add",
      "statement": "R : Type u_1\nV : Type u_2\nV' : Type u_3\nP : Type u_4\nP' : Type u_5\ninstâœâ· : Ring R\ninstâœâ¶ : Invertible 2\ninstâœâµ : AddCommGroup V\ninstâœâ´ : Module R V\ninstâœÂ³ : AddTorsor V P\ninstâœÂ² : AddCommGroup V'\ninstâœÂ¹ : Module R V'\ninstâœ : AddTorsor V' P'\nxâœ yâœ z : P\nx y : V\nâŠ¢ midpoint R (x - y) (x + y) = x"
    },
    {
      "name": "minpoly.coeff_zero_eq_zero",
      "statement": "A : Type u_1\nB : Type u_2\ninstâœÂ³ : Field A\ninstâœÂ² : Ring B\ninstâœÂ¹ : IsDomain B\ninstâœ : Algebra A B\nx : B\nhx : IsIntegral A x\nâŠ¢ (minpoly A x).coeff 0 = 0 â†” x = 0"
    },
    {
      "name": "minpoly.coeff_zero_ne_zero",
      "statement": "A : Type u_1\nB : Type u_2\ninstâœÂ³ : Field A\ninstâœÂ² : Ring B\ninstâœÂ¹ : IsDomain B\ninstâœ : Algebra A B\nx : B\nhx : IsIntegral A x\nh : x â‰  0\nâŠ¢ (minpoly A x).coeff 0 â‰  0"
    },
    {
      "name": "minpoly.prime",
      "statement": "A : Type u_1\nB : Type u_2\ninstâœÂ³ : Field A\ninstâœÂ² : Ring B\ninstâœÂ¹ : IsDomain B\ninstâœ : Algebra A B\nx : B\nhx : IsIntegral A x\nâŠ¢ Prime (minpoly A x)"
    },
    {
      "name": "minpoly.zero",
      "statement": "A : Type u_1\nB : Type u_2\ninstâœÂ³ : Field A\ninstâœÂ² : Ring B\ninstâœÂ¹ : Algebra A B\nx : B\ninstâœ : Nontrivial B\nâŠ¢ minpoly A 0 = X"
    },
    {
      "name": "monovary_invâ‚€",
      "statement": "Î¹ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : LinearOrderedSemifield Î±\ninstâœ : LinearOrderedSemifield Î²\ns : Set Î¹\nf fâ‚ fâ‚‚ : Î¹ â†’ Î±\ng gâ‚ gâ‚‚ : Î¹ â†’ Î²\nhf : StrongLT 0 f\nhg : StrongLT 0 g\nâŠ¢ Monovary fâ»Â¹ gâ»Â¹ â†” Monovary f g"
    },
    {
      "name": "mul_inv_lt_iff_le_mul'",
      "statement": "Î± : Type u\ninstâœÂ² : CommGroup Î±\ninstâœÂ¹ : LT Î±\ninstâœ : CovariantClass Î± Î± (fun x x_1 => x * x_1) fun x x_1 => x < x_1\na b c d : Î±\nâŠ¢ a * bâ»Â¹ < c â†” a < b * c"
    },
    {
      "name": "mul_zpow_neg_one",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nG : Type u_3\nM : Type u_4\ninstâœ : DivisionMonoid Î±\naâœ bâœ c d a b : Î±\nâŠ¢ (a * b) ^ (-1) = b ^ (-1) * a ^ (-1)"
    },
    {
      "name": "multiple_mem_adjoin_of_mem_localization_adjoin",
      "statement": "R S : Type u\ninstâœâ¹ : CommRing R\ninstâœâ¸ : CommRing S\nM : Submonoid R\nN : Submonoid S\nR' S' : Type u\ninstâœâ· : CommRing R'\ninstâœâ¶ : CommRing S'\nf : R â†’+* S\ninstâœâµ : Algebra R R'\ninstâœâ´ : Algebra S S'\ninstâœÂ³ : Algebra R' S\ninstâœÂ² : Algebra R S\ninstâœÂ¹ : IsScalarTower R R' S\ninstâœ : IsLocalization M R'\ns : Set S\nx : S\nhx : x âˆˆ Algebra.adjoin R' s\nâŠ¢ âˆƒ t, t â€¢ x âˆˆ Algebra.adjoin R s"
    },
    {
      "name": "negSucc_zsmul",
      "statement": "Gâœ : Type u_1\ninstâœÂ¹ : DivInvMonoid Gâœ\naâœ b : Gâœ\nG : Type u_2\ninstâœ : SubNegMonoid G\na : G\nn : â„•\nâŠ¢ Int.negSucc n â€¢ a = -((n + 1) â€¢ a)"
    },
    {
      "name": "neg_one_geom_sum",
      "statement": "Î± : Type u\ninstâœ : Ring Î±\nn : â„•\nâŠ¢ âˆ‘ i âˆˆ range n, (-1) ^ i = if Even n then 0 else 1"
    },
    {
      "name": "neg_one_sq",
      "statement": "Î± : Type u\nÎ² : Type v\nÎ³ : Type w\nR : Type x\ninstâœÂ¹ : Monoid R\ninstâœ : HasDistribNeg R\nâŠ¢ (-1) ^ 2 = 1"
    },
    {
      "name": "neg_strictConvexOn_iff",
      "statement": "ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nÎ± : Type u_4\nÎ² : Type u_5\nÎ¹ : Type u_6\ninstâœâµ : OrderedSemiring ğ•œ\ninstâœâ´ : AddCommMonoid E\ninstâœÂ³ : AddCommMonoid F\ninstâœÂ² : OrderedAddCommGroup Î²\ninstâœÂ¹ : SMul ğ•œ E\ninstâœ : Module ğ•œ Î²\ns : Set E\nf g : E â†’ Î²\nâŠ¢ StrictConvexOn ğ•œ s (-f) â†” StrictConcaveOn ğ•œ s f"
    },
    {
      "name": "nhdsWithin_empty",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\ninstâœ : TopologicalSpace Î±\na : Î±\nâŠ¢ ğ“[âˆ…] a = âŠ¥"
    },
    {
      "name": "nhdsWithin_le_nhds",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\ninstâœ : TopologicalSpace Î±\na : Î±\ns : Set Î±\nâŠ¢ ğ“[s] a â‰¤ ğ“ a"
    },
    {
      "name": "normEDS_four",
      "statement": "R : Type u\nS : Type v\ninstâœÂ¹ : CommRing R\ninstâœ : CommRing S\nW : â„¤ â†’ R\nf : R â†’+* S\nb c d : R\nâŠ¢ normEDS b c d 4 = d * b"
    },
    {
      "name": "normEDS_three",
      "statement": "R : Type u\nS : Type v\ninstâœÂ¹ : CommRing R\ninstâœ : CommRing S\nW : â„¤ â†’ R\nf : R â†’+* S\nb c d : R\nâŠ¢ normEDS b c d 3 = c"
    },
    {
      "name": "normUnit_mul_normUnit",
      "statement": "Î± : Type u_1\ninstâœÂ¹ : CancelCommMonoidWithZero Î±\ninstâœ : NormalizationMonoid Î±\na : Î±\nâŠ¢ normUnit (a * â†‘(normUnit a)) = 1"
    },
    {
      "name": "one_le_mabs",
      "statement": "Î± : Type u_1\ninstâœÂ³ : Lattice Î±\ninstâœÂ² : Group Î±\naâœ b : Î±\ninstâœÂ¹ : CovariantClass Î± Î± (fun x x_1 => x * x_1) fun x x_1 => x â‰¤ x_1\ninstâœ : CovariantClass Î± Î± (swap fun x x_1 => x * x_1) fun x x_1 => x â‰¤ x_1\na : Î±\nâŠ¢ 1 â‰¤ mabs a"
    },
    {
      "name": "one_sub_goldConj",
      "statement": "âŠ¢ 1 - Ï† = Ïˆ"
    },
    {
      "name": "orderOf_dvd_natCard",
      "statement": "Gâœ : Type u_1\nH : Type u_2\nA : Type u_3\nÎ± : Type u_4\nÎ² : Type u_5\ninstâœÂ² : Group Gâœ\ninstâœÂ¹ : Fintype Gâœ\nxâœ : Gâœ\nn : â„•\nG : Type u_6\ninstâœ : Group G\nx : G\nâŠ¢ orderOf x âˆ£ Nat.card G"
    },
    {
      "name": "padicNorm.div",
      "statement": "p : â„•\nhp : Fact (Nat.Prime p)\nq r : â„š\nhr : r = 0\nâŠ¢ padicNorm p (q / r) = padicNorm p q / padicNorm p r"
    },
    {
      "name": "padicNorm.mul",
      "statement": "p : â„•\nhp : Fact (Nat.Prime p)\nq r : â„š\nhq : q = 0\nâŠ¢ padicNorm p (q * r) = padicNorm p q * padicNorm p r"
    },
    {
      "name": "padicValNat.self",
      "statement": "p : â„•\nhp : 1 < p\nâŠ¢ padicValNat p p = 1"
    },
    {
      "name": "pow_mem_ball",
      "statement": "ğ“• : Type u_1\nğ•œ : Type u_2\nÎ± : Type u_3\nÎ¹ : Type u_4\nÎº : Type u_5\nE : Type u_6\nF : Type u_7\nG : Type u_8\ninstâœÂ¹ : SeminormedCommGroup E\ninstâœ : SeminormedCommGroup F\na aâ‚ aâ‚‚ b bâ‚ bâ‚‚ : E\nr râ‚ râ‚‚ : â„\nn : â„•\nhn : 0 < n\nh : a âˆˆ ball b r\nâŠ¢ a ^ n âˆˆ ball (b ^ n) (n â€¢ r)"
    },
    {
      "name": "pow_pos",
      "statement": "Î± : Type u\nÎ² : Type u_1\ninstâœ : StrictOrderedSemiring Î±\na b c d : Î±\nH : 0 < a\nâŠ¢ 0 < a ^ 0"
    },
    {
      "name": "pow_two",
      "statement": "G : Type u_1\nM : Type u_2\ninstâœ : Monoid M\naâœ b c : M\nm n : â„•\na : M\nâŠ¢ a ^ 2 = a * a"
    },
    {
      "name": "preNormEDS_ofNat",
      "statement": "R : Type u\nS : Type v\ninstâœÂ¹ : CommRing R\ninstâœ : CommRing S\nW : â„¤ â†’ R\nf : R â†’+* S\nb c d : R\nn : â„•\nâŠ¢ preNormEDS b c d â†‘n = preNormEDS' b c d n"
    },
    {
      "name": "prod_dvd_iff",
      "statement": "Î¹ : Type u_1\nGâ‚ : Type u_2\nGâ‚‚ : Type u_3\nG : Î¹ â†’ Type u_4\ninstâœÂ² : Semigroup Gâ‚\ninstâœÂ¹ : Semigroup Gâ‚‚\ninstâœ : (i : Î¹) â†’ Semigroup (G i)\nx y : Gâ‚ Ã— Gâ‚‚\nâŠ¢ x âˆ£ y â†” x.1 âˆ£ y.1 âˆ§ x.2 âˆ£ y.2"
    },
    {
      "name": "quasispectrumRestricts_iff_spectrumRestricts",
      "statement": "Râœ : Type u_1\nAâœ : Type u_2\ninstâœÂ¹â° : CommSemiring Râœ\ninstâœâ¹ : NonUnitalRing Aâœ\ninstâœâ¸ : Module Râœ Aâœ\ninstâœâ· : IsScalarTower Râœ Aâœ Aâœ\ninstâœâ¶ : SMulCommClass Râœ Aâœ Aâœ\nR : Type u_3\nS : Type u_4\nA : Type u_5\ninstâœâµ : Semifield R\ninstâœâ´ : Semifield S\ninstâœÂ³ : Ring A\ninstâœÂ² : Algebra R S\ninstâœÂ¹ : Algebra R A\ninstâœ : Algebra S A\na : A\nf : S â†’ R\nâŠ¢ QuasispectrumRestricts a f â†” SpectrumRestricts a f"
    },
    {
      "name": "range_two_mul",
      "statement": "F : Type u_1\nÎ±âœ : Type u_2\nÎ² : Type u_3\nR : Type u_4\ninstâœÂ² : Semiring Î±âœ\ninstâœÂ¹ : Semiring Î²\na b : Î±âœ\nm n : â„•\nÎ± : Type u_5\ninstâœ : Semiring Î±\nâŠ¢ (Set.range fun x => 2 * x) = {a | Even a}"
    },
    {
      "name": "rank_directSum",
      "statement": "R S : Type u\nMâœ : Type v\nM' : Type v'\nMâ‚ : Type v\nÎ¹âœ : Type w\nÎ¹' : Type w'\nÎ· : Type uâ‚'\nÏ† : Î· â†’ Type u_1\ninstâœÂ¹Â³ : Ring R\ninstâœÂ¹Â² : CommRing S\ninstâœÂ¹Â¹ : AddCommGroup Mâœ\ninstâœÂ¹â° : AddCommGroup M'\ninstâœâ¹ : AddCommGroup Mâ‚\ninstâœâ¸ : Module R Mâœ\ninstâœâ· : Module R M'\ninstâœâ¶ : Module R Mâ‚\ninstâœâµ : StrongRankCondition R\ninstâœâ´ : Module.Free R Mâœ\ninstâœÂ³ : Module.Free R M'\nÎ¹ : Type v\nM : Î¹ â†’ Type w\ninstâœÂ² : (i : Î¹) â†’ AddCommGroup (M i)\ninstâœÂ¹ : (i : Î¹) â†’ Module R (M i)\ninstâœ : âˆ€ (i : Î¹), Module.Free R (M i)\nâŠ¢ Module.rank R (â¨ (i : Î¹), M i) = sum fun i => Module.rank R (M i)"
    },
    {
      "name": "rank_finsupp_self",
      "statement": "R S : Type u\nM : Type v\nM' : Type v'\nMâ‚ : Type v\nÎ¹âœ : Type w\nÎ¹' : Type w'\nÎ· : Type uâ‚'\nÏ† : Î· â†’ Type u_1\ninstâœÂ¹â° : Ring R\ninstâœâ¹ : CommRing S\ninstâœâ¸ : AddCommGroup M\ninstâœâ· : AddCommGroup M'\ninstâœâ¶ : AddCommGroup Mâ‚\ninstâœâµ : Module R M\ninstâœâ´ : Module R M'\ninstâœÂ³ : Module R Mâ‚\ninstâœÂ² : StrongRankCondition R\ninstâœÂ¹ : Module.Free R M\ninstâœ : Module.Free R M'\nÎ¹ : Type w\nâŠ¢ Module.rank R (Î¹ â†’â‚€ R) = lift.{u, w} #Î¹"
    },
    {
      "name": "rank_fun",
      "statement": "R S : Type u\nMâœ : Type v\nM' : Type v'\nMâ‚ : Type v\nÎ¹ : Type w\nÎ¹' : Type w'\nÎ·âœ : Type uâ‚'\nÏ† : Î·âœ â†’ Type u_1\ninstâœÂ¹â· : Ring R\ninstâœÂ¹â¶ : CommRing S\ninstâœÂ¹âµ : AddCommGroup Mâœ\ninstâœÂ¹â´ : AddCommGroup M'\ninstâœÂ¹Â³ : AddCommGroup Mâ‚\ninstâœÂ¹Â² : Module R Mâœ\ninstâœÂ¹Â¹ : Module R M'\ninstâœÂ¹â° : Module R Mâ‚\ninstâœâ¹ : StrongRankCondition R\ninstâœâ¸ : Module.Free R Mâœ\ninstâœâ· : (i : Î·âœ) â†’ AddCommGroup (Ï† i)\ninstâœâ¶ : (i : Î·âœ) â†’ Module R (Ï† i)\ninstâœâµ : âˆ€ (i : Î·âœ), Module.Free R (Ï† i)\ninstâœâ´ : Fintype Î·âœ\nM Î· : Type u\ninstâœÂ³ : Fintype Î·\ninstâœÂ² : AddCommGroup M\ninstâœÂ¹ : Module R M\ninstâœ : Module.Free R M\nâŠ¢ Module.rank R (Î· â†’ M) = â†‘(Fintype.card Î·) * Module.rank R M"
    },
    {
      "name": "rank_pi",
      "statement": "R S : Type u\nM : Type v\nM' : Type v'\nMâ‚ : Type v\nÎ¹ : Type w\nÎ¹' : Type w'\nÎ· : Type uâ‚'\nÏ† : Î· â†’ Type u_1\ninstâœÂ¹Â³ : Ring R\ninstâœÂ¹Â² : CommRing S\ninstâœÂ¹Â¹ : AddCommGroup M\ninstâœÂ¹â° : AddCommGroup M'\ninstâœâ¹ : AddCommGroup Mâ‚\ninstâœâ¸ : Module R M\ninstâœâ· : Module R M'\ninstâœâ¶ : Module R Mâ‚\ninstâœâµ : StrongRankCondition R\ninstâœâ´ : Module.Free R M\ninstâœÂ³ : (i : Î·) â†’ AddCommGroup (Ï† i)\ninstâœÂ² : (i : Î·) â†’ Module R (Ï† i)\ninstâœÂ¹ : âˆ€ (i : Î·), Module.Free R (Ï† i)\ninstâœ : Finite Î·\nâŠ¢ Module.rank R ((i : Î·) â†’ Ï† i) = sum fun i => Module.rank R (Ï† i)"
    },
    {
      "name": "rank_subsingleton",
      "statement": "R : Type u\nR' : Type u'\nM Mâ‚ : Type v\nM' : Type v'\ninstâœÂ¹â° : Ring R\ninstâœâ¹ : Ring R'\ninstâœâ¸ : AddCommGroup M\ninstâœâ· : AddCommGroup M'\ninstâœâ¶ : AddCommGroup Mâ‚\ninstâœâµ : Module R M\ninstâœâ´ : Module R M'\ninstâœÂ³ : Module R Mâ‚\ninstâœÂ² : Module R' M'\ninstâœÂ¹ : Module R' Mâ‚\ninstâœ : Subsingleton R\nâŠ¢ Module.rank R M = 1"
    },
    {
      "name": "rank_tensorProduct",
      "statement": "R S : Type u\nM : Type v\nM' : Type v'\nMâ‚ : Type v\nÎ¹ : Type w\nÎ¹' : Type w'\nÎ· : Type uâ‚'\nÏ† : Î· â†’ Type u_1\ninstâœÂ¹â¹ : Ring R\ninstâœÂ¹â¸ : CommRing S\ninstâœÂ¹â· : AddCommGroup M\ninstâœÂ¹â¶ : AddCommGroup M'\ninstâœÂ¹âµ : AddCommGroup Mâ‚\ninstâœÂ¹â´ : Module R M\ninstâœÂ¹Â³ : Module R M'\ninstâœÂ¹Â² : Module R Mâ‚\ninstâœÂ¹Â¹ : StrongRankCondition R\ninstâœÂ¹â° : StrongRankCondition S\ninstâœâ¹ : Module S M\ninstâœâ¸ : Module.Free S M\ninstâœâ· : Module S M'\ninstâœâ¶ : Module.Free S M'\ninstâœâµ : Module S Mâ‚\ninstâœâ´ : Module.Free S Mâ‚\ninstâœÂ³ : Algebra S R\ninstâœÂ² : Module R M\ninstâœÂ¹ : IsScalarTower S R M\ninstâœ : Module.Free R M\nâŠ¢ Module.rank R (M âŠ—[S] M') = Cardinal.lift.{v', v} (Module.rank R M) * Cardinal.lift.{v, v'} (Module.rank S M')"
    },
    {
      "name": "rightCoset_mem_rightCoset",
      "statement": "Î± : Type u_1\ninstâœ : Group Î±\ns : Subgroup Î±\na : Î±\nha : a âˆˆ s\nb : Î±\nâŠ¢ b âˆˆ op a â€¢ â†‘s â†” b âˆˆ â†‘s"
    },
    {
      "name": "ringExpChar.eq_one",
      "statement": "Râœ : Type u\ninstâœÂ² : Semiring Râœ\nR : Type u_1\ninstâœÂ¹ : NonAssocSemiring R\ninstâœ : CharZero R\nâŠ¢ ringExpChar R = 1"
    },
    {
      "name": "round_neg_two_inv",
      "statement": "F : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : LinearOrderedField Î±\ninstâœ : FloorRing Î±\nâŠ¢ round (-2â»Â¹) = 0"
    },
    {
      "name": "sUnion_memPartition",
      "statement": "case zero\nÎ± : Type u_1\nf : â„• â†’ Set Î±\nâŠ¢ â‹ƒâ‚€ memPartition f 0 = univ"
    },
    {
      "name": "sbtw_one_zero_iff",
      "statement": "R : Type u_1\nV : Type u_2\nV' : Type u_3\nP : Type u_4\nP' : Type u_5\ninstâœâ¶ : OrderedRing R\ninstâœâµ : AddCommGroup V\ninstâœâ´ : Module R V\ninstâœÂ³ : AddTorsor V P\ninstâœÂ² : AddCommGroup V'\ninstâœÂ¹ : Module R V'\ninstâœ : AddTorsor V' P'\nx : R\nâŠ¢ Sbtw R 1 x 0 â†” x âˆˆ Set.Ioo 0 1"
    },
    {
      "name": "sbtw_zero_one_iff",
      "statement": "R : Type u_1\nV : Type u_2\nV' : Type u_3\nP : Type u_4\nP' : Type u_5\ninstâœâ¶ : OrderedRing R\ninstâœâµ : AddCommGroup V\ninstâœâ´ : Module R V\ninstâœÂ³ : AddTorsor V P\ninstâœÂ² : AddCommGroup V'\ninstâœÂ¹ : Module R V'\ninstâœ : AddTorsor V' P'\nx : R\nâŠ¢ Sbtw R 0 x 1 â†” x âˆˆ Set.Ioo 0 1"
    },
    {
      "name": "sdiff_le_sdiff_of_sup_le_sup_left",
      "statement": "Î¹ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœ : GeneralizedCoheytingAlgebra Î±\na b c d : Î±\nh : c âŠ” a â‰¤ c âŠ” b\nâŠ¢ a \\ c â‰¤ b \\ c"
    },
    {
      "name": "sdiff_symmDiff_right",
      "statement": "Î¹ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nÏ€ : Î¹ â†’ Type u_4\ninstâœ : GeneralizedBooleanAlgebra Î±\na b c d : Î±\nâŠ¢ b \\ a âˆ† b = a âŠ“ b"
    },
    {
      "name": "selfZPow_neg_natCast",
      "statement": "R : Type u_1\ninstâœÂ³ : CommRing R\nx : R\nB : Type u_2\ninstâœÂ² : CommRing B\ninstâœÂ¹ : Algebra R B\ninstâœ : IsLocalization.Away x B\nd : â„•\nâŠ¢ selfZPow x B (-â†‘d) = mk' B 1 (Submonoid.pow x d)"
    },
    {
      "name": "selfZPow_sub_natCast",
      "statement": "R : Type u_1\ninstâœÂ³ : CommRing R\nx : R\nB : Type u_2\ninstâœÂ² : CommRing B\ninstâœÂ¹ : Algebra R B\ninstâœ : IsLocalization.Away x B\nn m : â„•\nâŠ¢ selfZPow x B (â†‘n - â†‘m) = mk' B (x ^ n) (Submonoid.pow x m)"
    },
    {
      "name": "sign_nonneg_iff",
      "statement": "Î± : Type u_1\ninstâœÂ¹ : Zero Î±\ninstâœ : LinearOrder Î±\na : Î±\nâŠ¢ 0 â‰¤ sign a â†” 0 â‰¤ a"
    },
    {
      "name": "slope_vadd_const",
      "statement": "k : Type u_1\nE : Type u_2\nPE : Type u_3\ninstâœÂ³ : Field k\ninstâœÂ² : AddCommGroup E\ninstâœÂ¹ : Module k E\ninstâœ : AddTorsor E PE\nf : k â†’ E\nc : PE\nâŠ¢ (slope fun x => f x +áµ¥ c) = slope f"
    },
    {
      "name": "smul_ball_one",
      "statement": "E : Type u_1\ninstâœ : SeminormedCommGroup E\nÎµ Î´ : â„\ns t : Set E\nx y : E\nâŠ¢ x â€¢ ball 1 Î´ = ball x Î´"
    },
    {
      "name": "smul_ceilDiv",
      "statement": "Î¹ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœâµ : OrderedSemiring Î±\ninstâœâ´ : OrderedAddCommMonoid Î²\ninstâœÂ³ : MulActionWithZero Î± Î²\ninstâœÂ² : CeilDiv Î± Î²\na : Î±\ninstâœÂ¹ : PosSMulMono Î± Î²\ninstâœ : PosSMulReflectLE Î± Î²\nha : 0 < a\nb : Î²\nâŠ¢ âˆ€ (c : Î²), a â€¢ b âŒˆ/âŒ‰ a â‰¤ c â†” b â‰¤ c"
    },
    {
      "name": "smul_inv_smul",
      "statement": "Î± : Type u\nÎ² : Type v\nÎ³ : Type w\ninstâœÂ¹ : Group Î±\ninstâœ : MulAction Î± Î²\nc : Î±\nx : Î²\nâŠ¢ c â€¢ câ»Â¹ â€¢ x = x"
    },
    {
      "name": "solvableByRad.induction3",
      "statement": "F : Type u_1\ninstâœÂ² : Field F\nE : Type u_2\ninstâœÂ¹ : Field E\ninstâœ : Algebra F E\nÎ±âœ : E\nÎ± : â†¥(solvableByRad F E)\nn : â„•\nhn : n â‰  0\nhÎ± : P (Î± ^ n)\nâŠ¢ P Î±"
    },
    {
      "name": "star_lt_star_iff",
      "statement": "R : Type u\ninstâœÂ³ : NonUnitalSemiring R\ninstâœÂ² : PartialOrder R\ninstâœÂ¹ : StarRing R\ninstâœ : StarOrderedRing R\nx y : R\nâŠ¢ star x < star y â†” x < y"
    },
    {
      "name": "stereographic_apply_neg",
      "statement": "E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace â„ E\nvâœ : E\nv : â†‘(sphere 0 1)\nâŠ¢ â†‘(stereographic â‹¯) (-v) = 0"
    },
    {
      "name": "stereographic_neg_apply",
      "statement": "E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace â„ E\nvâœ : E\nv : â†‘(sphere 0 1)\nâŠ¢ â†‘(stereographic â‹¯) v = 0"
    },
    {
      "name": "strictMonoOn_dual_iff",
      "statement": "Î¹ : Type u_1\nÎ± : Type u\nÎ² : Type v\nÎ³ : Type w\nÎ´ : Type u_2\nÏ€ : Î¹ â†’ Type u_3\nr : Î± â†’ Î± â†’ Prop\ninstâœÂ¹ : Preorder Î±\ninstâœ : Preorder Î²\nf : Î± â†’ Î²\ns : Set Î±\nâŠ¢ StrictMonoOn (â‡‘toDual âˆ˜ f âˆ˜ â‡‘ofDual) s â†” StrictMonoOn f s"
    },
    {
      "name": "sub_one_mul",
      "statement": "Î± : Type u\nÎ² : Type v\nÎ³ : Type w\nR : Type x\ninstâœ : NonAssocRing Î±\na b : Î±\nâŠ¢ (a - 1) * b = a * b - b"
    },
    {
      "name": "sub_smul_slope",
      "statement": "k : Type u_1\nE : Type u_2\nPE : Type u_3\ninstâœÂ³ : Field k\ninstâœÂ² : AddCommGroup E\ninstâœÂ¹ : Module k E\ninstâœ : AddTorsor E PE\nf : k â†’ PE\na b : k\nâŠ¢ (b - a) â€¢ slope f a b = f b -áµ¥ f a"
    },
    {
      "name": "sum_bernoulli",
      "statement": "A : Type u_1\ninstâœÂ¹ : CommRing A\ninstâœ : Algebra â„š A\nn : â„•\nâŠ¢ âˆ‘ k âˆˆ range n, â†‘(n.choose k) * bernoulli k = if n = 1 then 1 else 0"
    },
    {
      "name": "symmDiff_eq_left",
      "statement": "Î¹ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nÏ€ : Î¹ â†’ Type u_4\ninstâœ : GeneralizedBooleanAlgebra Î±\na b c d : Î±\nâŠ¢ a âˆ† b = a â†” a âˆ† b = a âˆ† âŠ¥"
    },
    {
      "name": "symmDiff_hnot_self",
      "statement": "Î¹ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nÏ€ : Î¹ â†’ Type u_4\ninstâœ : CoheytingAlgebra Î±\na : Î±\nâŠ¢ a âˆ† (ï¿¢a) = âŠ¤"
    },
    {
      "name": "symmDiff_sdiff_inf",
      "statement": "Î¹ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nÏ€ : Î¹ â†’ Type u_4\ninstâœ : GeneralizedCoheytingAlgebra Î±\na b c d : Î±\nâŠ¢ a âˆ† b \\ (a âŠ“ b) = a âˆ† b"
    },
    {
      "name": "symmDiff_sup_inf",
      "statement": "Î¹ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nÏ€ : Î¹ â†’ Type u_4\ninstâœ : GeneralizedCoheytingAlgebra Î±\na b c d : Î±\nâŠ¢ a âˆ† b âŠ” a âŠ“ b = a âŠ” b"
    },
    {
      "name": "tendsto_Ioi_atBot",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : LinearOrder Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : DenselyOrdered Î±\na b : Î±\ns : Set Î±\nl : Filter Î²\nfâœ : Î± â†’ Î²\nf : Î² â†’ â†‘(Ioi a)\nâŠ¢ Tendsto f l atBot â†” Tendsto (fun x => â†‘(f x)) l (ğ“[>] a)"
    },
    {
      "name": "tendsto_Ioo_atBot",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : LinearOrder Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : DenselyOrdered Î±\na b : Î±\ns : Set Î±\nl : Filter Î²\nfâœ : Î± â†’ Î²\nf : Î² â†’ â†‘(Ioo a b)\nâŠ¢ Tendsto f l atBot â†” Tendsto (fun x => â†‘(f x)) l (ğ“[>] a)"
    },
    {
      "name": "tendsto_iff_dist_tendsto_zero",
      "statement": "Î± : Type u\nÎ² : Type v\nX : Type u_1\nÎ¹ : Type u_2\ninstâœ : PseudoMetricSpace Î±\nf : Î² â†’ Î±\nx : Filter Î²\na : Î±\nâŠ¢ Tendsto f x (ğ“ a) â†” Tendsto (fun b => dist (f b) a) x (ğ“ 0)"
    },
    {
      "name": "tendsto_indicator_const_apply_iff_eventually",
      "statement": "Î± : Type u_1\nA : Set Î±\nÎ² : Type u_2\ninstâœÂ³ : Zero Î²\ninstâœÂ² : TopologicalSpace Î²\nÎ¹ : Type u_3\nL : Filter Î¹\nAs : Î¹ â†’ Set Î±\ninstâœÂ¹ : T1Space Î²\nb : Î²\ninstâœ : NeZero b\nx : Î±\nâŠ¢ Tendsto (fun i => (As i).indicator (fun x => b) x) L (ğ“ (A.indicator (fun x => b) x)) â†”\n    âˆ€á¶  (i : Î¹) in L, x âˆˆ As i â†” x âˆˆ A"
    },
    {
      "name": "toAdd_multiset_sum",
      "statement": "Î¹ : Type u_1\nÎº : Type u_2\nÎ± : Type u_3\nÎ² : Type u_4\nÎ³ : Type u_5\nsâœ sâ‚ sâ‚‚ : Finset Î±\na : Î±\nf g : Î± â†’ Î²\ninstâœ : AddCommMonoid Î±\ns : Multiset (Multiplicative Î±)\nâŠ¢ toAdd s.prod = (Multiset.map (â‡‘toAdd) s).sum"
    },
    {
      "name": "toIcoDiv_add_left",
      "statement": "Î± : Type u_1\ninstâœ : LinearOrderedAddCommGroup Î±\nhÎ± : Archimedean Î±\np : Î±\nhp : 0 < p\naâœ bâœ c : Î±\nn : â„¤\na b : Î±\nâŠ¢ toIcoDiv hp a (p + b) = toIcoDiv hp a b + 1"
    },
    {
      "name": "toIcoDiv_add_zsmul'",
      "statement": "Î± : Type u_1\ninstâœ : LinearOrderedAddCommGroup Î±\nhÎ± : Archimedean Î±\np : Î±\nhp : 0 < p\naâœ bâœ c : Î±\nn : â„¤\na b : Î±\nm : â„¤\nâŠ¢ toIcoDiv hp (a + m â€¢ p) b = toIcoDiv hp a b - m"
    },
    {
      "name": "toIcoMod_add_left'",
      "statement": "Î± : Type u_1\ninstâœ : LinearOrderedAddCommGroup Î±\nhÎ± : Archimedean Î±\np : Î±\nhp : 0 < p\naâœ bâœ c : Î±\nn : â„¤\na b : Î±\nâŠ¢ toIcoMod hp (p + a) b = p + toIcoMod hp a b"
    },
    {
      "name": "toIocDiv_zsmul_sub_toIocMod",
      "statement": "Î± : Type u_1\ninstâœ : LinearOrderedAddCommGroup Î±\nhÎ± : Archimedean Î±\np : Î±\nhp : 0 < p\naâœ bâœ c : Î±\nn : â„¤\na b : Î±\nâŠ¢ toIocDiv hp a b â€¢ p + toIocMod hp a b = b"
    },
    {
      "name": "toSubalgebra_toIntermediateField",
      "statement": "K : Type u_1\nL : Type u_2\nL' : Type u_3\ninstâœâ´ : Field K\ninstâœÂ³ : Field L\ninstâœÂ² : Field L'\ninstâœÂ¹ : Algebra K L\ninstâœ : Algebra K L'\nSâœ : IntermediateField K L\nS : Subalgebra K L\ninv_mem : âˆ€ x âˆˆ S, xâ»Â¹ âˆˆ S\nâŠ¢ (S.toIntermediateField inv_mem).toSubalgebra = S"
    },
    {
      "name": "ultrafilter_extend_extends",
      "statement": "Î± : Type u\nÎ³ : Type u_1\ninstâœÂ¹ : TopologicalSpace Î³\ninstâœ : T2Space Î³\nf : Î± â†’ Î³\nâŠ¢ Ultrafilter.extend f âˆ˜ pure = f"
    },
    {
      "name": "unitInterval.one_minus_le_one",
      "statement": "x : â†‘I\nâŠ¢ 1 - â†‘x â‰¤ 1"
    },
    {
      "name": "unitInterval.one_minus_nonneg",
      "statement": "x : â†‘I\nâŠ¢ 0 â‰¤ 1 - â†‘x"
    },
    {
      "name": "units_smul_eq_self_iff",
      "statement": "R : Type u_1\ninstâœÂ³ : LinearOrderedCommRing R\nM : Type u_2\ninstâœÂ² : AddCommGroup M\ninstâœÂ¹ : Module R M\ninstâœ : NoZeroSMulDivisors R M\nu : RË£\nv : Module.Ray R M\nâŠ¢ u â€¢ v = v â†” 0 < â†‘u"
    },
    {
      "name": "upperClosure_sups",
      "statement": "F : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœ : SemilatticeSup Î±\ns t : Set Î±\nâŠ¢ upperClosure (s âŠ» t) = upperClosure s âŠ” upperClosure t"
    },
    {
      "name": "vadd_vsub_vadd_cancel_left",
      "statement": "G : Type u_1\nP : Type u_2\ninstâœÂ¹ : AddCommGroup G\ninstâœ : AddTorsor G P\nv : G\npâ‚ pâ‚‚ : P\nâŠ¢ v +áµ¥ pâ‚ -áµ¥ (v +áµ¥ pâ‚‚) = pâ‚ -áµ¥ pâ‚‚"
    },
    {
      "name": "wbtw_lineMap_iff",
      "statement": "R : Type u_1\nV : Type u_2\nV' : Type u_3\nP : Type u_4\nP' : Type u_5\ninstâœâ· : OrderedRing R\ninstâœâ¶ : AddCommGroup V\ninstâœâµ : Module R V\ninstâœâ´ : AddTorsor V P\ninstâœÂ³ : AddCommGroup V'\ninstâœÂ² : Module R V'\ninstâœÂ¹ : AddTorsor V' P'\ninstâœ : NoZeroSMulDivisors R V\nx y : P\nr : R\nâŠ¢ Wbtw R x ((lineMap x y) r) y â†” x = y âˆ¨ r âˆˆ Set.Icc 0 1"
    },
    {
      "name": "wbtw_zero_one_iff",
      "statement": "R : Type u_1\nV : Type u_2\nV' : Type u_3\nP : Type u_4\nP' : Type u_5\ninstâœâ¶ : OrderedRing R\ninstâœâµ : AddCommGroup V\ninstâœâ´ : Module R V\ninstâœÂ³ : AddTorsor V P\ninstâœÂ² : AddCommGroup V'\ninstâœÂ¹ : Module R V'\ninstâœ : AddTorsor V' P'\nx : R\nâŠ¢ Wbtw R 0 x 1 â†” x âˆˆ Set.Icc 0 1"
    },
    {
      "name": "wellFounded_liftâ‚‚_iff",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\nrâœ : Î± â†’ Î± â†’ Prop\ns : Î² â†’ Î² â†’ Prop\nt : Î³ â†’ Î³ â†’ Prop\nu : Î´ â†’ Î´ â†’ Prop\ninstâœ : Setoid Î±\nr : Î± â†’ Î± â†’ Prop\nH : âˆ€ (aâ‚ bâ‚ aâ‚‚ bâ‚‚ : Î±), aâ‚ â‰ˆ aâ‚‚ â†’ bâ‚ â‰ˆ bâ‚‚ â†’ r aâ‚ bâ‚ = r aâ‚‚ bâ‚‚\nâŠ¢ WellFounded (Quotient.liftâ‚‚ r H) â†” WellFounded r"
    },
    {
      "name": "zpow_neg",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nG : Type u_3\nM : Type u_4\ninstâœ : DivisionMonoid Î±\naâœ b c d a : Î±\nâŠ¢ a ^ (-0) = (a ^ 0)â»Â¹"
    }
  ]
}
