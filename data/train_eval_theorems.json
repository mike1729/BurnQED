{
  "theorems": [
    {
      "name": "equicontinuous_iInf_rng",
      "statement": "Î¹ : Type u_1\nÎº : Type u_2\nX : Type u_3\nX' : Type u_4\nY : Type u_5\nZ : Type u_6\nÎ± : Type u_7\nÎ±' : Type u_8\nÎ² : Type u_9\nÎ²' : Type u_10\nÎ³ : Type u_11\nğ“• : Type u_12\ntX : TopologicalSpace X\ntY : TopologicalSpace Y\ntZ : TopologicalSpace Z\nuÎ± : UniformSpace Î±\nuÎ² : UniformSpace Î²\nuÎ³ : UniformSpace Î³\nu : Îº â†’ UniformSpace Î±'\nF : Î¹ â†’ X â†’ Î±'\nâŠ¢ Equicontinuous F â†” âˆ€ (k : Îº), Equicontinuous F"
    },
    {
      "name": "symmDiff_hnot_self",
      "statement": "Î¹ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nÏ€ : Î¹ â†’ Type u_4\ninstâœ : CoheytingAlgebra Î±\na : Î±\nâŠ¢ a âˆ† (ï¿¢a) = âŠ¤"
    },
    {
      "name": "ENNReal.toReal_eq_toReal_iff",
      "statement": "Î± : Type u_1\na b c d : â„â‰¥0âˆ\nr p q : â„â‰¥0\nx y : â„â‰¥0âˆ\nâŠ¢ x.toReal = y.toReal â†” x = y âˆ¨ x = 0 âˆ§ y = âŠ¤ âˆ¨ x = âŠ¤ âˆ§ y = 0"
    },
    {
      "name": "AdicCompletion.mk_zero_of",
      "statement": "R : Type u_1\ninstâœâ´ : CommRing R\nI : Ideal R\nM : Type u_2\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\nN : Type u_3\ninstâœÂ¹ : AddCommGroup N\ninstâœ : Module R N\nf : AdicCauchySequence I M\nh : âˆƒ k, âˆ€ n â‰¥ k, âˆƒ m â‰¥ n, âˆƒ l â‰¥ n, â†‘f m âˆˆ I ^ l â€¢ âŠ¤\nâŠ¢ (mk I M) f = 0"
    },
    {
      "name": "MeasureTheory.IsStoppingTime.min",
      "statement": "Î© : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœ : LinearOrder Î¹\nf : Filtration Î¹ m\nÏ„ Ï€ : Î© â†’ Î¹\nhÏ„ : IsStoppingTime f Ï„\nhÏ€ : IsStoppingTime f Ï€\nâŠ¢ IsStoppingTime f fun Ï‰ => min (Ï„ Ï‰) (Ï€ Ï‰)"
    },
    {
      "name": "WeierstrassCurve.Affine.evalEval_polynomialY_zero",
      "statement": "R : Type u\ninstâœ : CommRing R\nW : Affine R\nâŠ¢ evalEval 0 0 W.polynomialY = W.aâ‚ƒ"
    },
    {
      "name": "Polynomial.Monic.geom_sum",
      "statement": "R : Type u\nS : Type u_1\ninstâœ : Semiring R\nP : R[X]\nhP : P.Monic\nhdeg : 0 < P.natDegree\nn : â„•\nhn : n â‰  0\nâŠ¢ (âˆ‘ i âˆˆ range n, P ^ i).Monic"
    },
    {
      "name": "PowerSeries.monomial_eq_mk",
      "statement": "R : Type u_1\ninstâœ : Semiring R\nn : â„•\na : R\nm : â„•\nâŠ¢ (coeff R m) ((monomial R n) a) = (coeff R m) (mk fun m => if m = n then a else 0)"
    },
    {
      "name": "Projectivization.submodule_injective",
      "statement": "K : Type u_1\nV : Type u_2\ninstâœÂ² : DivisionRing K\ninstâœÂ¹ : AddCommGroup V\ninstâœ : Module K V\nu v : â„™ K V\nh : u.submodule = v.submodule\nâŠ¢ u = v"
    },
    {
      "name": "Trivialization.frontier_preimage",
      "statement": "Î¹ : Type u_1\nB : Type u_2\nF : Type u_3\nE : B â†’ Type u_4\nZ : Type u_5\ninstâœâ´ : TopologicalSpace B\ninstâœÂ³ : TopologicalSpace F\nproj : Z â†’ B\ninstâœÂ² : TopologicalSpace Z\ninstâœÂ¹ : TopologicalSpace (TotalSpace F E)\neâœ : Trivialization F proj\nx : Z\ne' : Trivialization F TotalSpace.proj\nx' : TotalSpace F E\nb : B\ny : E b\nB' : Type u_6\ninstâœ : TopologicalSpace B'\ne : Trivialization F proj\ns : Set B\nâŠ¢ e.source âˆ© frontier (proj â»Â¹' s) = proj â»Â¹' (e.baseSet âˆ© frontier s)"
    },
    {
      "name": "LieAlgebra.IsKilling.traceForm_eq_zero_of_mem_ker_of_mem_span_coroot",
      "statement": "R : Type u_1\nK : Type u_2\nL : Type u_3\ninstâœâ¹ : CommRing R\ninstâœâ¸ : LieRing L\ninstâœâ· : LieAlgebra R L\ninstâœâ¶ : Field K\ninstâœâµ : LieAlgebra K L\ninstâœâ´ : FiniteDimensional K L\nH : LieSubalgebra K L\ninstâœÂ³ : H.IsCartanSubalgebra\ninstâœÂ² : IsTriangularizable K (â†¥H) L\ninstâœÂ¹ : IsKilling K L\ninstâœ : CharZero K\nÎ± : Weight K (â†¥H) L\nx y : â†¥H\nhx : x âˆˆ Weight.ker\nhy : y âˆˆ span K {coroot Î±}\nâŠ¢ ((traceForm K (â†¥H) L) x) y = 0"
    },
    {
      "name": "Set.pairwise_univ",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ¹ : Type u_4\nÎ¹' : Type u_5\nr p q : Î± â†’ Î± â†’ Prop\nf g : Î¹ â†’ Î±\ns t u : Set Î±\na b : Î±\nâŠ¢ univ.Pairwise r â†” Pairwise r"
    },
    {
      "name": "ContinuousMonoidHom.range_toContinuousMap",
      "statement": "F : Type u_1\nA : Type u_2\nB : Type u_3\nC : Type u_4\nD : Type u_5\nE : Type u_6\ninstâœÂ¹â° : Monoid A\ninstâœâ¹ : Monoid B\ninstâœâ¸ : Monoid C\ninstâœâ· : Monoid D\ninstâœâ¶ : CommGroup E\ninstâœâµ : TopologicalSpace A\ninstâœâ´ : TopologicalSpace B\ninstâœÂ³ : TopologicalSpace C\ninstâœÂ² : TopologicalSpace D\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : TopologicalGroup E\nâŠ¢ Set.range toContinuousMap = {f | f 1 = 1 âˆ§ âˆ€ (x y : A), f (x * y) = f x * f y}"
    },
    {
      "name": "HasFiniteFPowerSeriesOnBall.changeOrigin",
      "statement": "ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf g : E â†’ F\np pf pg : FormalMultilinearSeries ğ•œ E F\nxâœ : E\nr r' : â„â‰¥0âˆ\nn m : â„•\nx y : E\nhf : HasFiniteFPowerSeriesOnBall f p x n r\nh : â†‘â€–yâ€–â‚Š < r\nâŠ¢ 0 < r - â†‘â€–yâ€–â‚Š"
    },
    {
      "name": "integral_exp_neg_mul_rpow",
      "statement": "p b : â„\nhp : 0 < p\nhb : 0 < b\nâŠ¢ âˆ« (x : â„) in Ioi 0, rexp (-b * x ^ p) = b ^ (-1 / p) * Gamma (1 / p + 1)"
    },
    {
      "name": "IsCompact.nonempty_iInter_of_directed_nonempty_isCompact_isClosed",
      "statement": "X : Type u\nY : Type v\nÎ¹âœ : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\ns tâœ : Set X\nÎ¹ : Type v\nhÎ¹ : Nonempty Î¹\nt : Î¹ â†’ Set X\nhtd : Directed (fun x x_1 => x âŠ‡ x_1) t\nhtn : âˆ€ (i : Î¹), (t i).Nonempty\nhtc : âˆ€ (i : Î¹), IsCompact (t i)\nhtcl : âˆ€ (i : Î¹), IsClosed (t i)\nâŠ¢ (â‹‚ i, t i).Nonempty"
    },
    {
      "name": "List.takeWhile_cons_of_pos",
      "statement": "Î¹ : Type u_1\nÎ± : Type u\nÎ² : Type v\nÎ³ : Type w\nlâ‚ lâ‚‚ : List Î±\np : Î± â†’ Bool\nl : List Î±\nx : Î±\nh : p x = true\nâŠ¢ takeWhile p (x :: l) = x :: takeWhile p l"
    },
    {
      "name": "round_neg_two_inv",
      "statement": "F : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : LinearOrderedField Î±\ninstâœ : FloorRing Î±\nâŠ¢ round (-2â»Â¹) = 0"
    },
    {
      "name": "Nat.multinomial_insert",
      "statement": "Î± : Type u_1\ns : Finset Î±\nfâœ : Î± â†’ â„•\na b : Î±\nn : â„•\ninstâœ : DecidableEq Î±\nha : a âˆ‰ s\nf : Î± â†’ â„•\nâŠ¢ multinomial (insert a s) f = (f a + âˆ‘ i âˆˆ s, f i).choose (f a) * multinomial s f"
    },
    {
      "name": "Finset.image_congr",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœ : DecidableEq Î²\nf g : Î± â†’ Î²\ns : Finset Î±\nt : Finset Î²\na : Î±\nb c : Î²\nh : Set.EqOn f g â†‘s\nâŠ¢ image f s = image g s"
    },
    {
      "name": "Ordinal.familyOfBFamily_enum",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nr : Î± â†’ Î± â†’ Prop\ns : Î² â†’ Î² â†’ Prop\nt : Î³ â†’ Î³ â†’ Prop\no : Ordinal.{?u.155550}\nf : (a : Ordinal.{?u.155550}) â†’ a < o â†’ Î±\ni : Ordinal.{?u.155550}\nhi : i < o\nâŠ¢ i < type fun x x_1 => x < x_1"
    },
    {
      "name": "Real.cos_sq_le_one",
      "statement": "x y : â„\nâŠ¢ cos x ^ 2 â‰¤ 1"
    },
    {
      "name": "CategoryTheory.eqToIso_trans",
      "statement": "C : Type uâ‚\ninstâœ : Category.{vâ‚, uâ‚} C\nÎ² : Sort u_1\nX Y Z : C\np : X = Y\nq : Y = Z\nâŠ¢ eqToIso p â‰ªâ‰« eqToIso q = eqToIso â‹¯"
    },
    {
      "name": "OrderIso.refl_trans",
      "statement": "F : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\nÎ´ : Type u_5\ninstâœÂ² : LE Î±\ninstâœÂ¹ : LE Î²\ninstâœ : LE Î³\ne : Î± â‰ƒo Î²\nâŠ¢ (refl Î±).trans e = e"
    },
    {
      "name": "Set.image_eq",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nf : Î± â†’ Î²\ns : Set Î±\nâŠ¢ f '' s = (Function.graph f).image s"
    },
    {
      "name": "Nat.floorRoot_def",
      "statement": "a b n : â„•\nâŠ¢ n.floorRoot a = if n = 0 âˆ¨ a = 0 then 0 else (a.factorization âŒŠ/âŒ‹ n).prod fun x x_1 => x ^ x_1"
    },
    {
      "name": "InnerProductGeometry.angle_comm",
      "statement": "V : Type u_1\ninstâœÂ¹ : NormedAddCommGroup V\ninstâœ : InnerProductSpace â„ V\nxâœ yâœ x y : V\nâŠ¢ angle x y = angle y x"
    },
    {
      "name": "Nat.even_xor_odd'",
      "statement": "F : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nR : Type u_4\nm nâœ n : â„•\nâŠ¢ âˆƒ k, Xor' (n = 2 * k) (n = 2 * k + 1)"
    },
    {
      "name": "SetLike.coe_list_dProd",
      "statement": "Î¹ : Type u_1\nR : Type u_2\nÎ± : Type u_3\nS : Type u_4\ninstâœÂ³ : SetLike S R\ninstâœÂ² : Monoid R\ninstâœÂ¹ : AddMonoid Î¹\nA : Î¹ â†’ S\ninstâœ : GradedMonoid A\nfÎ¹ : Î± â†’ Î¹\nfA : (a : Î±) â†’ â†¥(A (fÎ¹ a))\nl : List Î±\nâŠ¢ â†‘(l.dProd fÎ¹ fA) = (List.map (fun a => â†‘(fA a)) l).prod"
    },
    {
      "name": "Matrix.vecMul_transpose",
      "statement": "l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nm' : o â†’ Type u_5\nn' : o â†’ Type u_6\nR : Type u_7\nS : Type u_8\nÎ± : Type v\nÎ² : Type w\nÎ³ : Type u_9\ninstâœÂ¹ : NonUnitalCommSemiring Î±\ninstâœ : Fintype n\nA : Matrix m n Î±\nx : n â†’ Î±\nâŠ¢ x áµ¥* Aáµ€ = A *áµ¥ x"
    },
    {
      "name": "Matrix.exp_neg",
      "statement": "ğ•‚ : Type u_1\nm : Type u_2\nn : Type u_3\np : Type u_4\nn' : m â†’ Type u_5\nğ”¸ : Type u_6\ninstâœâ¹ : RCLike ğ•‚\ninstâœâ¸ : Fintype m\ninstâœâ· : DecidableEq m\ninstâœâ¶ : Fintype n\ninstâœâµ : DecidableEq n\ninstâœâ´ : (i : m) â†’ Fintype (n' i)\ninstâœÂ³ : (i : m) â†’ DecidableEq (n' i)\ninstâœÂ² : NormedCommRing ğ”¸\ninstâœÂ¹ : NormedAlgebra ğ•‚ ğ”¸\ninstâœ : CompleteSpace ğ”¸\nA : Matrix m m ğ”¸\nâŠ¢ exp ğ•‚ (-A) = (exp ğ•‚ A)â»Â¹"
    },
    {
      "name": "Num.cast_lt",
      "statement": "Î± : Type u_1\ninstâœ : LinearOrderedSemiring Î±\nm n : Num\nâŠ¢ â†‘m < â†‘n â†” m < n"
    },
    {
      "name": "IntermediateField.adjoin_eq_top_of_adjoin_eq_top",
      "statement": "F : Type u_1\ninstâœâ¸ : Field F\nE : Type u_2\ninstâœâ· : Field E\ninstâœâ¶ : Algebra F E\nÎ± : E\nK : Type u\ninstâœâµ : Field K\ninstâœâ´ : Algebra F K\nL : Type u_3\ninstâœÂ³ : Field L\ninstâœÂ² : Algebra K L\ninstâœÂ¹ : Algebra E K\ninstâœ : IsScalarTower F E K\nS : Set K\nhprim : adjoin F S = âŠ¤\nâŠ¢ restrictScalars F (adjoin E S) = restrictScalars F âŠ¤"
    },
    {
      "name": "Metric.Sigma.fst_eq_of_dist_lt_one",
      "statement": "Î¹ : Type u_1\nE : Î¹ â†’ Type u_2\ninstâœ : (i : Î¹) â†’ MetricSpace (E i)\nx y : (i : Î¹) Ã— E i\nh : dist x y < 1\nâŠ¢ x.fst = y.fst"
    },
    {
      "name": "ProbabilityTheory.IsCondKernelCDF.setLIntegral",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nÎº : â†¥(kernel Î± (Î² Ã— â„))\nÎ½ : â†¥(kernel Î± Î²)\nfâœ : Î± Ã— Î² â†’ StieltjesFunction\ninstâœ : IsFiniteKernel Îº\nf : Î± Ã— Î² â†’ StieltjesFunction\nhf : IsCondKernelCDF f Îº Î½\na : Î±\ns : Set Î²\nhs : MeasurableSet s\nx : â„\nâŠ¢ âˆ«â» (b : Î²) in s, ENNReal.ofReal (â†‘(f (a, b)) x) âˆ‚Î½ a = (Îº a) (s Ã—Ë¢ Iic x)"
    },
    {
      "name": "Finset.sdiff_eq_filter",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\np q : Î± â†’ Prop\ninstâœÂ² : DecidablePred p\ninstâœÂ¹ : DecidablePred q\ns : Finset Î±\ninstâœ : DecidableEq Î±\nsâ‚ sâ‚‚ : Finset Î±\nxâœ : Î±\nâŠ¢ xâœ âˆˆ sâ‚ \\ sâ‚‚ â†” xâœ âˆˆ filter (fun x => x âˆ‰ sâ‚‚) sâ‚"
    },
    {
      "name": "variationOnFromTo.monotoneOn",
      "statement": "Î± : Type u_1\ninstâœÂ¹ : LinearOrder Î±\nE : Type u_2\ninstâœ : PseudoEMetricSpace E\nf : Î± â†’ E\ns : Set Î±\nhf : LocallyBoundedVariationOn f s\na : Î±\nas : a âˆˆ s\nâŠ¢ MonotoneOn (variationOnFromTo f s a) s"
    },
    {
      "name": "Cardinal.mk_univ_quaternionAlgebra",
      "statement": "R : Type u_1\ncâ‚ câ‚‚ : R\nâŠ¢ #â†‘Set.univ = #R ^ 4"
    },
    {
      "name": "Set.iUnion_accumulate",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ns : Î± â†’ Set Î²\nt : Î± â†’ Set Î³\ninstâœ : Preorder Î±\nâŠ¢ â‹ƒ x, Accumulate s x = â‹ƒ x, s x"
    },
    {
      "name": "MeasureTheory.integrable_withDensity_iff_integrable_smul'",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\nm : MeasurableSpace Î±\nÎ¼ Î½ : Measure Î±\ninstâœâ´ : MeasurableSpace Î´\ninstâœÂ³ : NormedAddCommGroup Î²\ninstâœÂ² : NormedAddCommGroup Î³\nE : Type u_5\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace â„ E\nf : Î± â†’ â„â‰¥0âˆ\nhf : Measurable f\nhflt : âˆ€áµ (x : Î±) âˆ‚Î¼, f x < âŠ¤\ng : Î± â†’ E\nâŠ¢ Integrable g (Î¼.withDensity f) â†” Integrable (fun x => (f x).toReal â€¢ g x) Î¼"
    },
    {
      "name": "symmDiff_sdiff_inf",
      "statement": "Î¹ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nÏ€ : Î¹ â†’ Type u_4\ninstâœ : GeneralizedCoheytingAlgebra Î±\na b c d : Î±\nâŠ¢ a âˆ† b \\ (a âŠ“ b) = a âˆ† b"
    },
    {
      "name": "IsClosed.vadd_right_of_isCompact",
      "statement": "Î± : Type u_1\nV : Type u_2\nP : Type u_3\nW : Type u_4\nQ : Type u_5\ninstâœâµ : SeminormedAddCommGroup V\ninstâœâ´ : PseudoMetricSpace P\ninstâœÂ³ : NormedAddTorsor V P\ninstâœÂ² : NormedAddCommGroup W\ninstâœÂ¹ : MetricSpace Q\ninstâœ : NormedAddTorsor W Q\ns : Set V\nt : Set P\nhs : IsClosed s\nht : IsCompact t\nâŠ¢ IsClosed (s +áµ¥ t)"
    },
    {
      "name": "Polynomial.trinomial_leading_coeff'",
      "statement": "R : Type u_1\ninstâœ : Semiring R\nk m n : â„•\nu v w : R\nhkm : k < m\nhmn : m < n\nâŠ¢ (trinomial k m n u v w).coeff n = w"
    },
    {
      "name": "RingCon.sSup_def",
      "statement": "Î± : Type u_1\nR : Type u_2\ninstâœÂ¹ : Add R\ninstâœ : Mul R\nS : Set (RingCon R)\nâŠ¢ sSup S = ringConGen (sSup (DFunLike.coe '' S))"
    },
    {
      "name": "IndepMatroid.ofFinset_indep'",
      "statement": "Î± : Type u_1\nIâœ B X : Set Î±\ninstâœ : DecidableEq Î±\nE : Set Î±\nIndep : Finset Î± â†’ Prop\nindep_empty : Indep âˆ…\nindep_subset : âˆ€ â¦ƒI J : Finset Î±â¦„, Indep J â†’ I âŠ† J â†’ Indep I\nindep_aug : âˆ€ â¦ƒI J : Finset Î±â¦„, Indep I â†’ Indep J â†’ I.card < J.card â†’ âˆƒ e âˆˆ J, e âˆ‰ I âˆ§ Indep (insert e I)\nsubset_ground : âˆ€ â¦ƒI : Finset Î±â¦„, Indep I â†’ â†‘I âŠ† E\nI : Set Î±\nâŠ¢ (IndepMatroid.ofFinset E Indep indep_empty indep_subset indep_aug subset_ground).Indep I â†”\n    âˆ€ (J : Finset Î±), â†‘J âŠ† I â†’ Indep J"
    },
    {
      "name": "Polynomial.IsUnitTrinomial.ne_zero",
      "statement": "p q : â„¤[X]\nhp : p.IsUnitTrinomial\nâŠ¢ p â‰  0"
    },
    {
      "name": "t0Space_iff_uniformity'",
      "statement": "Î± : Type u\nÎ² : Type v\nÎ³ : Type w\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformSpace Î²\ninstâœ : UniformSpace Î³\nâŠ¢ T0Space Î± â†” Pairwise fun x y => âˆƒ r âˆˆ ğ“¤ Î±, (x, y) âˆ‰ r"
    },
    {
      "name": "Finset.gcd_union",
      "statement": "Î¹ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\ninstâœÂ² : CancelCommMonoidWithZero Î±\ninstâœÂ¹ : NormalizedGCDMonoid Î±\ns sâ‚ sâ‚‚ : Finset Î²\nf : Î² â†’ Î±\ninstâœ : DecidableEq Î²\nâŠ¢ (âˆ… âˆª sâ‚‚).gcd f = GCDMonoid.gcd (âˆ….gcd f) (sâ‚‚.gcd f)"
    },
    {
      "name": "UniqueFactorizationMonoid.normalize_normalized_factor",
      "statement": "Î± : Type u_1\ninstâœÂ² : CancelCommMonoidWithZero Î±\ninstâœÂ¹ : NormalizationMonoid Î±\ninstâœ : UniqueFactorizationMonoid Î±\na : Î±\nâŠ¢ âˆ€ x âˆˆ normalizedFactors a, normalize x = x"
    },
    {
      "name": "iterateFrobeniusEquiv_symm_add_apply",
      "statement": "R : Type u_1\np m n : â„•\ninstâœÂ² : CommSemiring R\ninstâœÂ¹ : ExpChar R p\ninstâœ : PerfectRing R p\nx : R\nâŠ¢ (iterateFrobeniusEquiv R p (m + n)) ((iterateFrobeniusEquiv R p (m + n)).symm x) =\n    (iterateFrobeniusEquiv R p (m + n)) ((iterateFrobeniusEquiv R p m).symm ((iterateFrobeniusEquiv R p n).symm x))"
    },
    {
      "name": "Matrix.cons_add_cons",
      "statement": "Î± : Type u\nm n o : â„•\nm' : Type u_1\nn' : Type u_2\no' : Type u_3\ninstâœ : Add Î±\nx : Î±\nv : Fin n â†’ Î±\ny : Î±\nw : Fin n â†’ Î±\nâŠ¢ vecCons x v + vecCons y w = vecCons (x + y) (v + w)"
    },
    {
      "name": "WittVector.zero_coeff",
      "statement": "p : â„•\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninstâœ : CommRing R\nn : â„•\nâŠ¢ (aeval (Function.uncurry fun i => (![] i).coeff)) (wittZero p n) = 0"
    },
    {
      "name": "Finset.powersetCard_empty_subsingleton",
      "statement": "Î± : Type u_1\nsâœ tâœ : Finset Î±\nnâœ : ?m.14806\ns t : Finset Î±\nn : â„•\nâŠ¢ (â†‘(powersetCard n âˆ…)).Subsingleton"
    },
    {
      "name": "AlgebraicGeometry.Spec.map_eqToHom",
      "statement": "R S : CommRingCat\ne : R = S\nâŠ¢ map (eqToHom e) = eqToHom â‹¯"
    },
    {
      "name": "List.count_attach",
      "statement": "Î± : Type u_1\nl : List Î±\ninstâœ : DecidableEq Î±\na xâœÂ¹ : { x // x âˆˆ l }\nxâœ : xâœÂ¹ âˆˆ l.attach\nâŠ¢ (xâœÂ¹ == a) = true â†” (â†‘xâœÂ¹ == â†‘a) = true"
    },
    {
      "name": "Real.toNNReal_div'",
      "statement": "x y : â„\nhy : 0 â‰¤ y\nâŠ¢ (x / y).toNNReal = x.toNNReal / y.toNNReal"
    },
    {
      "name": "Finset.mk_mem_sym2_iff",
      "statement": "Î± : Type u_1\ns t : Finset Î±\na b : Î±\nâŠ¢ s(a, b) âˆˆ s.sym2 â†” a âˆˆ s âˆ§ b âˆˆ s"
    },
    {
      "name": "Set.countable_pi",
      "statement": "Î± : Type u\nÎ² : Type v\nÎ³ : Type w\nÎ¹ : Sort x\nÏ€ : Î± â†’ Type u_1\ninstâœ : Finite Î±\ns : (a : Î±) â†’ Set (Ï€ a)\nhs : âˆ€ (a : Î±), (s a).Countable\nâŠ¢ {f | âˆ€ (a : Î±), f a âˆˆ s a}.Countable"
    },
    {
      "name": "MvPowerSeries.inv_eq_zero",
      "statement": "Ïƒ : Type u_1\nR : Type u_2\nk : Type u_3\ninstâœ : Field k\nÏ† : MvPowerSeries Ïƒ k\nh : Ï†â»Â¹ = 0\nâŠ¢ (constantCoeff Ïƒ k) Ï† = 0"
    },
    {
      "name": "Concept.ext",
      "statement": "Î¹ : Sort u_1\nÎ± : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\nÎº : Î¹ â†’ Sort u_5\nr : Î± â†’ Î² â†’ Prop\ns sâ‚ sâ‚‚ : Set Î±\nt tâ‚ tâ‚‚ : Set Î²\nc d : Concept Î± Î² r\nh : c.toProd.1 = d.toProd.1\nâŠ¢ c = d"
    },
    {
      "name": "CategoryTheory.FintypeCat.Action.pretransitive_of_isConnected",
      "statement": "G : Type u\ninstâœÂ¹ : Group G\nX : Action FintypeCat (MonCat.of G)\ninstâœ : IsConnected X\nx y : â†‘X.V\nâŠ¢ âˆƒ g, g â€¢ x = y"
    },
    {
      "name": "EReal.add_lt_top",
      "statement": "x y : EReal\nhx : x â‰  âŠ¤\nhy : y â‰  âŠ¤\nâŠ¢ x + y < âŠ¤"
    },
    {
      "name": "CompositionSeries.isMaximal_eraseLast_last",
      "statement": "X : Type u\ninstâœÂ¹ : Lattice X\ninstâœ : JordanHolderLattice X\ns : CompositionSeries X\nh : 0 < s.length\nâŠ¢ IsMaximal (eraseLast s).last (last s)"
    },
    {
      "name": "List.Ico.eq_nil_of_le",
      "statement": "n m : â„•\nh : m â‰¤ n\nâŠ¢ Ico n m = []"
    },
    {
      "name": "YoungDiagram.mk_mem_col_iff",
      "statement": "Î¼ : YoungDiagram\ni j : â„•\nâŠ¢ (i, j) âˆˆ Î¼.col j â†” (i, j) âˆˆ Î¼"
    },
    {
      "name": "EMetric.isClosed_subsets_of_isClosed",
      "statement": "Î± : Type u\ninstâœ : EMetricSpace Î±\ns : Set Î±\nhs : IsClosed s\nâŠ¢ IsClosed {t | â†‘t âŠ† s}"
    },
    {
      "name": "Filter.mem_iInf'",
      "statement": "Î± : Type u\nÎ² : Type v\nÎ³ : Type w\nÎ´ : Type u_1\nÎ¹âœ : Sort x\nf g : Filter Î±\nsâœ t : Set Î±\nÎ¹ : Type u_2\ns : Î¹ â†’ Filter Î±\nU : Set Î±\nâŠ¢ U âˆˆ â¨… i, s i â†” âˆƒ I, I.Finite âˆ§ âˆƒ V, (âˆ€ (i : Î¹), V i âˆˆ s i) âˆ§ (âˆ€ i âˆ‰ I, V i = univ) âˆ§ U = â‹‚ i âˆˆ I, V i âˆ§ U = â‹‚ i, V i"
    },
    {
      "name": "Nat.card_uIcc",
      "statement": "a b c : â„•\nâŠ¢ a âŠ” b + 1 - a âŠ“ b = (â†‘b - â†‘a).natAbs + 1"
    },
    {
      "name": "Nat.ceil_eq_zero",
      "statement": "F : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : LinearOrderedSemiring Î±\ninstâœ : FloorSemiring Î±\na : Î±\nn : â„•\nâŠ¢ âŒˆaâŒ‰â‚Š = 0 â†” a â‰¤ 0"
    },
    {
      "name": "CategoryTheory.EffectiveEpiFamily.transitive_of_finite",
      "statement": "C : Type u_1\ninstâœÂ³ : Category.{u_2, u_1} C\ninstâœÂ² : Precoherent C\nX : C\nÎ± : Type\ninstâœÂ¹ : Finite Î±\nY : Î± â†’ C\nÏ€ : (a : Î±) â†’ Y a âŸ¶ X\nh : EffectiveEpiFamily Y Ï€\nÎ² : Î± â†’ Type\ninstâœ : âˆ€ (a : Î±), Finite (Î² a)\nY_n : (a : Î±) â†’ Î² a â†’ C\nÏ€_n : (a : Î±) â†’ (b : Î² a) â†’ Y_n a b âŸ¶ Y a\nH : âˆ€ (a : Î±), EffectiveEpiFamily (Y_n a) (Ï€_n a)\nâŠ¢ EffectiveEpiFamily (fun c => Y_n c.fst c.snd) fun c => Ï€_n c.fst c.snd â‰« Ï€ c.fst"
    },
    {
      "name": "padicNorm.div",
      "statement": "p : â„•\nhp : Fact (Nat.Prime p)\nq r : â„š\nhr : r = 0\nâŠ¢ padicNorm p (q / r) = padicNorm p q / padicNorm p r"
    },
    {
      "name": "Matroid.restrict_eq_restrict_iff",
      "statement": "Î± : Type u_1\nMâœ : Matroid Î±\nR I J Xâœ Y : Set Î±\nM M' : Matroid Î±\nX : Set Î±\nâŠ¢ M â†¾ X = M' â†¾ X â†” âˆ€ I âŠ† X, M.Indep I â†” M'.Indep I"
    },
    {
      "name": "RCLike.conj_neg_I",
      "statement": "K : Type u_1\nE : Type u_2\ninstâœ : RCLike K\nâŠ¢ (starRingEnd K) (-I) = I"
    },
    {
      "name": "ZNum.zneg_zneg",
      "statement": "Î± : Type u_1\nn : ZNum\nâŠ¢ - -n = n"
    },
    {
      "name": "WithBot.image_coe_Ico",
      "statement": "Î± : Type u_1\ninstâœ : Preorder Î±\na b : Î±\nâŠ¢ some '' Ico a b = Ico â†‘a â†‘b"
    },
    {
      "name": "MeasureTheory.Lp.ext_iff",
      "statement": "Î± : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\nm m0 : MeasurableSpace Î±\np : â„â‰¥0âˆ\nq : â„\nÎ¼ Î½ : Measure Î±\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedAddCommGroup G\nf g : â†¥(Lp E p Î¼)\nh : f = g\nâŠ¢ â†‘â†‘f =á¶ [ae Î¼] â†‘â†‘g"
    },
    {
      "name": "WithZero.map'_id",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ² : MulOneClass Î±\ninstâœÂ¹ : MulOneClass Î²\ninstâœ : MulOneClass Î³\nâŠ¢ â†‘(map' (MonoidHom.id Î²)) = MonoidHom.id (WithZero Î²)"
    },
    {
      "name": "Finset.prod_powerset_cons",
      "statement": "Î¹ : Type u_1\nÎº : Type u_2\nÎ± : Type u_3\nÎ² : Type u_4\nÎ³ : Type u_5\ns sâ‚ sâ‚‚ : Finset Î±\na : Î±\nfâœ g : Î± â†’ Î²\ninstâœ : CommMonoid Î²\nha : a âˆ‰ s\nf : Finset Î± â†’ Î²\nâŠ¢ âˆ t âˆˆ (cons a s ha).powerset, f t = (âˆ t âˆˆ s.powerset, f t) * âˆ t âˆˆ s.powerset.attach, f (cons a â†‘t â‹¯)"
    },
    {
      "name": "Finset.sum_smul_const_vsub_eq_sub_weightedVSubOfPoint",
      "statement": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninstâœÂ² : Ring k\ninstâœÂ¹ : AddCommGroup V\ninstâœ : Module k V\nS : AffineSpace V P\nÎ¹ : Type u_4\ns : Finset Î¹\nÎ¹â‚‚ : Type u_5\nsâ‚‚ : Finset Î¹â‚‚\nw : Î¹ â†’ k\npâ‚‚ : Î¹ â†’ P\npâ‚ b : P\nâŠ¢ âˆ‘ i âˆˆ s, w i â€¢ (pâ‚ -áµ¥ pâ‚‚ i) = (âˆ‘ i âˆˆ s, w i) â€¢ (pâ‚ -áµ¥ b) - (s.weightedVSubOfPoint pâ‚‚ b) w"
    },
    {
      "name": "AlgebraicGeometry.ProjectiveSpectrum.Proj.stalkMap_toSpec",
      "statement": "R : Type u_1\nA : Type u_2\ninstâœÂ³ : CommRing R\ninstâœÂ² : CommRing A\ninstâœÂ¹ : Algebra R A\nğ’œ : â„• â†’ Submodule R A\ninstâœ : GradedAlgebra ğ’œ\nf : A\nx : â†¥(pbo f)\nm : â„•\nf_deg : f âˆˆ ğ’œ m\nhm : 0 < m\nâŠ¢ awayToÎ“ ğ’œ f â‰« (Proj.restrict â‹¯).Î“ToStalk x =\n    RingHom.comp\n      ((specStalkEquiv ğ’œ f x f_deg hm).hom â‰«\n        (Proj.stalkIso' ğ’œ â†‘x).toCommRingCatIso.inv â‰« (Proj.restrictStalkIso â‹¯ x).inv)\n      (algebraMap (Aâ°_ f) â†‘((Spec.structureSheaf (Aâ°_ f)).presheaf.stalk ((toSpec ğ’œ f).val.base x)))"
    },
    {
      "name": "Stream'.WSeq.exists_of_liftRel_right",
      "statement": "Î± : Type u\nÎ² : Type v\nÎ³ : Type w\nR : Î± â†’ Î² â†’ Prop\ns : WSeq Î±\nt : WSeq Î²\nH : LiftRel R s t\nb : Î²\nh : b âˆˆ t\nâŠ¢ âˆƒ a, a âˆˆ s âˆ§ R a b"
    },
    {
      "name": "CategoryTheory.CatCommSq.hInv_hInv",
      "statement": "Câ‚ : Type u_1\nCâ‚‚ : Type u_2\nCâ‚ƒ : Type u_3\nCâ‚„ : Type u_4\nCâ‚… : Type u_5\nCâ‚† : Type u_6\ninstâœâµ : Category.{u_8, u_1} Câ‚\ninstâœâ´ : Category.{u_9, u_2} Câ‚‚\ninstâœÂ³ : Category.{u_10, u_3} Câ‚ƒ\ninstâœÂ² : Category.{u_7, u_4} Câ‚„\ninstâœÂ¹ : Category.{?u.17460, u_5} Câ‚…\ninstâœ : Category.{?u.17464, u_6} Câ‚†\nTâœ : Câ‚ â¥¤ Câ‚‚\nLâœ : Câ‚ â¥¤ Câ‚ƒ\nRâœ : Câ‚‚ â¥¤ Câ‚„\nBâœ : Câ‚ƒ â¥¤ Câ‚„\nT : Câ‚ â‰Œ Câ‚‚\nL : Câ‚ â¥¤ Câ‚ƒ\nR : Câ‚‚ â¥¤ Câ‚„\nB : Câ‚ƒ â‰Œ Câ‚„\nh : CatCommSq T.functor L R B.functor\nâŠ¢ hInv T.symm R L B.symm (hInv T L R B h) = h"
    },
    {
      "name": "Filter.prod_map_seq_comm",
      "statement": "Î± : Type u\nÎ² : Type v\nÎ³ : Type w\nÎ´ : Type u_1\nÎ¹ : Sort x\nl f : Filter Î±\ng : Filter Î²\nâŠ¢ (map Prod.mk f).seq g = (map (fun b a => (a, b)) g).seq f"
    },
    {
      "name": "MeasureTheory.OuterMeasure.comap_ofFunction",
      "statement": "Î± : Type u_1\nm : Set Î± â†’ â„â‰¥0âˆ\nm_empty : m âˆ… = 0\nÎ² : Type ?u.25201\nf : Î² â†’ Î±\nh : Monotone m âˆ¨ Surjective f\nâŠ¢ (fun s => m (f '' s)) âˆ… = 0"
    },
    {
      "name": "compact_open_separated_mul_left",
      "statement": "G : Type w\nH : Type x\nÎ± : Type u\nÎ² : Type v\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : MulOneClass G\ninstâœ : ContinuousMul G\nK U : Set G\nhK : IsCompact K\nhU : IsOpen U\nhKU : K âŠ† U\nâŠ¢ âˆƒ V âˆˆ ğ“ 1, V * K âŠ† U"
    },
    {
      "name": "LinearMap.trace_tensorProduct",
      "statement": "R : Type u_1\ninstâœÂ¹Â² : CommRing R\nM : Type u_2\ninstâœÂ¹Â¹ : AddCommGroup M\ninstâœÂ¹â° : Module R M\nN : Type u_3\nP : Type u_4\ninstâœâ¹ : AddCommGroup N\ninstâœâ¸ : Module R N\ninstâœâ· : AddCommGroup P\ninstâœâ¶ : Module R P\nÎ¹ : Type u_5\ninstâœâµ : Module.Free R M\ninstâœâ´ : Module.Finite R M\ninstâœÂ³ : Module.Free R N\ninstâœÂ² : Module.Finite R N\ninstâœÂ¹ : Module.Free R P\ninstâœ : Module.Finite R P\nâŠ¢ (mapBilinear R M N M N).comprâ‚‚ (trace R (M âŠ—[R] N)) = (lsmul R R).complâ‚â‚‚ (trace R M) (trace R N)"
    },
    {
      "name": "dite_le_one",
      "statement": "Î¹ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nÏ€ : Î¹ â†’ Type u_4\ninstâœÂ² : One Î±\np : Prop\ninstâœÂ¹ : Decidable p\na : p â†’ Î±\nb : Â¬p â†’ Î±\ninstâœ : LE Î±\nha : âˆ€ (h : p), a h â‰¤ 1\nhb : âˆ€ (h : Â¬p), b h â‰¤ 1\nâŠ¢ dite p a b â‰¤ 1"
    },
    {
      "name": "Cardinal.deriv_lt_ord",
      "statement": "Î± : Type u_1\nr : Î± â†’ Î± â†’ Prop\nf : Ordinal.{u} â†’ Ordinal.{u}\nc : Cardinal.{u}\nhc : c.IsRegular\nhc' : c â‰  â„µâ‚€\nhf : âˆ€ i < c.ord, f i < c.ord\na : Ordinal.{u}\nâŠ¢ lift.{u, 0} #Unit < c"
    },
    {
      "name": "Fin.min_val",
      "statement": "n m : â„•\na : Fin n\nâŠ¢ min (â†‘a) n = â†‘a"
    },
    {
      "name": "Finsupp.support_zipWith",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ¹ : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS : Type u_12\ninstâœÂ² : Zero M\ninstâœÂ¹ : Zero N\ninstâœ : Zero P\nD : DecidableEq Î±\nf : M â†’ N â†’ P\nhf : f 0 0 = 0\ngâ‚ : Î± â†’â‚€ M\ngâ‚‚ : Î± â†’â‚€ N\nâŠ¢ (zipWith f hf gâ‚ gâ‚‚).support âŠ† gâ‚.support âˆª gâ‚‚.support"
    },
    {
      "name": "sub_one_mul",
      "statement": "Î± : Type u\nÎ² : Type v\nÎ³ : Type w\nR : Type x\ninstâœ : NonAssocRing Î±\na b : Î±\nâŠ¢ (a - 1) * b = a * b - b"
    },
    {
      "name": "Set.image_id_eq",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ¹ : Sort u_4\nÎ¹' : Sort u_5\nf : Î± â†’ Î²\ns t : Set Î±\nâŠ¢ image id = id"
    },
    {
      "name": "EMetric.le_infEdist",
      "statement": "Î¹ : Sort u_1\nÎ± : Type u\nÎ² : Type v\ninstâœÂ¹ : PseudoEMetricSpace Î±\ninstâœ : PseudoEMetricSpace Î²\nx y : Î±\ns t : Set Î±\nÎ¦ : Î± â†’ Î²\nd : â„â‰¥0âˆ\nâŠ¢ d â‰¤ infEdist x s â†” âˆ€ y âˆˆ s, d â‰¤ edist x y"
    },
    {
      "name": "Function.update_comp_equiv",
      "statement": "Î±' : Sort u_1\nÎ± : Sort u_2\nÎ² : Sort u_3\ninstâœÂ¹ : DecidableEq Î±'\ninstâœ : DecidableEq Î±\nf : Î± â†’ Î²\ng : Î±' â‰ƒ Î±\na : Î±\nv : Î²\nâŠ¢ update f a v âˆ˜ â‡‘g = update (f âˆ˜ â‡‘g) (g.symm a) v"
    },
    {
      "name": "Liouville.liouvilleWith",
      "statement": "x : â„\nhx : Liouville x\np : â„\nâŠ¢ LiouvilleWith p x"
    },
    {
      "name": "bernoulli'_zero",
      "statement": "A : Type u_1\ninstâœÂ¹ : CommRing A\ninstâœ : Algebra â„š A\nâŠ¢ bernoulli' 0 = 1"
    },
    {
      "name": "Nat.mul_div_eq_iff_dvd",
      "statement": "a b c dâœ m nâœ k : â„•\np q : â„• â†’ Prop\nn d : â„•\nâŠ¢ d * (n / d) = n â†” d * (n / d) = d * (n / d) + n % d"
    },
    {
      "name": "ZetaAsymptotics.tendsto_Gamma_term_aux",
      "statement": "âŠ¢ Tendsto (fun s => 1 / (s - 1) - 1 / s.Gammaâ„ / (s - 1)) (ğ“[â‰ ] 1) (ğ“ (-(â†‘Î³ + Complex.log (4 * â†‘Ï€)) / 2))"
    },
    {
      "name": "Subalgebra.toSubring_injective",
      "statement": "R' : Type u'\nRâœ : Type u\nAâœ : Type v\nB : Type w\nC : Type w'\ninstâœâ¹ : CommSemiring Râœ\ninstâœâ¸ : Semiring Aâœ\ninstâœâ· : Algebra Râœ Aâœ\ninstâœâ¶ : Semiring B\ninstâœâµ : Algebra Râœ B\ninstâœâ´ : Semiring C\ninstâœÂ³ : Algebra Râœ C\nSâœ : Subalgebra Râœ Aâœ\nR : Type u\nA : Type v\ninstâœÂ² : CommRing R\ninstâœÂ¹ : Ring A\ninstâœ : Algebra R A\nS T : Subalgebra R A\nh : S.toSubring = T.toSubring\nx : A\nâŠ¢ x âˆˆ S â†” x âˆˆ T"
    },
    {
      "name": "Finset.map_add_left_Ioo",
      "statement": "Î¹ : Type u_1\nÎ± : Type u_2\ninstâœÂ² : OrderedCancelAddCommMonoid Î±\ninstâœÂ¹ : ExistsAddOfLE Î±\ninstâœ : LocallyFiniteOrder Î±\na b c : Î±\nâŠ¢ map (addLeftEmbedding c) (Ioo a b) = Ioo (c + a) (c + b)"
    },
    {
      "name": "Filter.HasBasis.to_hasBasis'",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ¹ : Sort u_4\nÎ¹' : Sort u_5\nl l' : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nt : Set Î±\ni : Î¹\np' : Î¹' â†’ Prop\ns' : Î¹' â†’ Set Î±\ni' : Î¹'\nhl : l.HasBasis p s\nh : âˆ€ (i : Î¹), p i â†’ âˆƒ i', p' i' âˆ§ s' i' âŠ† s i\nh' : âˆ€ (i' : Î¹'), p' i' â†’ s' i' âˆˆ l\nâŠ¢ l.HasBasis p' s'"
    },
    {
      "name": "Nat.prime_three",
      "statement": "n : â„•\nâŠ¢ Prime 3"
    },
    {
      "name": "Polynomial.comp_X",
      "statement": "R : Type u\nS : Type v\nT : Type w\nÎ¹ : Type y\na b : R\nm n : â„•\ninstâœ : Semiring R\np q r : R[X]\nâŠ¢ p.comp X = p"
    },
    {
      "name": "MeasurableSpace.cardinal_generateMeasurable_le_continuum",
      "statement": "Î± : Type u\ns : Set (Set Î±)\nhs : #â†‘s â‰¤ ğ” \nâŠ¢ max (#â†‘s) 2 ^ â„µâ‚€ â‰¤ ğ” "
    },
    {
      "name": "Batteries.RBSet.mem_toList_insert",
      "statement": "Î± : Type u_1\ncmp : Î± â†’ Î± â†’ Ordering\nv' v : Î±\ninstâœ : TransCmp cmp\nt : RBSet Î± cmp\nâŠ¢ v' âˆˆ (t.insert v).toList â†” v' âˆˆ t.toList âˆ§ t.find? v â‰  some v' âˆ¨ v' = v"
    },
    {
      "name": "IsUnit.mul_eq_mul_of_div_eq_div",
      "statement": "Î± : Type u\nM : Type u_1\nN : Type u_2\ninstâœ : DivisionCommMonoid Î±\naâœ b câœ d : Î±\nhb : IsUnit b\nhd : IsUnit d\na c : Î±\nh : a / b = c / d\nâŠ¢ a * d = c * b"
    },
    {
      "name": "MvPowerSeries.mul_inv_rev",
      "statement": "Ïƒ : Type u_1\nR : Type u_2\nk : Type u_3\ninstâœ : Field k\nÏ† Ïˆ : MvPowerSeries Ïƒ k\nâŠ¢ (Ï† * Ïˆ)â»Â¹ = Ïˆâ»Â¹ * Ï†â»Â¹"
    },
    {
      "name": "Fermat42.not_minimal",
      "statement": "a b c : â„¤\nh : Minimal a b c\nha2 : a % 2 = 1\nhc : 0 < c\nâŠ¢ False"
    },
    {
      "name": "mul_eq_of_eq_inv_mulâ‚€",
      "statement": "Î± : Type u_1\nMâ‚€ : Type u_2\nGâ‚€ : Type u_3\nMâ‚€' : Type u_4\nGâ‚€' : Type u_5\nF : Type u_6\nF' : Type u_7\ninstâœÂ¹ : MonoidWithZero Mâ‚€\ninstâœ : GroupWithZero Gâ‚€\na b c d : Gâ‚€\nm n : â„•\nhb : b â‰  0\nh : b = aâ»Â¹ * c\nâŠ¢ a * b = c"
    },
    {
      "name": "Finset.Ioc_subset_Iic_self",
      "statement": "Î¹ : Type u_1\nÎ± : Type u_2\ninstâœÂ² : Preorder Î±\ninstâœÂ¹ : LocallyFiniteOrder Î±\na aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±\ninstâœ : LocallyFiniteOrderBot Î±\nâŠ¢ Ioc a b âŠ† Iic b"
    },
    {
      "name": "DFinsupp.toMultiset_lt_toMultiset",
      "statement": "Î± : Type u_1\nÎ² : Î± â†’ Type u_2\ninstâœ : DecidableEq Î±\nf g : Î â‚€ (_a : Î±), â„•\nâŠ¢ toMultiset f < toMultiset g â†” f < g"
    },
    {
      "name": "Complex.exp_ne_zero",
      "statement": "x y : â„‚\nh : cexp x = 0\nâŠ¢ 0 = 1"
    },
    {
      "name": "Option.mapâ‚‚_map_left_anticomm",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\nfâœ : Î± â†’ Î² â†’ Î³\na : Option Î±\nb : Option Î²\nc : Option Î³\nÎ±' : Type u_5\nÎ²' : Type u_6\nÎ´' : Type u_7\nÎµ : Type u_8\nÎµ' : Type u_9\nf : Î±' â†’ Î² â†’ Î³\ng : Î± â†’ Î±'\nf' : Î² â†’ Î± â†’ Î´\ng' : Î´ â†’ Î³\nh_left_anticomm : âˆ€ (a : Î±) (b : Î²), f (g a) b = g' (f' b a)\nâŠ¢ mapâ‚‚ f (Option.map g a) b = Option.map g' (mapâ‚‚ f' b a)"
    },
    {
      "name": "CategoryTheory.Quotient.comp_right",
      "statement": "C : Type u_2\ninstâœ : Category.{u_1, u_2} C\nr : HomRel C\na b c : C\ng : b âŸ¶ c\naâœ bâœ : C\nx : a âŸ¶ aâœ\nmâ‚ mâ‚‚ : aâœ âŸ¶ bâœ\ny : bâœ âŸ¶ b\nh : r mâ‚ mâ‚‚\nâŠ¢ CompClosure r ((x â‰« mâ‚ â‰« y) â‰« g) ((x â‰« mâ‚‚ â‰« y) â‰« g)"
    },
    {
      "name": "Part.some_ne_none",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nx : Î±\nâŠ¢ some x â‰  none"
    },
    {
      "name": "CategoryTheory.Presieve.FamilyOfElements.comp_of_compatible",
      "statement": "C : Type uâ‚\ninstâœ : Category.{vâ‚, uâ‚} C\nP Q U : Cáµ’áµ– â¥¤ Type w\nX Y : C\nSâœ : Sieve X\nR : Presieve X\nS : Sieve X\nx : FamilyOfElements P S.arrows\nt : x.Compatible\nf : Y âŸ¶ X\nhf : S.arrows f\nZ : C\ng : Z âŸ¶ Y\nâŠ¢ x (g â‰« f) â‹¯ = P.map g.op (x f hf)"
    },
    {
      "name": "Real.log_sqrt",
      "statement": "xâœ y x : â„\nhx : 0 â‰¤ x\nâŠ¢ log âˆšx = log x / 2"
    },
    {
      "name": "MeasureTheory.integral_Ioi_deriv_mul_eq_sub",
      "statement": "A : Type u_1\ninstâœÂ² : NormedRing A\ninstâœÂ¹ : NormedAlgebra â„ A\na b : â„\na' b' : A\nu v u' v' : â„ â†’ A\ninstâœ : CompleteSpace A\nhu : âˆ€ x âˆˆ Ioi a, HasDerivAt u (u' x) x\nhv : âˆ€ x âˆˆ Ioi a, HasDerivAt v (v' x) x\nhuv : IntegrableOn (u' * v + u * v') (Ioi a) volume\nh_zero : Tendsto (u * v) (ğ“[>] a) (ğ“ a')\nh_infty : Tendsto (u * v) atTop (ğ“ b')\nâŠ¢ âˆ« (x : â„) in Ioi a, u' x * v x + u x * v' x = b' - a'"
    },
    {
      "name": "harmonic_eq_sum_Icc",
      "statement": "n : â„•\nâŠ¢ harmonic n = âˆ‘ i âˆˆ Finset.Icc 1 n, (â†‘i)â»Â¹"
    },
    {
      "name": "OreLocalization.add_assoc",
      "statement": "R : Type u_1\ninstâœÂ³ : Monoid R\nS : Submonoid R\ninstâœÂ² : OreSet S\nX : Type u_2\ninstâœÂ¹ : AddMonoid X\ninstâœ : DistribMulAction R X\nx y z : OreLocalization S X\nâŠ¢ x + y + z = x + (y + z)"
    },
    {
      "name": "div_eq_div_iff_mul_eq_mul",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nG : Type u_3\nM : Type u_4\ninstâœ : CommGroup G\na b c d : G\nâŠ¢ a / b = c / d â†” a * d = c * b"
    },
    {
      "name": "StrictConcaveOn.eq_of_map_sum_eq",
      "statement": "ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nÎ² : Type u_4\nÎ¹ : Type u_5\ninstâœâµ : LinearOrderedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : OrderedAddCommGroup Î²\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Module ğ•œ Î²\ninstâœ : OrderedSMul ğ•œ Î²\ns : Set E\nf : E â†’ Î²\nt : Finset Î¹\nw : Î¹ â†’ ğ•œ\np : Î¹ â†’ E\nv : ğ•œ\nq : E\nhf : StrictConcaveOn ğ•œ s f\nhâ‚€ : âˆ€ i âˆˆ t, 0 < w i\nhâ‚ : âˆ‘ i âˆˆ t, w i = 1\nhmem : âˆ€ i âˆˆ t, p i âˆˆ s\nh_eq : f (âˆ‘ i âˆˆ t, w i â€¢ p i) â‰¤ âˆ‘ i âˆˆ t, w i â€¢ f (p i)\nâŠ¢ âˆ€ â¦ƒj : Î¹â¦„, j âˆˆ t â†’ âˆ€ â¦ƒk : Î¹â¦„, k âˆˆ t â†’ p j = p k"
    },
    {
      "name": "Monotone.cauchySeq_alternating_series_of_tendsto_zero",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nE : Type u_4\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace â„ E\nb : â„\nf : â„• â†’ â„\nz : â„• â†’ E\nhfa : Monotone f\nhf0 : Tendsto f atTop (ğ“ 0)\nâŠ¢ CauchySeq fun n => âˆ‘ i âˆˆ Finset.range n, (-1) ^ i * f i"
    },
    {
      "name": "Combinatorics.Line.vertical_apply",
      "statement": "Î± : Type u_1\nÎ¹ : Type u_2\nÎ¹' : Type u_3\nv : Î¹ â†’ Î±\nl : Line Î± Î¹'\nx : Î±\nâŠ¢ (fun x i => ((vertical v l).idxFun i).getD x) x = Sum.elim v ((fun x i => (l.idxFun i).getD x) x)"
    },
    {
      "name": "Fin.foldl_zero",
      "statement": "Î± : Sort u_1\nf : Î± â†’ Fin 0 â†’ Î±\nx : Î±\nâŠ¢ foldl 0 f x = x"
    },
    {
      "name": "Polynomial.degree_modByMonic_lt",
      "statement": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : â„•\ninstâœÂ¹ : Ring R\npâœ qâœ : R[X]\ninstâœ : Nontrivial R\np q : R[X]\nhq : q.Monic\nthis : DecidableEq R := Classical.decEq R\nh : q.degree â‰¤ p.degree âˆ§ p â‰  0\nâŠ¢ (p %â‚˜ q).degree < q.degree"
    },
    {
      "name": "MulOpposite.unop_list_prod",
      "statement": "Î¹ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nM : Type u_4\nN : Type u_5\nP : Type u_6\nG : Type u_7\ninstâœ : Monoid M\nl : List Máµáµ’áµ–\nâŠ¢ unop l.prod = (map unop l).reverse.prod"
    },
    {
      "name": "Matrix.cons_add",
      "statement": "Î± : Type u\nm n o : â„•\nm' : Type u_1\nn' : Type u_2\no' : Type u_3\ninstâœ : Add Î±\nx : Î±\nv : Fin n â†’ Î±\nw : Fin n.succ â†’ Î±\nâŠ¢ vecCons x v + w = vecCons (x + vecHead w) (v + vecTail w)"
    },
    {
      "name": "MeasureTheory.UnifIntegrable.neg",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nm : MeasurableSpace Î±\nÎ¼ : Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf g : Î¹ â†’ Î± â†’ Î²\np : â„â‰¥0âˆ\nhf : UnifIntegrable f p Î¼\nâŠ¢ UnifIntegrable (-f) p Î¼"
    },
    {
      "name": "Set.ordConnected_singleton",
      "statement": "Î±âœ : Type u_1\nÎ² : Type u_2\ninstâœÂ² : Preorder Î±âœ\ninstâœÂ¹ : Preorder Î²\ns t : Set Î±âœ\nÎ± : Type u_3\ninstâœ : PartialOrder Î±\na : Î±\nâŠ¢ {a}.OrdConnected"
    },
    {
      "name": "Measurable.piecewise",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\nÎ´' : Type u_5\nÎ¹ : Sort uÎ¹\ns t u : Set Î±\nf g : Î± â†’ Î²\nm : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nxâœ : DecidablePred fun x => x âˆˆ s\nhs : MeasurableSet s\nhf : Measurable f\nhg : Measurable g\nâŠ¢ Measurable (s.piecewise f g)"
    },
    {
      "name": "List.map_permutationsAux2'",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ±' : Type u_3\nÎ²' : Type u_4\ng : Î± â†’ Î±'\ng' : Î² â†’ Î²'\nt : Î±\nts ys : List Î±\nr : List Î²\nf : List Î± â†’ Î²\nf' : List Î±' â†’ Î²'\nH : âˆ€ (a : List Î±), g' (f a) = f' (map g a)\nâŠ¢ map g' (permutationsAux2 t ts r ys f).2 = (permutationsAux2 (g t) (map g ts) (map g' r) (map g ys) f').2"
    },
    {
      "name": "ProbabilityTheory.cond_univ",
      "statement": "Î© : Type u_1\nÎ©' : Type u_2\nÎ± : Type u_3\nm : MeasurableSpace Î©\nm' : MeasurableSpace Î©'\nÎ¼ : Measure Î©\ns t : Set Î©\ninstâœ : IsProbabilityMeasure Î¼\nâŠ¢ Î¼[|univ] = Î¼"
    },
    {
      "name": "MeasureTheory.lintegral_pos_iff_support",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\nm : MeasurableSpace Î±\nÎ¼ Î½ : Measure Î±\nf : Î± â†’ â„â‰¥0âˆ\nhf : Measurable f\nâŠ¢ 0 < âˆ«â» (a : Î±), f a âˆ‚Î¼ â†” 0 < Î¼ (support f)"
    },
    {
      "name": "DifferentiableWithinAt.mono",
      "statement": "ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\nG' : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G'\ninstâœ : NormedSpace ğ•œ G'\nf fâ‚€ fâ‚ g : E â†’ F\nf' fâ‚€' fâ‚' g' e : E â†’L[ğ•œ] F\nx : E\ns t : Set E\nL Lâ‚ Lâ‚‚ : Filter E\nh : DifferentiableWithinAt ğ•œ f t x\nst : s âŠ† t\nâŠ¢ DifferentiableWithinAt ğ•œ f s x"
    },
    {
      "name": "Nat.gcd_sub_self_right",
      "statement": "m n : â„•\nh : m â‰¤ n\nâŠ¢ m.gcd (n - m) = m.gcd n"
    },
    {
      "name": "IsLowerSet.erase",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ¹ : Sort u_4\nÎº : Î¹ â†’ Sort u_5\ninstâœÂ¹ : LE Î±\ninstâœ : LE Î²\ns t : Set Î±\na : Î±\nhs : IsLowerSet s\nhas : âˆ€ b âˆˆ s, a â‰¤ b â†’ b = a\nâŠ¢ âˆ€ b âˆˆ s, âˆ€ c âˆˆ {a}, c â‰¤ b â†’ b âˆˆ {a}"
    },
    {
      "name": "nnnorm_mul_le",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ¹ : Type u_4\ninstâœ : NonUnitalSeminormedRing Î±\na b : Î±\nâŠ¢ â€–a * bâ€–â‚Š â‰¤ â€–aâ€–â‚Š * â€–bâ€–â‚Š"
    },
    {
      "name": "CategoryTheory.Subobject.eq_mk_of_comm",
      "statement": "C : Type uâ‚\ninstâœÂ² : Category.{vâ‚, uâ‚} C\nXâœ Y Z : C\nD : Type uâ‚‚\ninstâœÂ¹ : Category.{vâ‚‚, uâ‚‚} D\nB A : C\nX : Subobject B\nf : A âŸ¶ B\ninstâœ : Mono f\ni : underlying.obj X â‰… A\nw : i.hom â‰« f = X.arrow\nâŠ¢ (i â‰ªâ‰« (underlyingIso f).symm).hom â‰« (mk f).arrow = X.arrow"
    },
    {
      "name": "Set.ncard_le_one_iff",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\ns t : Set Î±\nf : Î± â†’ Î²\nhs : autoParam s.Finite _autoâœ\nâŠ¢ s.ncard â‰¤ 1 â†” âˆ€ {a b : Î±}, a âˆˆ s â†’ b âˆˆ s â†’ a = b"
    },
    {
      "name": "Set.inv_mem_inv",
      "statement": "F : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\ninstâœ : InvolutiveInv Î±\ns t : Set Î±\na : Î±\nâŠ¢ aâ»Â¹ âˆˆ sâ»Â¹ â†” a âˆˆ s"
    },
    {
      "name": "Ordering.Compares.ne_lt",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\ninstâœ : Preorder Î±\na b : Î±\nhâœ : eq.Compares a b\nxâœ : b â‰¤ a\nh : eq = lt\nâŠ¢ False"
    },
    {
      "name": "Set.Ioo_add_bij",
      "statement": "M : Type u_1\ninstâœÂ¹ : OrderedCancelAddCommMonoid M\ninstâœ : ExistsAddOfLE M\na b c d : M\nâŠ¢ BijOn (fun x => x + d) (Ioo a b) (Ioo (a + d) (b + d))"
    },
    {
      "name": "CategoryTheory.Presieve.isSheafFor_iff_generate",
      "statement": "C : Type uâ‚\ninstâœ : Category.{vâ‚, uâ‚} C\nP Q U : Cáµ’áµ– â¥¤ Type w\nX Y : C\nS : Sieve X\nRâœ R : Presieve X\nâŠ¢ IsSheafFor P R â†” IsSheafFor P (generate R).arrows"
    },
    {
      "name": "JordanHolderLattice.isMaximal_inf_right_of_isMaximal_sup",
      "statement": "X : Type u\ninstâœÂ¹ : Lattice X\ninstâœ : JordanHolderLattice X\nx y : X\nhxz : IsMaximal x (x âŠ” y)\nhyz : IsMaximal y (x âŠ” y)\nâŠ¢ IsMaximal (x âŠ“ y) y"
    },
    {
      "name": "Besicovitch.SatelliteConfig.exists_normalized_aux1",
      "statement": "E : Type u_1\ninstâœ : NormedAddCommGroup E\nN : â„•\nÏ„ : â„\na : SatelliteConfig E N Ï„\nlastr : a.r (last N) = 1\nhÏ„ : 1 â‰¤ Ï„\nÎ´ : â„\nhÎ´1 : Ï„ â‰¤ 1 + Î´ / 4\nhÎ´2 : Î´ â‰¤ 1\ni j : Fin N.succ\ninej : i â‰  j\nâŠ¢ 1 - Î´ â‰¤ â€–a.c i - a.c jâ€–"
    },
    {
      "name": "FormalMultilinearSeries.radius_rightInv_pos_of_radius_pos",
      "statement": "ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\ni : E â‰ƒL[ğ•œ] F\nhp : 0 < p.radius\nâŠ¢ 0 < (p.rightInv i).radius"
    },
    {
      "name": "Finset.surj_on_of_inj_on_of_card_le",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nR : Type u_3\ns tâœ u : Finset Î±\nfâœ : Î± â†’ Î²\nn : â„•\nt : Finset Î²\nf : (a : Î±) â†’ a âˆˆ s â†’ Î²\nhf : âˆ€ (a : Î±) (ha : a âˆˆ s), f a ha âˆˆ t\nhinj : âˆ€ (aâ‚ aâ‚‚ : Î±) (haâ‚ : aâ‚ âˆˆ s) (haâ‚‚ : aâ‚‚ âˆˆ s), f aâ‚ haâ‚ = f aâ‚‚ haâ‚‚ â†’ aâ‚ = aâ‚‚\nhst : t.card â‰¤ s.card\nâŠ¢ âˆ€ b âˆˆ t, âˆƒ a, âˆƒ (ha : a âˆˆ s), b = f a ha"
    },
    {
      "name": "Ordnode.dual_node4L",
      "statement": "Î± : Type u_1\nl : Ordnode Î±\nx : Î±\nm : Ordnode Î±\ny : Î±\nr : Ordnode Î±\nâŠ¢ (l.node4L x m y r).dual = r.dual.node4R y m.dual x l.dual"
    },
    {
      "name": "SzemerediRegularity.initialBound_le_bound",
      "statement": "Î± : Type u_1\ninstâœÂ¹ : DecidableEq Î±\ninstâœ : Fintype Î±\nP : Finpartition univ\nu : Finset Î±\nÎµ : â„\nl : â„•\nâŠ¢ 0 < 16 ^ stepBound^[âŒŠ4 / Îµ ^ 5âŒ‹â‚Š] (initialBound Îµ l)"
    },
    {
      "name": "HomogeneousLocalization.val_add",
      "statement": "Î¹ : Type u_1\nR : Type u_2\nA : Type u_3\ninstâœâµ : AddCommMonoid Î¹\ninstâœâ´ : DecidableEq Î¹\ninstâœÂ³ : CommRing R\ninstâœÂ² : CommRing A\ninstâœÂ¹ : Algebra R A\nğ’œ : Î¹ â†’ Submodule R A\ninstâœ : GradedAlgebra ğ’œ\nx : Submonoid A\ny1 y2 : NumDenSameDeg ğ’œ x\nâŠ¢ (Quotient.mk'' y1 + Quotient.mk'' y2).val = val (Quotient.mk'' y1) + val (Quotient.mk'' y2)"
    },
    {
      "name": "multiplicity_eq_zero_of_coprime",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\np a b : â„•\nhp : p â‰  1\nhle : multiplicity p a â‰¤ multiplicity p b\nhab : a.Coprime b\nâŠ¢ multiplicity p a = 0"
    },
    {
      "name": "List.mem_dedup",
      "statement": "case refine_2\nÎ± : Type u\ninstâœ : DecidableEq Î±\na : Î±\nl : List Î±\nthis : (Â¬âˆ€ b âˆˆ pwFilter (fun x x_1 => x â‰  x_1) l, a â‰  b) â†” Â¬âˆ€ b âˆˆ l, a â‰  b\nâŠ¢ a âˆˆ l.dedup â†” a âˆˆ l"
    },
    {
      "name": "List.ofFn_mul'",
      "statement": "Î± : Type u\nm n : â„•\nf : Fin (m * n) â†’ Î±\ni : Fin n\nj : Fin m\nâŠ¢ m * â†‘i + m = m * (â†‘i + 1)"
    },
    {
      "name": "nhds_basis_uniformity'",
      "statement": "Î± : Type ua\nÎ² : Type ub\nÎ³ : Type uc\nÎ´ : Type ud\nÎ¹ : Sort u_1\ninstâœ : UniformSpace Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set (Î± Ã— Î±)\nh : (ğ“¤ Î±).HasBasis p s\nx : Î±\nâŠ¢ (ğ“ x).HasBasis p fun i => ball x (s i)"
    },
    {
      "name": "SimpleGraph.map_singletonSubgraph",
      "statement": "Î¹ : Sort u_1\nV : Type u\nW : Type v\nG : SimpleGraph V\nG' : SimpleGraph W\nf : G â†’g G'\nv : V\nâŠ¢ Subgraph.map f (G.singletonSubgraph v) = G'.singletonSubgraph (f v)"
    },
    {
      "name": "AddSubgroup.norm_normedMk_le",
      "statement": "M : Type u_1\nN : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup M\ninstâœ : SeminormedAddCommGroup N\nS : AddSubgroup M\nm : M\nâŠ¢ â€–S.normedMk mâ€– â‰¤ 1 * â€–mâ€–"
    },
    {
      "name": "MeasureTheory.SimpleFunc.forall_mem_range",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\ninstâœ : MeasurableSpace Î±\nf : Î± â†’â‚› Î²\np : Î² â†’ Prop\nâŠ¢ (âˆ€ y âˆˆ f.range, p y) â†” âˆ€ (x : Î±), p (â†‘f x)"
    },
    {
      "name": "CategoryTheory.congrArg_mpr_hom_right",
      "statement": "C : Type uâ‚\ninstâœ : Category.{vâ‚, uâ‚} C\nÎ² : Sort u_1\nX Y Z : C\np : X âŸ¶ Y\nq : Z = Y\nâŠ¢ â‹¯.mpr p = p â‰« eqToHom â‹¯"
    },
    {
      "name": "MeasureTheory.measure_le_average_pos",
      "statement": "Î± : Type u_1\nE : Type u_2\nF : Type u_3\nm0 : MeasurableSpace Î±\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace â„ E\ninstâœâ´ : CompleteSpace E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace â„ F\ninstâœÂ¹ : CompleteSpace F\nÎ¼ Î½ : Measure Î±\ns t N : Set Î±\nf : Î± â†’ â„\ninstâœ : IsFiniteMeasure Î¼\nhÎ¼ : Î¼ â‰  0\nhf : Integrable f Î¼\nâŠ¢ 0 < Î¼ {x | f x â‰¤ â¨ (a : Î±), f a âˆ‚Î¼}"
    },
    {
      "name": "Finset.subset_set_biUnion_of_mem",
      "statement": "F : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\nÎ¹ : Type u_5\nÎº : Type u_6\ns : Finset Î±\nf : Î± â†’ Set Î²\nx : Î±\nh : x âˆˆ s\nâŠ¢ f x â‰¤ â¨† (_ : x âˆˆ s), f x"
    },
    {
      "name": "TopCat.Presheaf.covering_presieve_eq_self",
      "statement": "X : TopCat\nY : Opens â†‘X\nR : Presieve Y\nâŠ¢ presieveOfCoveringAux (coveringOfPresieve Y R) Y = R"
    },
    {
      "name": "Module.finite_iff_of_rank_eq_nsmul",
      "statement": "R : Type u\nM Mâ‚ : Type v\nM' : Type v'\ninstâœÂ¹Â³ : Ring R\ninstâœÂ¹Â² : StrongRankCondition R\ninstâœÂ¹Â¹ : AddCommGroup M\ninstâœÂ¹â° : Module R M\ninstâœâ¹ : Free R M\ninstâœâ¸ : AddCommGroup M'\ninstâœâ· : Module R M'\ninstâœâ¶ : Free R M'\ninstâœâµ : AddCommGroup Mâ‚\ninstâœâ´ : Module R Mâ‚\ninstâœÂ³ : Free R Mâ‚\nW : Type v\ninstâœÂ² : AddCommGroup W\ninstâœÂ¹ : Module R W\ninstâœ : Free R W\nn : â„•\nhn : n â‰  0\nhVW : Module.rank R M = n â€¢ Module.rank R W\nâŠ¢ Finite R M â†” Finite R W"
    },
    {
      "name": "IsCompact.nonempty_sInter_of_directed_nonempty_isCompact_isClosed",
      "statement": "X : Type u\nY : Type v\nÎ¹ : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\ns t : Set X\nS : Set (Set X)\nhS : Nonempty â†‘S\nhSd : DirectedOn (fun x x_1 => x âŠ‡ x_1) S\nhSn : âˆ€ U âˆˆ S, U.Nonempty\nhSc : âˆ€ U âˆˆ S, IsCompact U\nhScl : âˆ€ U âˆˆ S, IsClosed U\nâŠ¢ (â‹‚â‚€ S).Nonempty"
    },
    {
      "name": "Mathlib.Meta.NormNum.isRat_div",
      "statement": "Î± : Type u_1\ninstâœ : DivisionRing Î±\nxâœÂ³ xâœÂ² : Î±\nxâœÂ¹ : â„¤\nxâœ : â„•\nh : IsRat (xâœÂ³ * xâœÂ²â»Â¹) xâœÂ¹ xâœ\nâŠ¢ IsRat (xâœÂ³ / xâœÂ²) xâœÂ¹ xâœ"
    },
    {
      "name": "SimpleGraph.mem_incidence_iff_neighbor",
      "statement": "Î¹ : Sort u_1\nV : Type u\nG : SimpleGraph V\na b c u vâœ wâœ : V\ne : Sym2 V\nv w : V\nâŠ¢ s(v, w) âˆˆ G.incidenceSet v â†” w âˆˆ G.neighborSet v"
    },
    {
      "name": "LieModule.mem_weightSpace",
      "statement": "K : Type u_1\nR : Type u_2\nL : Type u_3\nM : Type u_4\ninstâœâ· : CommRing R\ninstâœâ¶ : LieRing L\ninstâœâµ : LieAlgebra R L\ninstâœâ´ : LieAlgebra.IsNilpotent R L\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\ninstâœÂ¹ : LieRingModule L M\ninstâœ : LieModule R L M\nÏ‡ : L â†’ R\nm : M\nâŠ¢ m âˆˆ weightSpace M Ï‡ â†” âˆ€ (x : L), âˆƒ k, (((toEnd R L M) x - Ï‡ x â€¢ 1) ^ k) m = 0"
    },
    {
      "name": "ZMod.natAbs_mod_two",
      "statement": "a : â„¤\nâŠ¢ â†‘a.natAbs = â†‘a"
    },
    {
      "name": "conjugate_le_conjugate'",
      "statement": "R : Type u\ninstâœÂ³ : NonUnitalSemiring R\ninstâœÂ² : PartialOrder R\ninstâœÂ¹ : StarRing R\ninstâœ : StarOrderedRing R\na b : R\nhab : a â‰¤ b\nc : R\nâŠ¢ c * a * star c â‰¤ c * b * star c"
    },
    {
      "name": "Quiver.Hom.cast_heq",
      "statement": "U : Type u_1\ninstâœ : Quiver U\nu v u' v' : U\nhu : u = u'\nhv : v = v'\ne : u âŸ¶ v\nâŠ¢ HEq (cast hu hv e) e"
    },
    {
      "name": "IsPGroup.powEquiv_symm_apply",
      "statement": "p : â„•\nG : Type u_1\ninstâœ : Group G\nhG : IsPGroup p G\nn : â„•\nhn : p.Coprime n\ng : G\nâŠ¢ (hG.powEquiv hn).symm g = g ^ (orderOf g).gcdB n"
    },
    {
      "name": "MeasureTheory.lintegral_tilted",
      "statement": "Î± : Type u_1\nmÎ± : MeasurableSpace Î±\nÎ¼ : Measure Î±\nfâœ f : Î± â†’ â„\ng : Î± â†’ â„â‰¥0âˆ\nâŠ¢ âˆ«â» (x : Î±), g x âˆ‚Î¼.tilted f = âˆ«â» (x : Î±), ENNReal.ofReal (rexp (f x) / âˆ« (x : Î±), rexp (f x) âˆ‚Î¼) * g x âˆ‚Î¼"
    },
    {
      "name": "isLUB_iff_sSup_eq",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ²â‚‚ : Type u_3\nÎ³ : Type u_4\nÎ¹ : Sort u_5\nÎ¹' : Sort u_6\nÎº : Î¹ â†’ Sort u_7\nÎº' : Î¹' â†’ Sort u_8\ninstâœ : CompleteSemilatticeSup Î±\ns t : Set Î±\na b : Î±\nâŠ¢ sSup s = a â†’ IsLUB s a"
    },
    {
      "name": "Zsqrtd.norm_intCast",
      "statement": "d n : â„¤\nâŠ¢ (â†‘n).norm = n * n"
    },
    {
      "name": "AlgebraicGeometry.IsAffineOpen.isQuasiSeparated",
      "statement": "Xâœ Y : Scheme\nf : Xâœ âŸ¶ Y\nX : Scheme\nU : Opens â†‘â†‘X.toPresheafedSpace\nhU : IsAffineOpen U\nâŠ¢ IsQuasiSeparated â†‘U"
    },
    {
      "name": "NonUnitalSemiring.toNonUnitalNonAssocSemiring_injective",
      "statement": "R : Type u\nâŠ¢ Function.Injective (@toNonUnitalNonAssocSemiring R)"
    },
    {
      "name": "Filter.exists_eventually_atBot",
      "statement": "Î¹ : Type u_1\nÎ¹' : Type u_2\nÎ± : Type u_3\nÎ² : Type u_4\nÎ³ : Type u_5\ninstâœÂ¹ : SemilatticeInf Î±\ninstâœ : Nonempty Î±\nr : Î± â†’ Î² â†’ Prop\nâŠ¢ (âˆƒ b, âˆ€á¶  (a : Î±) in atBot, r a b) â†” âˆ€á¶  (aâ‚€ : Î±) in atBot, âˆƒ b, âˆ€ a â‰¤ aâ‚€, r a b"
    },
    {
      "name": "HurwitzZeta.completedCosZeta_one_sub",
      "statement": "a : UnitAddCircle\ns : â„‚\nâŠ¢ completedCosZeta a (1 - s) = completedHurwitzZetaEven a s"
    },
    {
      "name": "LieAlgebra.IsSemisimple.isSimple_of_isAtom",
      "statement": "R : Type u_1\nL : Type u_2\ninstâœÂ³ : CommRing R\ninstâœÂ² : LieRing L\ninstâœÂ¹ : LieAlgebra R L\ninstâœ : IsSemisimple R L\nI : LieIdeal R L\nhI : IsAtom I\nâŠ¢ âˆ€ (I_1 : LieIdeal R â†¥â†‘I), I_1 = âŠ¥ âˆ¨ I_1 = âŠ¤"
    },
    {
      "name": "MetricSpace.ext",
      "statement": "Î±âœ : Type u\nÎ² : Type v\nX : Type u_1\nÎ¹ : Type u_2\ninstâœ : PseudoMetricSpace Î±âœ\nÎ± : Type u_3\nm m' : MetricSpace Î±\nh : PseudoMetricSpace.toDist = PseudoMetricSpace.toDist\nâŠ¢ m = m'"
    },
    {
      "name": "Real.ofCauchy_sup",
      "statement": "x y : â„\na b : CauSeq â„š abs\nâŠ¢ { cauchy := âŸ¦a âŠ” bâŸ§ } = Real.sup { cauchy := âŸ¦aâŸ§ } { cauchy := âŸ¦bâŸ§ }"
    },
    {
      "name": "Representation.asAlgebraHom_single",
      "statement": "k : Type u_1\nG : Type u_2\nV : Type u_3\ninstâœÂ³ : CommSemiring k\ninstâœÂ² : Monoid G\ninstâœÂ¹ : AddCommMonoid V\ninstâœ : Module k V\nÏ : Representation k G V\ng : G\nr : k\nâŠ¢ Ï.asAlgebraHom (Finsupp.single g r) = r â€¢ Ï g"
    },
    {
      "name": "Set.iInterâ‚‚_union",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ¹ : Sort u_4\nÎ¹' : Sort u_5\nÎ¹â‚‚ : Sort u_6\nÎº : Î¹ â†’ Sort u_7\nÎºâ‚ : Î¹ â†’ Sort u_8\nÎºâ‚‚ : Î¹ â†’ Sort u_9\nÎº' : Î¹' â†’ Sort u_10\ns : (i : Î¹) â†’ Îº i â†’ Set Î±\nt : Set Î±\nâŠ¢ (â‹‚ i, â‹‚ j, s i j) âˆª t = â‹‚ i, â‹‚ j, s i j âˆª t"
    },
    {
      "name": "FreeGroup.invRev_length",
      "statement": "Î± : Type u\nL Lâ‚ Lâ‚‚ Lâ‚ƒ Lâ‚„ : List (Î± Ã— Bool)\nâŠ¢ (invRev Lâ‚).length = Lâ‚.length"
    },
    {
      "name": "LinearMap.IsProj.eq_conj_prod_map'",
      "statement": "R : Type u_1\ninstâœâ¹ : Ring R\nE : Type u_2\ninstâœâ¸ : AddCommGroup E\ninstâœâ· : Module R E\nF : Type u_3\ninstâœâ¶ : AddCommGroup F\ninstâœâµ : Module R F\nG : Type u_4\ninstâœâ´ : AddCommGroup G\ninstâœÂ³ : Module R G\np q : Submodule R E\nS : Type u_5\ninstâœÂ² : Semiring S\nM : Type u_6\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : Module S M\nm : Submodule S M\nf : E â†’â‚—[R] E\nh : IsProj p f\nâŠ¢ f = â†‘(p.prodEquivOfIsCompl (ker f) â‹¯) âˆ˜â‚— id.prodMap 0 âˆ˜â‚— â†‘(p.prodEquivOfIsCompl (ker f) â‹¯).symm"
    },
    {
      "name": "Ideal.isCoprime_iff_add",
      "statement": "R : Type u\nÎ¹ : Type u_1\ninstâœ : CommSemiring R\nI J K L : Ideal R\nâŠ¢ IsCoprime I J â†” I + J = 1"
    },
    {
      "name": "InnerProductGeometry.sin_angle_add_mul_norm_of_inner_eq_zero",
      "statement": "V : Type u_1\ninstâœÂ¹ : NormedAddCommGroup V\ninstâœ : InnerProductSpace â„ V\nx y : V\nh : âŸªx, yâŸ«_â„ = 0\nâŠ¢ Real.sin (angle x (x + y)) * â€–x + yâ€– = â€–yâ€–"
    },
    {
      "name": "Finset.isGLB_mem",
      "statement": "F : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\nÎ¹ : Type u_5\nÎº : Type u_6\ninstâœ : LinearOrder Î±\ni : Î±\ns : Finset Î±\nhis : IsGLB (â†‘s) i\nhs : s.Nonempty\nâŠ¢ i âˆˆ s"
    },
    {
      "name": "IsBoundedLinearMap.snd",
      "statement": "ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nâŠ¢ IsBoundedLinearMap ğ•œ fun x => x.2"
    },
    {
      "name": "Ring.inverse_pow",
      "statement": "Î± : Type u_1\nMâ‚€ : Type u_2\nGâ‚€ : Type u_3\nMâ‚€' : Type u_4\nGâ‚€' : Type u_5\nF : Type u_6\nF' : Type u_7\ninstâœ : MonoidWithZero Mâ‚€\nr : Mâ‚€\nâŠ¢ inverse r ^ 0 = inverse (r ^ 0)"
    },
    {
      "name": "intervalIntegral.integral_Iio_add_Ici",
      "statement": "Î¹ : Type u_1\nğ•œ : Type u_2\nE : Type u_3\nF : Type u_4\nA : Type u_5\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : CompleteSpace E\ninstâœ : NormedSpace â„ E\na b c d : â„\nf g : â„ â†’ E\nÎ¼ : Measure â„\nh_left : IntegrableOn f (Iio b) Î¼\nh_right : IntegrableOn f (Ici b) Î¼\nâŠ¢ âˆ« (x : â„) in Iio b, f x âˆ‚Î¼ + âˆ« (x : â„) in Ici b, f x âˆ‚Î¼ = âˆ« (x : â„), f x âˆ‚Î¼"
    },
    {
      "name": "MeasureTheory.lintegral_zero",
      "statement": "Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\nm : MeasurableSpace Î±\nÎ¼ Î½ : Measure Î±\nâŠ¢ âˆ«â» (x : Î±), 0 âˆ‚Î¼ = 0"
    },
    {
      "name": "Zsqrtd.le_antisymm",
      "statement": "d : â„•\ndnsq : Nonsquare d\na b : â„¤âˆšâ†‘d\nab : a â‰¤ b\nba : b â‰¤ a\nâŠ¢ (-(a - b)).Nonneg"
    },
    {
      "name": "Ideal.iInf_span_singleton",
      "statement": "R : Type u\nÎ¹âœ : Type u_1\ninstâœÂ¹ : CommSemiring R\nIâœ J K L : Ideal R\nÎ¹ : Type u_2\ninstâœ : Fintype Î¹\nI : Î¹ â†’ R\nhI : âˆ€ (i j : Î¹), i â‰  j â†’ IsCoprime (I i) (I j)\nâŠ¢ â¨… i, span {I i} = span {âˆ i : Î¹, I i}"
    },
    {
      "name": "unitInterval.mem_iff_one_sub_mem",
      "statement": "t : â„\nâŠ¢ t âˆˆ I â†” 1 - t âˆˆ I"
    },
    {
      "name": "Algebra.TensorProduct.basis_repr_symm_apply",
      "statement": "R : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\nC : Type uC\nD : Type uD\nE : Type uE\nF : Type uF\nM : Type uM\nÎ¹ : Type uÎ¹\ninstâœâ´ : CommSemiring R\ninstâœÂ³ : Semiring A\ninstâœÂ² : Algebra R A\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : Module R M\nb : Basis Î¹ R M\na : A\ni : Î¹\nâŠ¢ (basis A b).repr.symm (Finsupp.single i a) = a âŠ—â‚œ[R] b.repr.symm (Finsupp.single i 1)"
    },
    {
      "name": "LinearPMap.inverse_graph",
      "statement": "R : Type u_1\ninstâœâ¶ : Ring R\nE : Type u_2\ninstâœâµ : AddCommGroup E\ninstâœâ´ : Module R E\nF : Type u_3\ninstâœÂ³ : AddCommGroup F\ninstâœÂ² : Module R F\nG : Type u_4\ninstâœÂ¹ : AddCommGroup G\ninstâœ : Module R G\nf : E â†’â‚—.[R] F\nhf : LinearMap.ker f.toFun = âŠ¥\nâŠ¢ f.inverse.graph = Submodule.map (LinearEquiv.prodComm R E F) f.graph"
    },
    {
      "name": "Nat.count_one",
      "statement": "p : â„• â†’ Prop\ninstâœ : DecidablePred p\nâŠ¢ count p 1 = if p 0 then 1 else 0"
    }
  ]
}
